Deep analysis enabled
For class -> Animation
[]
[]
For class -> _AlwaysCompleteAnimation
[]
[]
For class -> _AlwaysDismissedAnimation
[]
[]
For class -> AlwaysStoppedAnimation
[this.value]
[T value]
For class -> ProxyAnimation
[Animation<double>? animation]
[[Animation<double>? animation]]
For class -> ReverseAnimation
[this.parent]
[Animation<double> parent]
For class -> CurvedAnimation
[required this.parent, required this.curve, this.reverseCurve]
[{required Animation<double> parent}, {required Curve curve}, {Curve? reverseCurve}]
For class -> TrainHoppingAnimation
[Animation<double> this._currentTrain, this._nextTrain, this.onSwitchedTrain]
[Animation<double> _currentTrain, Animation<double>? _nextTrain, {void Function()? onSwitchedTrain}]
For class -> CompoundAnimation
[required this.first, required this.next]
[{required Animation<T> first}, {required Animation<T> next}]
For class -> AnimationMean
[required Animation<double> left, required Animation<double> right]
[{required Animation<double> left}, {required Animation<double> right}]
For class -> AnimationMax
[Animation<T> first, Animation<T> next]
[Animation<T> first, Animation<T> next]
For class -> AnimationMin
[Animation<T> first, Animation<T> next]
[Animation<T> first, Animation<T> next]
For class -> AnimationController
[double? value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, required TickerProvider vsync]
[{double? value}, {Duration? duration}, {Duration? reverseDuration}, {String? debugLabel}, {double lowerBound = 0.0}, {double upperBound = 1.0}, {AnimationBehavior animationBehavior = AnimationBehavior.normal}, {required TickerProvider vsync}]
[double value = 0.0, this.duration, this.reverseDuration, this.debugLabel, required TickerProvider vsync, this.animationBehavior = AnimationBehavior.preserve]
[{double value = 0.0}, {Duration? duration}, {Duration? reverseDuration}, {String? debugLabel}, {required TickerProvider vsync}, {AnimationBehavior animationBehavior = AnimationBehavior.preserve}]
For class -> _InterpolationSimulation
[this._begin, this._end, Duration duration, this._curve, double scale]
[double _begin, double _end, Duration duration, Curve _curve, double scale]
For class -> _RepeatingSimulation
[double initialValue, this.min, this.max, this.reverse, Duration period, this.directionSetter]
[double initialValue, double min, double max, bool reverse, Duration period, void Function(_AnimationDirection) directionSetter]
For class -> ParametricCurve
[]
[]
For class -> Curve
[]
[]
For class -> _Linear
[]
[]
For class -> SawTooth
[this.count]
[int count]
For class -> Interval
[this.begin, this.end, this.curve = Curves.linear]
[double begin, double end, {Curve curve = Curves.linear}]
For class -> Threshold
[this.threshold]
[double threshold]
For class -> Cubic
[this.a, this.b, this.c, this.d]
[double a, double b, double c, double d]
For class -> Curve2D
[]
[]
For class -> Curve2DSample
[this.t, this.value]
[double t, Offset value]
For class -> CatmullRomSpline
[List<Offset> controlPoints, double tension = 0.0, Offset? startHandle, Offset? endHandle]
[List<Offset> controlPoints, {double tension = 0.0}, {Offset? startHandle}, {Offset? endHandle}]
[List<Offset> controlPoints, double tension = 0.0, Offset? startHandle, Offset? endHandle]
[List<Offset> controlPoints, {double tension = 0.0}, {Offset? startHandle}, {Offset? endHandle}]
For class -> CatmullRomCurve
[this.controlPoints, this.tension = 0.0]
[List<Offset> controlPoints, {double tension = 0.0}]
[this.controlPoints, this.tension = 0.0]
[List<Offset> controlPoints, {double tension = 0.0}]
For class -> FlippedCurve
[this.curve]
[Curve curve]
For class -> _DecelerateCurve
[]
[]
For class -> _BounceInCurve
[]
[]
For class -> _BounceOutCurve
[]
[]
For class -> _BounceInOutCurve
[]
[]
For class -> ElasticInCurve
[this.period = 0.4]
[[double period = 0.4]]
For class -> ElasticOutCurve
[this.period = 0.4]
[[double period = 0.4]]
For class -> ElasticInOutCurve
[this.period = 0.4]
[[double period = 0.4]]
For class -> Curves
[]
[]
For class -> Animatable
[]
[]
For class -> _AnimatedEvaluation
[this.parent, this._evaluatable]
[Animation<double> parent, Animatable<T> _evaluatable]
For class -> _ChainedEvaluation
[this._parent, this._evaluatable]
[Animatable<double> _parent, Animatable<T> _evaluatable]
For class -> Tween
[this.begin, this.end]
[{T? begin}, {T? end}]
For class -> ReverseTween
[this.parent]
[Tween<T> parent]
For class -> ColorTween
[Color? begin, Color? end]
[{Color? begin}, {Color? end}]
For class -> SizeTween
[Size? begin, Size? end]
[{Size? begin}, {Size? end}]
For class -> RectTween
[Rect? begin, Rect? end]
[{Rect? begin}, {Rect? end}]
For class -> IntTween
[int? begin, int? end]
[{int? begin}, {int? end}]
For class -> StepTween
[int? begin, int? end]
[{int? begin}, {int? end}]
For class -> ConstantTween
[T value]
[T value]
For class -> CurveTween
[required this.curve]
[{required Curve curve}]
For class -> TweenSequence
[List<TweenSequenceItem<T>> items]
[List<TweenSequenceItem<T>> items]
For class -> FlippedTweenSequence
[List<TweenSequenceItem<double>> items]
[List<TweenSequenceItem<double>> items]
For class -> TweenSequenceItem
[required this.tween, required this.weight]
[{required Animatable<T> tween}, {required double weight}]
For class -> _Interval
[this.start, this.end]
[double start, double end]
For class -> CupertinoActionSheet
[Key? key, this.title, this.message, this.actions, this.messageScrollController, this.actionScrollController, this.cancelButton]
[{Key? key}, {Widget? title}, {Widget? message}, {List<Widget>? actions}, {ScrollController? messageScrollController}, {ScrollController? actionScrollController}, {Widget? cancelButton}]
For class -> CupertinoActionSheetAction
[Key? key, required this.onPressed, this.isDefaultAction = false, this.isDestructiveAction = false, required this.child]
[{Key? key}, {required void Function() onPressed}, {bool isDefaultAction = false}, {bool isDestructiveAction = false}, {required Widget child}]
For class -> _CupertinoActionSheetCancelButton
[Key? key, this.child]
[{Key? key}, {Widget? child}]
For class -> _CupertinoActionSheetCancelButtonState
For class -> _CupertinoAlertRenderWidget
[Key? key, required this.contentSection, required this.actionsSection]
[{Key? key}, {required Widget contentSection}, {required Widget actionsSection}]
For class -> _CupertinoAlertRenderElement
[_CupertinoAlertRenderWidget widget]
[_CupertinoAlertRenderWidget widget]
For class -> _RenderCupertinoAlert
[RenderBox? contentSection, RenderBox? actionsSection, double dividerThickness = 0.0, required Color dividerColor]
[{RenderBox? contentSection}, {RenderBox? actionsSection}, {double dividerThickness = 0.0}, {required Color dividerColor}]
For class -> _AlertSizes
[required this.size, required this.contentHeight]
[{required Size size}, {required double contentHeight}]
For class -> _CupertinoAlertContentSection
[Key? key, this.title, this.message, this.scrollController]
[{Key? key}, {Widget? title}, {Widget? message}, {ScrollController? scrollController}]
For class -> _CupertinoAlertActionSection
[Key? key, required this.children, this.scrollController, this.hasCancelButton]
[{Key? key}, {required List<Widget> children}, {ScrollController? scrollController}, {bool? hasCancelButton}]
For class -> _CupertinoAlertActionSectionState
For class -> _PressableActionButton
[required this.child]
[{required Widget child}]
For class -> _PressableActionButtonState
For class -> _ActionButtonParentDataWidget
[Key? key, required this.isPressed, required Widget child]
[{Key? key}, {required bool isPressed}, {required Widget child}]
For class -> _ActionButtonParentData
[this.isPressed = false]
[{bool isPressed = false}]
For class -> _CupertinoAlertActionsRenderWidget
[Key? key, required List<Widget> actionButtons, double dividerThickness = 0.0, bool hasCancelButton = false]
[{Key? key}, {required List<Widget> actionButtons}, {double dividerThickness = 0.0}, {bool hasCancelButton = false}]
For class -> _RenderCupertinoAlertActions
[List<RenderBox>? children, double dividerThickness = 0.0, required Color dividerColor, bool hasCancelButton = false, required Color backgroundColor, required Color pressedColor]
[{List<RenderBox>? children}, {double dividerThickness = 0.0}, {required Color dividerColor}, {bool hasCancelButton = false}, {required Color backgroundColor}, {required Color pressedColor}]
For class -> CupertinoActivityIndicator
[Key? key, this.animating = true, this.radius = _kDefaultIndicatorRadius]
[{Key? key}, {bool animating = true}, {double radius = _kDefaultIndicatorRadius}]
[Key? key, this.radius = _kDefaultIndicatorRadius, this.progress = 1.0]
[{Key? key}, {double radius = _kDefaultIndicatorRadius}, {double progress = 1.0}]
For class -> _CupertinoActivityIndicatorState
For class -> _CupertinoActivityIndicatorPainter
[required this.position, required this.activeColor, required this.radius, required this.progress]
[{required Animation<double> position}, {required Color activeColor}, {required double radius}, {required double progress}]
For class -> CupertinoApp
[Key? key, this.navigatorKey, this.home, this.theme, Map<String, Widget Function(BuildContext)> this.routes = const <String, WidgetBuilder>{}, this.initialRoute, this.onGenerateRoute, this.onGenerateInitialRoutes, this.onUnknownRoute, List<NavigatorObserver> this.navigatorObservers = const <NavigatorObserver>[], this.builder, this.title = '', this.onGenerateTitle, this.color, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {GlobalKey<NavigatorState>? navigatorKey}, {Widget? home}, {CupertinoThemeData? theme}, {Map<String, Widget Function(BuildContext)> routes = const <String, WidgetBuilder>{}}, {String? initialRoute}, {Route<dynamic>? Function(RouteSettings)? onGenerateRoute}, {List<Route<dynamic>> Function(String)? onGenerateInitialRoutes}, {Route<dynamic>? Function(RouteSettings)? onUnknownRoute}, {List<NavigatorObserver> navigatorObservers = const <NavigatorObserver>[]}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {Color? color}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowCheckedModeBanner = true}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
[Key? key, this.routeInformationProvider, required RouteInformationParser<Object> this.routeInformationParser, required RouterDelegate<Object> this.routerDelegate, this.backButtonDispatcher, this.theme, this.builder, this.title = '', this.onGenerateTitle, this.color, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {RouteInformationProvider? routeInformationProvider}, {required RouteInformationParser<Object> routeInformationParser}, {required RouterDelegate<Object> routerDelegate}, {BackButtonDispatcher? backButtonDispatcher}, {CupertinoThemeData? theme}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {Color? color}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowCheckedModeBanner = true}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
For class -> _AlwaysCupertinoScrollBehavior
For class -> _CupertinoAppState
For class -> CupertinoTabBar
[Key? key, required this.items, this.onTap, this.currentIndex = 0, this.backgroundColor, this.activeColor, this.inactiveColor = _kDefaultTabBarInactiveColor, this.iconSize = 30.0, this.border = const Border(top: BorderSide(color: _kDefaultTabBarBorderColor, width: 0.0, style: BorderStyle.solid))]
[{Key? key}, {required List<BottomNavigationBarItem> items}, {void Function(int)? onTap}, {int currentIndex = 0}, {Color? backgroundColor}, {Color? activeColor}, {Color inactiveColor = _kDefaultTabBarInactiveColor}, {double iconSize = 30.0}, {Border? border = const Border(top: BorderSide(color: _kDefaultTabBarBorderColor, width: 0.0, style: BorderStyle.solid))}]
For class -> CupertinoButton
[Key? key, required this.child, this.padding, this.color, this.disabledColor = CupertinoColors.quaternarySystemFill, this.minSize = kMinInteractiveDimensionCupertino, this.pressedOpacity = 0.4, this.borderRadius = const BorderRadius.all(Radius.circular(8.0)), this.alignment = Alignment.center, required this.onPressed]
[{Key? key}, {required Widget child}, {EdgeInsetsGeometry? padding}, {Color? color}, {Color disabledColor = CupertinoColors.quaternarySystemFill}, {double? minSize = kMinInteractiveDimensionCupertino}, {double? pressedOpacity = 0.4}, {BorderRadius? borderRadius = const BorderRadius.all(Radius.circular(8.0))}, {AlignmentGeometry alignment = Alignment.center}, {required void Function()? onPressed}]
[Key? key, required this.child, this.padding, this.disabledColor = CupertinoColors.quaternarySystemFill, this.minSize = kMinInteractiveDimensionCupertino, this.pressedOpacity = 0.4, this.borderRadius = const BorderRadius.all(Radius.circular(8.0)), this.alignment = Alignment.center, required this.onPressed]
[{Key? key}, {required Widget child}, {EdgeInsetsGeometry? padding}, {Color disabledColor = CupertinoColors.quaternarySystemFill}, {double? minSize = kMinInteractiveDimensionCupertino}, {double? pressedOpacity = 0.4}, {BorderRadius? borderRadius = const BorderRadius.all(Radius.circular(8.0))}, {AlignmentGeometry alignment = Alignment.center}, {required void Function()? onPressed}]
For class -> _CupertinoButtonState
For class -> CupertinoColors
[]
[]
For class -> CupertinoDynamicColor
[String? debugLabel, required Color color, required Color darkColor, required Color highContrastColor, required Color darkHighContrastColor, required Color elevatedColor, required Color darkElevatedColor, required Color highContrastElevatedColor, required Color darkHighContrastElevatedColor]
[{String? debugLabel}, {required Color color}, {required Color darkColor}, {required Color highContrastColor}, {required Color darkHighContrastColor}, {required Color elevatedColor}, {required Color darkElevatedColor}, {required Color highContrastElevatedColor}, {required Color darkHighContrastElevatedColor}]
[String? debugLabel, required Color color, required Color darkColor, required Color highContrastColor, required Color darkHighContrastColor]
[{String? debugLabel}, {required Color color}, {required Color darkColor}, {required Color highContrastColor}, {required Color darkHighContrastColor}]
[String? debugLabel, required Color color, required Color darkColor]
[{String? debugLabel}, {required Color color}, {required Color darkColor}]
[this._effectiveColor, this.color, this.darkColor, this.highContrastColor, this.darkHighContrastColor, this.elevatedColor, this.darkElevatedColor, this.highContrastElevatedColor, this.darkHighContrastElevatedColor, this._debugResolveContext, this._debugLabel]
[Color _effectiveColor, Color color, Color darkColor, Color highContrastColor, Color darkHighContrastColor, Color elevatedColor, Color darkElevatedColor, Color highContrastElevatedColor, Color darkHighContrastElevatedColor, Element? _debugResolveContext, String? _debugLabel]
For class -> CupertinoContextMenu
[Key? key, required this.actions, required this.child, this.previewBuilder]
[{Key? key}, {required List<Widget> actions}, {required Widget child}, {Widget Function(BuildContext, Animation<double>, Widget)? previewBuilder}]
For class -> _CupertinoContextMenuState
For class -> _DecoyChild
[Key? key, this.beginRect, required this.controller, this.endRect, this.child]
[{Key? key}, {Rect? beginRect}, {required AnimationController controller}, {Rect? endRect}, {Widget? child}]
For class -> _DecoyChildState
For class -> _ContextMenuRoute
[required List<Widget> actions, required _ContextMenuLocation contextMenuLocation, this.barrierLabel, _ContextMenuPreviewBuilderChildless? builder, ui.ImageFilter? filter, required Rect previousChildRect, RouteSettings? settings]
[{required List<Widget> actions}, {required _ContextMenuLocation contextMenuLocation}, {String? barrierLabel}, {Widget Function(BuildContext, Animation<double>)? builder}, {ImageFilter? filter}, {required Rect previousChildRect}, {RouteSettings? settings}]
For class -> _ContextMenuRouteStatic
[Key? key, this.actions, required this.child, this.childGlobalKey, required this.contextMenuLocation, this.onDismiss, required this.orientation, this.sheetGlobalKey]
[{Key? key}, {List<Widget>? actions}, {required Widget child}, {GlobalKey<State<StatefulWidget>>? childGlobalKey}, {required _ContextMenuLocation contextMenuLocation}, {void Function(BuildContext, double, double)? onDismiss}, {required Orientation orientation}, {GlobalKey<State<StatefulWidget>>? sheetGlobalKey}]
For class -> _ContextMenuRouteStaticState
For class -> _ContextMenuSheet
[Key? key, required this.actions, required _ContextMenuLocation contextMenuLocation, required Orientation orientation]
[{Key? key}, {required List<Widget> actions}, {required _ContextMenuLocation contextMenuLocation}, {required Orientation orientation}]
For class -> _OnOffAnimation
[required AnimationController controller, required T onValue, required T offValue, required double intervalOn, required double intervalOff]
[{required AnimationController controller}, {required T onValue}, {required T offValue}, {required double intervalOn}, {required double intervalOff}]
For class -> CupertinoContextMenuAction
[Key? key, required this.child, this.isDefaultAction = false, this.isDestructiveAction = false, this.onPressed, this.trailingIcon]
[{Key? key}, {required Widget child}, {bool isDefaultAction = false}, {bool isDestructiveAction = false}, {void Function()? onPressed}, {IconData? trailingIcon}]
For class -> _CupertinoContextMenuActionState
For class -> _DatePickerLayoutDelegate
[required this.columnWidths, required this.textDirectionFactor]
[{required List<double> columnWidths}, {required int textDirectionFactor}]
For class -> CupertinoDatePicker
[Key? key, this.mode = CupertinoDatePickerMode.dateAndTime, required this.onDateTimeChanged, DateTime? initialDateTime, this.minimumDate, this.maximumDate, this.minimumYear = 1, this.maximumYear, this.minuteInterval = 1, this.use24hFormat = false, this.backgroundColor]
[{Key? key}, {CupertinoDatePickerMode mode = CupertinoDatePickerMode.dateAndTime}, {required void Function(DateTime) onDateTimeChanged}, {DateTime? initialDateTime}, {DateTime? minimumDate}, {DateTime? maximumDate}, {int minimumYear = 1}, {int? maximumYear}, {int minuteInterval = 1}, {bool use24hFormat = false}, {Color? backgroundColor}]
For class -> _CupertinoDatePickerDateTimeState
For class -> _CupertinoDatePickerDateState
For class -> CupertinoTimerPicker
[Key? key, this.mode = CupertinoTimerPickerMode.hms, this.initialTimerDuration = Duration.zero, this.minuteInterval = 1, this.secondInterval = 1, this.alignment = Alignment.center, this.backgroundColor, required this.onTimerDurationChanged]
[{Key? key}, {CupertinoTimerPickerMode mode = CupertinoTimerPickerMode.hms}, {Duration initialTimerDuration = Duration.zero}, {int minuteInterval = 1}, {int secondInterval = 1}, {AlignmentGeometry alignment = Alignment.center}, {Color? backgroundColor}, {required void Function(Duration) onTimerDurationChanged}]
For class -> _CupertinoTimerPickerState
For class -> _CupertinoDesktopTextSelectionControls
For class -> _CupertinoDesktopTextSelectionControlsToolbar
[Key? key, required this.clipboardStatus, required this.endpoints, required this.globalEditableRegion, required this.handleCopy, required this.handleCut, required this.handlePaste, required this.handleSelectAll, required this.selectionMidpoint, required this.textLineHeight, required this.lastSecondaryTapDownPosition]
[{Key? key}, {required ClipboardStatusNotifier? clipboardStatus}, {required List<TextSelectionPoint> endpoints}, {required Rect globalEditableRegion}, {required void Function()? handleCopy}, {required void Function()? handleCut}, {required void Function()? handlePaste}, {required void Function()? handleSelectAll}, {required Offset selectionMidpoint}, {required double textLineHeight}, {required Offset? lastSecondaryTapDownPosition}]
For class -> _CupertinoDesktopTextSelectionControlsToolbarState
For class -> _CupertinoDesktopTextSelectionToolbar
[Key? key, required this.anchor, required this.children, this.toolbarBuilder = _defaultToolbarBuilder]
[{Key? key}, {required Offset anchor}, {required List<Widget> children}, {Widget Function(BuildContext, Widget) toolbarBuilder = _defaultToolbarBuilder}]
For class -> _CupertinoDesktopTextSelectionToolbarButton
[Key? key, required this.onPressed, required this.child]
[{Key? key}, {required void Function() onPressed}, {required Widget child}]
[Key? key, required BuildContext context, required this.onPressed, required String text]
[{Key? key}, {required BuildContext context}, {required void Function() onPressed}, {required String text}]
For class -> _CupertinoDesktopTextSelectionToolbarButtonState
For class -> CupertinoAlertDialog
[Key? key, this.title, this.content, this.actions = const <Widget>[], this.scrollController, this.actionScrollController, this.insetAnimationDuration = const Duration(milliseconds: 100), this.insetAnimationCurve = Curves.decelerate]
[{Key? key}, {Widget? title}, {Widget? content}, {List<Widget> actions = const <Widget>[]}, {ScrollController? scrollController}, {ScrollController? actionScrollController}, {Duration insetAnimationDuration = const Duration(milliseconds: 100)}, {Curve insetAnimationCurve = Curves.decelerate}]
For class -> CupertinoPopupSurface
[Key? key, this.isSurfacePainted = true, this.child]
[{Key? key}, {bool isSurfacePainted = true}, {Widget? child}]
For class -> _CupertinoDialogRenderWidget
[Key? key, required this.contentSection, required this.actionsSection]
[{Key? key}, {required Widget contentSection}, {required Widget actionsSection}]
For class -> _CupertinoDialogRenderElement
[_CupertinoDialogRenderWidget widget]
[_CupertinoDialogRenderWidget widget]
For class -> _RenderCupertinoDialog
[RenderBox? contentSection, RenderBox? actionsSection, double dividerThickness = 0.0, bool isInAccessibilityMode = false, required Color dividerColor]
[{RenderBox? contentSection}, {RenderBox? actionsSection}, {double dividerThickness = 0.0}, {bool isInAccessibilityMode = false}, {required Color dividerColor}]
For class -> _DialogSizes
[required this.size, required this.actionSectionYOffset]
[{required Size size}, {required double actionSectionYOffset}]
For class -> _CupertinoAlertContentSection
[Key? key, this.title, this.content, this.scrollController]
[{Key? key}, {Widget? title}, {Widget? content}, {ScrollController? scrollController}]
For class -> _CupertinoAlertActionSection
[Key? key, required this.children, this.scrollController]
[{Key? key}, {required List<Widget> children}, {ScrollController? scrollController}]
For class -> _CupertinoAlertActionSectionState
For class -> _PressableActionButton
[required this.child]
[{required Widget child}]
For class -> _PressableActionButtonState
For class -> _ActionButtonParentDataWidget
[Key? key, required this.isPressed, required Widget child]
[{Key? key}, {required bool isPressed}, {required Widget child}]
For class -> _ActionButtonParentData
[this.isPressed = false]
[{bool isPressed = false}]
For class -> CupertinoDialogAction
[Key? key, this.onPressed, this.isDefaultAction = false, this.isDestructiveAction = false, this.textStyle, required this.child]
[{Key? key}, {void Function()? onPressed}, {bool isDefaultAction = false}, {bool isDestructiveAction = false}, {TextStyle? textStyle}, {required Widget child}]
For class -> _CupertinoDialogActionsRenderWidget
[Key? key, required List<Widget> actionButtons, double dividerThickness = 0.0]
[{Key? key}, {required List<Widget> actionButtons}, {double dividerThickness = 0.0}]
For class -> _RenderCupertinoDialogActions
[List<RenderBox>? children, required double dialogWidth, double dividerThickness = 0.0, required Color dialogColor, required Color dialogPressedColor, required Color dividerColor]
[{List<RenderBox>? children}, {required double dialogWidth}, {double dividerThickness = 0.0}, {required Color dialogColor}, {required Color dialogPressedColor}, {required Color dividerColor}]
For class -> CupertinoFormRow
[Key? key, required this.child, this.prefix, this.padding, this.helper, this.error]
[{Key? key}, {required Widget child}, {Widget? prefix}, {EdgeInsetsGeometry? padding}, {Widget? helper}, {Widget? error}]
For class -> CupertinoFormSection
[Key? key, required this.children, this.header, this.footer, this.margin = EdgeInsets.zero, this.backgroundColor = CupertinoColors.systemGroupedBackground, this.decoration, this.clipBehavior = Clip.none]
[{Key? key}, {required List<Widget> children}, {Widget? header}, {Widget? footer}, {EdgeInsetsGeometry margin = EdgeInsets.zero}, {Color backgroundColor = CupertinoColors.systemGroupedBackground}, {BoxDecoration? decoration}, {Clip clipBehavior = Clip.none}]
[Key? key, required this.children, this.header, this.footer, this.margin = _kDefaultInsetGroupedRowsMargin, this.backgroundColor = CupertinoColors.systemGroupedBackground, this.decoration, this.clipBehavior = Clip.none]
[{Key? key}, {required List<Widget> children}, {Widget? header}, {Widget? footer}, {EdgeInsetsGeometry margin = _kDefaultInsetGroupedRowsMargin}, {Color backgroundColor = CupertinoColors.systemGroupedBackground}, {BoxDecoration? decoration}, {Clip clipBehavior = Clip.none}]
For class -> CupertinoIcons
[]
[]
For class -> CupertinoIconThemeData
[Color? color, double? opacity, double? size]
[{Color? color}, {double? opacity}, {double? size}]
For class -> CupertinoUserInterfaceLevel
[Key? key, required CupertinoUserInterfaceLevelData data, required Widget child]
[{Key? key}, {required CupertinoUserInterfaceLevelData data}, {required Widget child}]
For class -> CupertinoLocalizations
For class -> _CupertinoLocalizationsDelegate
[]
[]
For class -> DefaultCupertinoLocalizations
[]
[]
For class -> _HeroTag
[this.navigator]
[NavigatorState? navigator]
For class -> CupertinoNavigationBar
[Key? key, this.leading, this.automaticallyImplyLeading = true, this.automaticallyImplyMiddle = true, this.previousPageTitle, this.middle, this.trailing, this.border = _kDefaultNavBarBorder, this.backgroundColor, this.brightness, this.padding, this.transitionBetweenRoutes = true, this.heroTag = _defaultHeroTag]
[{Key? key}, {Widget? leading}, {bool automaticallyImplyLeading = true}, {bool automaticallyImplyMiddle = true}, {String? previousPageTitle}, {Widget? middle}, {Widget? trailing}, {Border? border = _kDefaultNavBarBorder}, {Color? backgroundColor}, {Brightness? brightness}, {EdgeInsetsDirectional? padding}, {bool transitionBetweenRoutes = true}, {Object heroTag = _defaultHeroTag}]
For class -> _CupertinoNavigationBarState
For class -> CupertinoSliverNavigationBar
[Key? key, this.largeTitle, this.leading, this.automaticallyImplyLeading = true, this.automaticallyImplyTitle = true, this.previousPageTitle, this.middle, this.trailing, this.border = _kDefaultNavBarBorder, this.backgroundColor, this.brightness, this.padding, this.transitionBetweenRoutes = true, this.heroTag = _defaultHeroTag, this.stretch = false]
[{Key? key}, {Widget? largeTitle}, {Widget? leading}, {bool automaticallyImplyLeading = true}, {bool automaticallyImplyTitle = true}, {String? previousPageTitle}, {Widget? middle}, {Widget? trailing}, {Border? border = _kDefaultNavBarBorder}, {Color? backgroundColor}, {Brightness? brightness}, {EdgeInsetsDirectional? padding}, {bool transitionBetweenRoutes = true}, {Object heroTag = _defaultHeroTag}, {bool stretch = false}]
For class -> _CupertinoSliverNavigationBarState
For class -> _LargeTitleNavigationBarSliverDelegate
[required this.keys, required this.components, required this.userMiddle, required this.backgroundColor, required this.brightness, required this.border, required this.padding, required this.actionsForegroundColor, required this.transitionBetweenRoutes, required this.heroTag, required this.persistentHeight, required this.alwaysShowMiddle, required this.stretchConfiguration]
[{required _NavigationBarStaticComponentsKeys keys}, {required _NavigationBarStaticComponents components}, {required Widget? userMiddle}, {required Color backgroundColor}, {required Brightness? brightness}, {required Border? border}, {required EdgeInsetsDirectional? padding}, {required Color actionsForegroundColor}, {required bool transitionBetweenRoutes}, {required Object heroTag}, {required double persistentHeight}, {required bool alwaysShowMiddle}, {required OverScrollHeaderStretchConfiguration? stretchConfiguration}]
For class -> _PersistentNavigationBar
[Key? key, required this.components, this.padding, this.middleVisible]
[{Key? key}, {required _NavigationBarStaticComponents components}, {EdgeInsetsDirectional? padding}, {bool? middleVisible}]
For class -> _NavigationBarStaticComponentsKeys
[]
[]
For class -> _NavigationBarStaticComponents
[required _NavigationBarStaticComponentsKeys keys, required ModalRoute<dynamic>? route, required Widget? userLeading, required bool automaticallyImplyLeading, required bool automaticallyImplyTitle, required String? previousPageTitle, required Widget? userMiddle, required Widget? userTrailing, required Widget? userLargeTitle, required EdgeInsetsDirectional? padding, required bool large]
[{required _NavigationBarStaticComponentsKeys keys}, {required ModalRoute<dynamic>? route}, {required Widget? userLeading}, {required bool automaticallyImplyLeading}, {required bool automaticallyImplyTitle}, {required String? previousPageTitle}, {required Widget? userMiddle}, {required Widget? userTrailing}, {required Widget? userLargeTitle}, {required EdgeInsetsDirectional? padding}, {required bool large}]
For class -> CupertinoNavigationBarBackButton
[Key? key, this.color, this.previousPageTitle, this.onPressed]
[{Key? key}, {Color? color}, {String? previousPageTitle}, {void Function()? onPressed}]
[this._backChevron, this._backLabel]
[Widget? _backChevron, Widget? _backLabel]
For class -> _BackChevron
[Key? key]
[{Key? key}]
For class -> _BackLabel
[Key? key, required this.specifiedPreviousTitle, required this.route]
[{Key? key}, {required String? specifiedPreviousTitle}, {required ModalRoute<dynamic>? route}]
For class -> _TransitionableNavigationBar
[required this.componentsKeys, required this.backgroundColor, required this.backButtonTextStyle, required this.titleTextStyle, required this.largeTitleTextStyle, required this.border, required this.hasUserMiddle, required this.largeExpanded, required this.child]
[{required _NavigationBarStaticComponentsKeys componentsKeys}, {required Color? backgroundColor}, {required TextStyle backButtonTextStyle}, {required TextStyle titleTextStyle}, {required TextStyle? largeTitleTextStyle}, {required Border? border}, {required bool hasUserMiddle}, {required bool largeExpanded}, {required Widget child}]
For class -> _NavigationBarTransition
[required this.animation, required this.topNavBar, required this.bottomNavBar]
[{required Animation<double> animation}, {required _TransitionableNavigationBar topNavBar}, {required _TransitionableNavigationBar bottomNavBar}]
For class -> _NavigationBarComponentsTransition
[required this.animation, required _TransitionableNavigationBar bottomNavBar, required _TransitionableNavigationBar topNavBar, required TextDirection directionality]
[{required Animation<double> animation}, {required _TransitionableNavigationBar bottomNavBar}, {required _TransitionableNavigationBar topNavBar}, {required TextDirection directionality}]
For class -> CupertinoPageScaffold
[Key? key, this.navigationBar, this.backgroundColor, this.resizeToAvoidBottomInset = true, required this.child]
[{Key? key}, {ObstructingPreferredSizeWidget? navigationBar}, {Color? backgroundColor}, {bool resizeToAvoidBottomInset = true}, {required Widget child}]
For class -> _CupertinoPageScaffoldState
For class -> ObstructingPreferredSizeWidget
For class -> CupertinoPicker
[Key? key, this.diameterRatio = _kDefaultDiameterRatio, this.backgroundColor, this.offAxisFraction = 0.0, this.useMagnifier = false, this.magnification = 1.0, this.scrollController, this.squeeze = _kSqueeze, required this.itemExtent, required this.onSelectedItemChanged, required List<Widget> children, this.selectionOverlay = const CupertinoPickerDefaultSelectionOverlay(), bool looping = false]
[{Key? key}, {double diameterRatio = _kDefaultDiameterRatio}, {Color? backgroundColor}, {double offAxisFraction = 0.0}, {bool useMagnifier = false}, {double magnification = 1.0}, {FixedExtentScrollController? scrollController}, {double squeeze = _kSqueeze}, {required double itemExtent}, {required void Function(int)? onSelectedItemChanged}, {required List<Widget> children}, {Widget selectionOverlay = const CupertinoPickerDefaultSelectionOverlay()}, {bool looping = false}]
[Key? key, this.diameterRatio = _kDefaultDiameterRatio, this.backgroundColor, this.offAxisFraction = 0.0, this.useMagnifier = false, this.magnification = 1.0, this.scrollController, this.squeeze = _kSqueeze, required this.itemExtent, required this.onSelectedItemChanged, required NullableIndexedWidgetBuilder itemBuilder, int? childCount, this.selectionOverlay = const CupertinoPickerDefaultSelectionOverlay()]
[{Key? key}, {double diameterRatio = _kDefaultDiameterRatio}, {Color? backgroundColor}, {double offAxisFraction = 0.0}, {bool useMagnifier = false}, {double magnification = 1.0}, {FixedExtentScrollController? scrollController}, {double squeeze = _kSqueeze}, {required double itemExtent}, {required void Function(int)? onSelectedItemChanged}, {required Widget? Function(BuildContext, int) itemBuilder}, {int? childCount}, {Widget selectionOverlay = const CupertinoPickerDefaultSelectionOverlay()}]
For class -> _CupertinoPickerState
For class -> CupertinoPickerDefaultSelectionOverlay
[Key? key, this.background = CupertinoColors.tertiarySystemFill, this.capLeftEdge = true, this.capRightEdge = true]
[{Key? key}, {Color background = CupertinoColors.tertiarySystemFill}, {bool capLeftEdge = true}, {bool capRightEdge = true}]
For class -> _CupertinoPickerSemantics
[Key? key, Widget? child, required this.scrollController]
[{Key? key}, {Widget? child}, {required FixedExtentScrollController scrollController}]
For class -> _RenderCupertinoPickerSemantics
[FixedExtentScrollController controller, this._textDirection]
[FixedExtentScrollController controller, TextDirection _textDirection]
For class -> _CupertinoSliverRefresh
[Key? key, this.refreshIndicatorLayoutExtent = 0.0, this.hasLayoutExtent = false, Widget? child]
[{Key? key}, {double refreshIndicatorLayoutExtent = 0.0}, {bool hasLayoutExtent = false}, {Widget? child}]
For class -> _RenderCupertinoSliverRefresh
[required double refreshIndicatorExtent, required bool hasLayoutExtent, RenderBox? child]
[{required double refreshIndicatorExtent}, {required bool hasLayoutExtent}, {RenderBox? child}]
For class -> CupertinoSliverRefreshControl
[Key? key, this.refreshTriggerPullDistance = _defaultRefreshTriggerPullDistance, this.refreshIndicatorExtent = _defaultRefreshIndicatorExtent, this.builder = buildRefreshIndicator, this.onRefresh]
[{Key? key}, {double refreshTriggerPullDistance = _defaultRefreshTriggerPullDistance}, {double refreshIndicatorExtent = _defaultRefreshIndicatorExtent}, {Widget Function(BuildContext, RefreshIndicatorMode, double, double, double)? builder = buildRefreshIndicator}, {Future<void> Function()? onRefresh}]
For class -> _CupertinoSliverRefreshControlState
For class -> CupertinoPageRoute
[required this.builder, this.title, RouteSettings? settings, this.maintainState = true, bool fullscreenDialog = false]
[{required Widget Function(BuildContext) builder}, {String? title}, {RouteSettings? settings}, {bool maintainState = true}, {bool fullscreenDialog = false}]
For class -> _PageBasedCupertinoPageRoute
[required CupertinoPage<T> page]
[{required CupertinoPage<T> page}]
For class -> CupertinoPage
[required this.child, this.maintainState = true, this.title, this.fullscreenDialog = false, LocalKey? key, String? name, Object? arguments]
[{required Widget child}, {bool maintainState = true}, {String? title}, {bool fullscreenDialog = false}, {LocalKey? key}, {String? name}, {Object? arguments}]
For class -> CupertinoPageTransition
[Key? key, required Animation<double> primaryRouteAnimation, required Animation<double> secondaryRouteAnimation, required this.child, required bool linearTransition]
[{Key? key}, {required Animation<double> primaryRouteAnimation}, {required Animation<double> secondaryRouteAnimation}, {required Widget child}, {required bool linearTransition}]
For class -> CupertinoFullscreenDialogTransition
[Key? key, required Animation<double> primaryRouteAnimation, required Animation<double> secondaryRouteAnimation, required this.child, required bool linearTransition]
[{Key? key}, {required Animation<double> primaryRouteAnimation}, {required Animation<double> secondaryRouteAnimation}, {required Widget child}, {required bool linearTransition}]
For class -> _CupertinoBackGestureDetector
[Key? key, required this.enabledCallback, required this.onStartPopGesture, required this.child]
[{Key? key}, {required bool Function() enabledCallback}, {required _CupertinoBackGestureController<T> Function() onStartPopGesture}, {required Widget child}]
For class -> _CupertinoBackGestureDetectorState
For class -> _CupertinoBackGestureController
[required this.navigator, required this.controller]
[{required NavigatorState navigator}, {required AnimationController controller}]
For class -> _CupertinoEdgeShadowDecoration
[this.edgeGradient]
[{LinearGradient? edgeGradient}]
For class -> _CupertinoEdgeShadowPainter
[this._decoration, VoidCallback? onChange]
[_CupertinoEdgeShadowDecoration _decoration, void Function()? onChange]
For class -> _CupertinoModalPopupRoute
[required this.barrierColor, required this.barrierLabel, required this.builder, bool? barrierDismissible, bool? semanticsDismissible, required ImageFilter? filter, RouteSettings? settings]
[{required Color? barrierColor}, {required String barrierLabel}, {required Widget Function(BuildContext) builder}, {bool? barrierDismissible}, {bool? semanticsDismissible}, {required ImageFilter? filter}, {RouteSettings? settings}]
For class -> CupertinoDialogRoute
[required WidgetBuilder builder, required BuildContext context, bool barrierDismissible = true, Color? barrierColor, String? barrierLabel, Duration transitionDuration = const Duration(milliseconds: 250), RouteTransitionsBuilder? transitionBuilder = _buildCupertinoDialogTransitions, RouteSettings? settings]
[{required Widget Function(BuildContext) builder}, {required BuildContext context}, {bool barrierDismissible = true}, {Color? barrierColor}, {String? barrierLabel}, {Duration transitionDuration = const Duration(milliseconds: 250)}, {Widget Function(BuildContext, Animation<double>, Animation<double>, Widget)? transitionBuilder = _buildCupertinoDialogTransitions}, {RouteSettings? settings}]
For class -> CupertinoScrollbar
[Key? key, required Widget child, ScrollController? controller, bool isAlwaysShown = false, double thickness = defaultThickness, this.thicknessWhileDragging = defaultThicknessWhileDragging, Radius radius = defaultRadius, this.radiusWhileDragging = defaultRadiusWhileDragging, ScrollNotificationPredicate? notificationPredicate]
[{Key? key}, {required Widget child}, {ScrollController? controller}, {bool isAlwaysShown = false}, {double thickness = defaultThickness}, {double thicknessWhileDragging = defaultThicknessWhileDragging}, {Radius radius = defaultRadius}, {Radius radiusWhileDragging = defaultRadiusWhileDragging}, {bool Function(ScrollNotification)? notificationPredicate}]
For class -> _CupertinoScrollbarState
For class -> CupertinoSearchTextField
[Key? key, this.controller, this.onChanged, this.onSubmitted, this.style, this.placeholder, this.placeholderStyle, this.decoration, this.backgroundColor, this.borderRadius, this.padding = const EdgeInsetsDirectional.fromSTEB(3.8, 8, 5, 8), this.itemColor = CupertinoColors.secondaryLabel, this.itemSize = 20.0, this.prefixInsets = const EdgeInsetsDirectional.fromSTEB(6, 0, 0, 4), this.suffixInsets = const EdgeInsetsDirectional.fromSTEB(0, 0, 5, 2), this.suffixIcon = const Icon(CupertinoIcons.xmark_circle_fill), this.suffixMode = OverlayVisibilityMode.editing, this.onSuffixTap, this.restorationId, this.focusNode]
[{Key? key}, {TextEditingController? controller}, {void Function(String)? onChanged}, {void Function(String)? onSubmitted}, {TextStyle? style}, {String? placeholder}, {TextStyle? placeholderStyle}, {BoxDecoration? decoration}, {Color? backgroundColor}, {BorderRadius? borderRadius}, {EdgeInsetsGeometry padding = const EdgeInsetsDirectional.fromSTEB(3.8, 8, 5, 8)}, {Color itemColor = CupertinoColors.secondaryLabel}, {double itemSize = 20.0}, {EdgeInsetsGeometry prefixInsets = const EdgeInsetsDirectional.fromSTEB(6, 0, 0, 4)}, {EdgeInsetsGeometry suffixInsets = const EdgeInsetsDirectional.fromSTEB(0, 0, 5, 2)}, {Icon suffixIcon = const Icon(CupertinoIcons.xmark_circle_fill)}, {OverlayVisibilityMode suffixMode = OverlayVisibilityMode.editing}, {void Function()? onSuffixTap}, {String? restorationId}, {FocusNode? focusNode}]
For class -> _CupertinoSearchTextFieldState
For class -> CupertinoSegmentedControl
[Key? key, required this.children, required this.onValueChanged, this.groupValue, this.unselectedColor, this.selectedColor, this.borderColor, this.pressedColor, this.padding]
[{Key? key}, {required Map<T, Widget> children}, {required void Function(T) onValueChanged}, {T? groupValue}, {Color? unselectedColor}, {Color? selectedColor}, {Color? borderColor}, {Color? pressedColor}, {EdgeInsetsGeometry? padding}]
For class -> _SegmentedControlState
For class -> _SegmentedControlRenderWidget
[Key? key, List<Widget> children = const <Widget>[], required this.selectedIndex, required this.pressedIndex, required this.backgroundColors, required this.borderColor]
[{Key? key}, {List<Widget> children = const <Widget>[]}, {required int? selectedIndex}, {required int? pressedIndex}, {required List<Color> backgroundColors}, {required Color borderColor}]
For class -> _SegmentedControlContainerBoxParentData
For class -> _RenderSegmentedControl
[required int? selectedIndex, required int? pressedIndex, required TextDirection textDirection, required List<Color> backgroundColors, required Color borderColor]
[{required int? selectedIndex}, {required int? pressedIndex}, {required TextDirection textDirection}, {required List<Color> backgroundColors}, {required Color borderColor}]
For class -> CupertinoSlider
[Key? key, required this.value, required this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0.0, this.max = 1.0, this.divisions, this.activeColor, this.thumbColor = CupertinoColors.white]
[{Key? key}, {required double value}, {required void Function(double)? onChanged}, {void Function(double)? onChangeStart}, {void Function(double)? onChangeEnd}, {double min = 0.0}, {double max = 1.0}, {int? divisions}, {Color? activeColor}, {Color thumbColor = CupertinoColors.white}]
For class -> _CupertinoSliderState
For class -> _CupertinoSliderRenderObjectWidget
[Key? key, required this.value, this.divisions, required this.activeColor, required this.thumbColor, this.onChanged, this.onChangeStart, this.onChangeEnd, required this.vsync]
[{Key? key}, {required double value}, {int? divisions}, {required Color activeColor}, {required Color thumbColor}, {void Function(double)? onChanged}, {void Function(double)? onChangeStart}, {void Function(double)? onChangeEnd}, {required TickerProvider vsync}]
For class -> _RenderCupertinoSlider
[required double value, int? divisions, required Color activeColor, required Color thumbColor, required Color trackColor, ValueChanged<double>? onChanged, this.onChangeStart, this.onChangeEnd, required TickerProvider vsync, required TextDirection textDirection]
[{required double value}, {int? divisions}, {required Color activeColor}, {required Color thumbColor}, {required Color trackColor}, {void Function(double)? onChanged}, {void Function(double)? onChangeStart}, {void Function(double)? onChangeEnd}, {required TickerProvider vsync}, {required TextDirection textDirection}]
For class -> _Segment
[required ValueKey<T> key, required this.child, required this.pressed, required this.highlighted, required this.isDragging]
[{required ValueKey<T> key}, {required Widget child}, {required bool pressed}, {required bool highlighted}, {required bool isDragging}]
For class -> _SegmentState
For class -> _SegmentSeparator
[required ValueKey<int> key, required this.highlighted]
[{required ValueKey<int> key}, {required bool highlighted}]
For class -> _SegmentSeparatorState
For class -> CupertinoSlidingSegmentedControl
[Key? key, required this.children, required this.onValueChanged, this.groupValue, this.thumbColor = _kThumbColor, this.padding = _kHorizontalItemPadding, this.backgroundColor = CupertinoColors.tertiarySystemFill]
[{Key? key}, {required Map<T, Widget> children}, {required void Function(T?) onValueChanged}, {T? groupValue}, {Color thumbColor = _kThumbColor}, {EdgeInsetsGeometry padding = _kHorizontalItemPadding}, {Color backgroundColor = CupertinoColors.tertiarySystemFill}]
For class -> _SegmentedControlState
For class -> _SegmentedControlRenderWidget
[Key? key, List<Widget> children = const <Widget>[], required this.highlightedIndex, required this.thumbColor, required this.thumbScale, required this.state]
[{Key? key}, {List<Widget> children = const <Widget>[]}, {required int? highlightedIndex}, {required Color thumbColor}, {required double thumbScale}, {required _SegmentedControlState<T> state}]
For class -> _SegmentedControlContainerBoxParentData
For class -> _RenderSegmentedControl
[required int? highlightedIndex, required Color thumbColor, required double thumbScale, required this.state]
[{required int? highlightedIndex}, {required Color thumbColor}, {required double thumbScale}, {required _SegmentedControlState<T> state}]
For class -> CupertinoSwitch
[Key? key, required this.value, required this.onChanged, this.activeColor, this.trackColor, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required bool value}, {required void Function(bool)? onChanged}, {Color? activeColor}, {Color? trackColor}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _CupertinoSwitchState
For class -> _CupertinoSwitchRenderObjectWidget
[Key? key, required this.value, required this.activeColor, required this.trackColor, required this.onChanged, required this.textDirection, required this.state]
[{Key? key}, {required bool value}, {required Color activeColor}, {required Color trackColor}, {required void Function(bool)? onChanged}, {required TextDirection textDirection}, {required _CupertinoSwitchState state}]
For class -> _RenderCupertinoSwitch
[required bool value, required Color activeColor, required Color trackColor, ValueChanged<bool>? onChanged, required TextDirection textDirection, required _CupertinoSwitchState state]
[{required bool value}, {required Color activeColor}, {required Color trackColor}, {void Function(bool)? onChanged}, {required TextDirection textDirection}, {required _CupertinoSwitchState state}]
For class -> CupertinoTabController
[int initialIndex = 0]
[{int initialIndex = 0}]
For class -> CupertinoTabScaffold
[Key? key, required this.tabBar, required this.tabBuilder, this.controller, this.backgroundColor, this.resizeToAvoidBottomInset = true, this.restorationId]
[{Key? key}, {required CupertinoTabBar tabBar}, {required Widget Function(BuildContext, int) tabBuilder}, {CupertinoTabController? controller}, {Color? backgroundColor}, {bool resizeToAvoidBottomInset = true}, {String? restorationId}]
For class -> _CupertinoTabScaffoldState
For class -> _TabSwitchingView
[required this.currentTabIndex, required this.tabCount, required this.tabBuilder]
[{required int currentTabIndex}, {required int tabCount}, {required Widget Function(BuildContext, int) tabBuilder}]
For class -> _TabSwitchingViewState
For class -> RestorableCupertinoTabController
[int initialIndex = 0]
[{int initialIndex = 0}]
For class -> CupertinoTabView
[Key? key, this.builder, this.navigatorKey, this.defaultTitle, this.routes, this.onGenerateRoute, this.onUnknownRoute, this.navigatorObservers = const <NavigatorObserver>[], this.restorationScopeId]
[{Key? key}, {Widget Function(BuildContext)? builder}, {GlobalKey<NavigatorState>? navigatorKey}, {String? defaultTitle}, {Map<String, Widget Function(BuildContext)>? routes}, {Route<dynamic>? Function(RouteSettings)? onGenerateRoute}, {Route<dynamic>? Function(RouteSettings)? onUnknownRoute}, {List<NavigatorObserver> navigatorObservers = const <NavigatorObserver>[]}, {String? restorationScopeId}]
For class -> _CupertinoTabViewState
For class -> _CupertinoTextFieldSelectionGestureDetectorBuilder
[required _CupertinoTextFieldState state]
[{required _CupertinoTextFieldState state}]
For class -> CupertinoTextField
[Key? key, this.controller, this.focusNode, this.decoration = _kDefaultRoundedBorderDecoration, this.padding = const EdgeInsets.all(6.0), this.placeholder, this.placeholderStyle = const TextStyle(fontWeight: FontWeight.w400, color: CupertinoColors.placeholderText), this.prefix, this.prefixMode = OverlayVisibilityMode.always, this.suffix, this.suffixMode = OverlayVisibilityMode.always, this.clearButtonMode = OverlayVisibilityMode.never, TextInputType? keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.style, this.strutStyle, this.textAlign = TextAlign.start, this.textAlignVertical, this.readOnly = false, ToolbarOptions? toolbarOptions, this.showCursor, this.autofocus = false, this.obscuringCharacter = '•', this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, @Deprecated('Use maxLengthEnforcement parameter which provides more specific ' 'behavior related to the maxLength limit. ' 'This feature was deprecated after v1.25.0-5.0.pre.') this.maxLengthEnforced = true, this.maxLengthEnforcement, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius = const Radius.circular(2.0), this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollController, this.scrollPhysics, this.autofillHints, this.restorationId]
[{Key? key}, {TextEditingController? controller}, {FocusNode? focusNode}, {BoxDecoration? decoration = _kDefaultRoundedBorderDecoration}, {EdgeInsetsGeometry padding = const EdgeInsets.all(6.0)}, {String? placeholder}, {TextStyle? placeholderStyle = const TextStyle(fontWeight: FontWeight.w400, color: CupertinoColors.placeholderText)}, {Widget? prefix}, {OverlayVisibilityMode prefixMode = OverlayVisibilityMode.always}, {Widget? suffix}, {OverlayVisibilityMode suffixMode = OverlayVisibilityMode.always}, {OverlayVisibilityMode clearButtonMode = OverlayVisibilityMode.never}, {TextInputType? keyboardType}, {TextInputAction? textInputAction}, {TextCapitalization textCapitalization = TextCapitalization.none}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign textAlign = TextAlign.start}, {TextAlignVertical? textAlignVertical}, {bool readOnly = false}, {ToolbarOptions? toolbarOptions}, {bool? showCursor}, {bool autofocus = false}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {int? maxLength}, {bool maxLengthEnforced = true}, {MaxLengthEnforcement? maxLengthEnforcement}, {void Function(String)? onChanged}, {void Function()? onEditingComplete}, {void Function(String)? onSubmitted}, {List<TextInputFormatter>? inputFormatters}, {bool? enabled}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius cursorRadius = const Radius.circular(2.0)}, {Color? cursorColor}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {Brightness? keyboardAppearance}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {void Function()? onTap}, {ScrollController? scrollController}, {ScrollPhysics? scrollPhysics}, {Iterable<String>? autofillHints}, {String? restorationId}]
[Key? key, this.controller, this.focusNode, this.decoration, this.padding = const EdgeInsets.all(6.0), this.placeholder, this.placeholderStyle = _kDefaultPlaceholderStyle, this.prefix, this.prefixMode = OverlayVisibilityMode.always, this.suffix, this.suffixMode = OverlayVisibilityMode.always, this.clearButtonMode = OverlayVisibilityMode.never, TextInputType? keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.style, this.strutStyle, this.textAlign = TextAlign.start, this.textAlignVertical, this.readOnly = false, ToolbarOptions? toolbarOptions, this.showCursor, this.autofocus = false, this.obscuringCharacter = '•', this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, @Deprecated('Use maxLengthEnforcement parameter which provides more specific ' 'behavior related to the maxLength limit. ' 'This feature was deprecated after v1.25.0-5.0.pre.') this.maxLengthEnforced = true, this.maxLengthEnforcement, this.onChanged, this.onEditingComplete, this.onSubmitted, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius = const Radius.circular(2.0), this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollController, this.scrollPhysics, this.autofillHints, this.restorationId]
[{Key? key}, {TextEditingController? controller}, {FocusNode? focusNode}, {BoxDecoration? decoration}, {EdgeInsetsGeometry padding = const EdgeInsets.all(6.0)}, {String? placeholder}, {TextStyle? placeholderStyle = _kDefaultPlaceholderStyle}, {Widget? prefix}, {OverlayVisibilityMode prefixMode = OverlayVisibilityMode.always}, {Widget? suffix}, {OverlayVisibilityMode suffixMode = OverlayVisibilityMode.always}, {OverlayVisibilityMode clearButtonMode = OverlayVisibilityMode.never}, {TextInputType? keyboardType}, {TextInputAction? textInputAction}, {TextCapitalization textCapitalization = TextCapitalization.none}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign textAlign = TextAlign.start}, {TextAlignVertical? textAlignVertical}, {bool readOnly = false}, {ToolbarOptions? toolbarOptions}, {bool? showCursor}, {bool autofocus = false}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {int? maxLength}, {bool maxLengthEnforced = true}, {MaxLengthEnforcement? maxLengthEnforcement}, {void Function(String)? onChanged}, {void Function()? onEditingComplete}, {void Function(String)? onSubmitted}, {List<TextInputFormatter>? inputFormatters}, {bool? enabled}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius cursorRadius = const Radius.circular(2.0)}, {Color? cursorColor}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {Brightness? keyboardAppearance}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {void Function()? onTap}, {ScrollController? scrollController}, {ScrollPhysics? scrollPhysics}, {Iterable<String>? autofillHints}, {String? restorationId}]
For class -> _CupertinoTextFieldState
For class -> CupertinoTextFormFieldRow
[Key? key, this.prefix, this.padding, this.controller, String? initialValue, FocusNode? focusNode, BoxDecoration? decoration, TextInputType? keyboardType, TextCapitalization textCapitalization = TextCapitalization.none, TextInputAction? textInputAction, TextStyle? style, StrutStyle? strutStyle, TextAlign textAlign = TextAlign.start, TextAlignVertical? textAlignVertical, bool autofocus = false, bool readOnly = false, ToolbarOptions? toolbarOptions, bool? showCursor, String obscuringCharacter = '•', bool obscureText = false, bool autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, bool enableSuggestions = true, int? maxLines = 1, int? minLines, bool expands = false, int? maxLength, ValueChanged<String>? onChanged, GestureTapCallback? onTap, VoidCallback? onEditingComplete, ValueChanged<String>? onFieldSubmitted, FormFieldSetter<String>? onSaved, FormFieldValidator<String>? validator, List<TextInputFormatter>? inputFormatters, bool? enabled, double cursorWidth = 2.0, double? cursorHeight, Color? cursorColor, Brightness? keyboardAppearance, EdgeInsets scrollPadding = const EdgeInsets.all(20.0), bool enableInteractiveSelection = true, TextSelectionControls? selectionControls, ScrollPhysics? scrollPhysics, Iterable<String>? autofillHints, AutovalidateMode autovalidateMode = AutovalidateMode.disabled, String? placeholder, TextStyle? placeholderStyle = const TextStyle(fontWeight: FontWeight.w400, color: CupertinoColors.placeholderText)]
[{Key? key}, {Widget? prefix}, {EdgeInsetsGeometry? padding}, {TextEditingController? controller}, {String? initialValue}, {FocusNode? focusNode}, {BoxDecoration? decoration}, {TextInputType? keyboardType}, {TextCapitalization textCapitalization = TextCapitalization.none}, {TextInputAction? textInputAction}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign textAlign = TextAlign.start}, {TextAlignVertical? textAlignVertical}, {bool autofocus = false}, {bool readOnly = false}, {ToolbarOptions? toolbarOptions}, {bool? showCursor}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {int? maxLength}, {void Function(String)? onChanged}, {void Function()? onTap}, {void Function()? onEditingComplete}, {void Function(String)? onFieldSubmitted}, {void Function(String?)? onSaved}, {String? Function(String?)? validator}, {List<TextInputFormatter>? inputFormatters}, {bool? enabled}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Color? cursorColor}, {Brightness? keyboardAppearance}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {ScrollPhysics? scrollPhysics}, {Iterable<String>? autofillHints}, {AutovalidateMode autovalidateMode = AutovalidateMode.disabled}, {String? placeholder}, {TextStyle? placeholderStyle = const TextStyle(fontWeight: FontWeight.w400, color: CupertinoColors.placeholderText)}]
For class -> _CupertinoTextFormFieldRowState
For class -> _CupertinoTextSelectionControlsToolbar
[Key? key, required this.clipboardStatus, required this.endpoints, required this.globalEditableRegion, required this.handleCopy, required this.handleCut, required this.handlePaste, required this.handleSelectAll, required this.selectionMidpoint, required this.textLineHeight]
[{Key? key}, {required ClipboardStatusNotifier? clipboardStatus}, {required List<TextSelectionPoint> endpoints}, {required Rect globalEditableRegion}, {required void Function()? handleCopy}, {required void Function()? handleCut}, {required void Function()? handlePaste}, {required void Function()? handleSelectAll}, {required Offset selectionMidpoint}, {required double textLineHeight}]
For class -> _CupertinoTextSelectionControlsToolbarState
For class -> _TextSelectionHandlePainter
[this.color]
[Color color]
For class -> CupertinoTextSelectionControls
For class -> CupertinoTextSelectionToolbar
[Key? key, required this.anchorAbove, required this.anchorBelow, required this.children, this.toolbarBuilder = _defaultToolbarBuilder]
[{Key? key}, {required Offset anchorAbove}, {required Offset anchorBelow}, {required List<Widget> children}, {Widget Function(BuildContext, Offset, bool, Widget) toolbarBuilder = _defaultToolbarBuilder}]
For class -> _CupertinoTextSelectionToolbarShape
[Key? key, required Offset anchor, required bool isAbove, Widget? child]
[{Key? key}, {required Offset anchor}, {required bool isAbove}, {Widget? child}]
For class -> _RenderCupertinoTextSelectionToolbarShape
[this._anchor, this._isAbove, RenderBox? child]
[Offset _anchor, bool _isAbove, RenderBox? child]
For class -> _CupertinoTextSelectionToolbarContent
[Key? key, required this.anchor, required this.isAbove, required this.toolbarBuilder, required this.children]
[{Key? key}, {required Offset anchor}, {required bool isAbove}, {required Widget Function(BuildContext, Offset, bool, Widget) toolbarBuilder}, {required List<Widget> children}]
For class -> _CupertinoTextSelectionToolbarContentState
For class -> _CupertinoTextSelectionToolbarItems
[Key? key, required this.page, required this.children, required this.backButton, required this.dividerWidth, required this.nextButton, required this.nextButtonDisabled]
[{Key? key}, {required int page}, {required List<Widget> children}, {required Widget backButton}, {required double dividerWidth}, {required Widget nextButton}, {required Widget nextButtonDisabled}]
For class -> _CupertinoTextSelectionToolbarItemsElement
[_CupertinoTextSelectionToolbarItems widget]
[_CupertinoTextSelectionToolbarItems widget]
For class -> _RenderCupertinoTextSelectionToolbarItems
[required double dividerWidth, required int page]
[{required double dividerWidth}, {required int page}]
For class -> _NullElement
[]
[]
For class -> _NullWidget
For class -> CupertinoTextSelectionToolbarButton
[Key? key, this.onPressed, required this.child]
[{Key? key}, {void Function()? onPressed}, {required Widget child}]
[Key? key, this.onPressed, required String text]
[{Key? key}, {void Function()? onPressed}, {required String text}]
For class -> CupertinoTextThemeData
[Color primaryColor = CupertinoColors.systemBlue, TextStyle? textStyle, TextStyle? actionTextStyle, TextStyle? tabLabelTextStyle, TextStyle? navTitleTextStyle, TextStyle? navLargeTitleTextStyle, TextStyle? navActionTextStyle, TextStyle? pickerTextStyle, TextStyle? dateTimePickerTextStyle]
[{Color primaryColor = CupertinoColors.systemBlue}, {TextStyle? textStyle}, {TextStyle? actionTextStyle}, {TextStyle? tabLabelTextStyle}, {TextStyle? navTitleTextStyle}, {TextStyle? navLargeTitleTextStyle}, {TextStyle? navActionTextStyle}, {TextStyle? pickerTextStyle}, {TextStyle? dateTimePickerTextStyle}]
[this._defaults, this._primaryColor, this._textStyle, this._actionTextStyle, this._tabLabelTextStyle, this._navTitleTextStyle, this._navLargeTitleTextStyle, this._navActionTextStyle, this._pickerTextStyle, this._dateTimePickerTextStyle]
[_TextThemeDefaultsBuilder _defaults, Color? _primaryColor, TextStyle? _textStyle, TextStyle? _actionTextStyle, TextStyle? _tabLabelTextStyle, TextStyle? _navTitleTextStyle, TextStyle? _navLargeTitleTextStyle, TextStyle? _navActionTextStyle, TextStyle? _pickerTextStyle, TextStyle? _dateTimePickerTextStyle]
For class -> _TextThemeDefaultsBuilder
[this.labelColor, this.inactiveGrayColor]
[Color labelColor, Color inactiveGrayColor]
For class -> CupertinoTheme
[Key? key, required this.data, required this.child]
[{Key? key}, {required CupertinoThemeData data}, {required Widget child}]
For class -> _InheritedCupertinoTheme
[Key? key, required this.theme, required Widget child]
[{Key? key}, {required CupertinoTheme theme}, {required Widget child}]
For class -> CupertinoThemeData
[Brightness? brightness, Color? primaryColor, Color? primaryContrastingColor, CupertinoTextThemeData? textTheme, Color? barBackgroundColor, Color? scaffoldBackgroundColor]
[{Brightness? brightness}, {Color? primaryColor}, {Color? primaryContrastingColor}, {CupertinoTextThemeData? textTheme}, {Color? barBackgroundColor}, {Color? scaffoldBackgroundColor}]
[Brightness? brightness, Color? primaryColor, Color? primaryContrastingColor, CupertinoTextThemeData? textTheme, Color? barBackgroundColor, Color? scaffoldBackgroundColor]
[Brightness? brightness, Color? primaryColor, Color? primaryContrastingColor, CupertinoTextThemeData? textTheme, Color? barBackgroundColor, Color? scaffoldBackgroundColor]
[Brightness? brightness, Color? primaryColor, Color? primaryContrastingColor, CupertinoTextThemeData? textTheme, Color? barBackgroundColor, Color? scaffoldBackgroundColor, this._defaults]
[Brightness? brightness, Color? primaryColor, Color? primaryContrastingColor, CupertinoTextThemeData? textTheme, Color? barBackgroundColor, Color? scaffoldBackgroundColor, _CupertinoThemeDefaults _defaults]
For class -> NoDefaultCupertinoThemeData
[this.brightness, this.primaryColor, this.primaryContrastingColor, this.textTheme, this.barBackgroundColor, this.scaffoldBackgroundColor]
[{Brightness? brightness}, {Color? primaryColor}, {Color? primaryContrastingColor}, {CupertinoTextThemeData? textTheme}, {Color? barBackgroundColor}, {Color? scaffoldBackgroundColor}]
For class -> _CupertinoThemeDefaults
[this.brightness, this.primaryColor, this.primaryContrastingColor, this.barBackgroundColor, this.scaffoldBackgroundColor, this.textThemeDefaults]
[Brightness? brightness, Color primaryColor, Color primaryContrastingColor, Color barBackgroundColor, Color scaffoldBackgroundColor, _CupertinoTextThemeDefaults textThemeDefaults]
For class -> _CupertinoTextThemeDefaults
[this.labelColor, this.inactiveGray]
[Color labelColor, Color inactiveGray]
For class -> _DefaultCupertinoTextThemeData
[required this.labelColor, required this.inactiveGray, required Color primaryColor]
[{required Color labelColor}, {required Color inactiveGray}, {required Color primaryColor}]
For class -> CupertinoThumbPainter
[this.color = CupertinoColors.white, this.shadows = _kSliderBoxShadows]
[{Color color = CupertinoColors.white}, {List<BoxShadow> shadows = _kSliderBoxShadows}]
[Color color = CupertinoColors.white, List<BoxShadow> shadows = _kSwitchBoxShadows]
[{Color color = CupertinoColors.white}, {List<BoxShadow> shadows = _kSwitchBoxShadows}]
For class -> Category
[this.sections]
[List<String> sections]
For class -> DocumentationIcon
[this.url]
[String url]
For class -> Summary
[this.text]
[String text]
For class -> PartialStackFrame
[required this.package, required this.className, required this.method]
[{required Pattern package}, {required String className}, {required String method}]
For class -> StackFilter
[]
[]
For class -> RepetitiveStackFrameFilter
[required this.frames, required this.replacement]
[{required List<PartialStackFrame> frames}, {required String replacement}]
For class -> _ErrorDiagnostic
[String message, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.flat, DiagnosticLevel level = DiagnosticLevel.info]
[String message, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.flat}, {DiagnosticLevel level = DiagnosticLevel.info}]
[List<Object> messageParts, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.flat, DiagnosticLevel level = DiagnosticLevel.info]
[List<Object> messageParts, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.flat}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> ErrorDescription
[String message]
[String message]
[List<Object> messageParts]
[List<Object> messageParts]
For class -> ErrorSummary
[String message]
[String message]
[List<Object> messageParts]
[List<Object> messageParts]
For class -> ErrorHint
[String message]
[String message]
[List<Object> messageParts]
[List<Object> messageParts]
For class -> ErrorSpacer
[]
[]
For class -> FlutterErrorDetails
[required this.exception, this.stack, this.library = 'Flutter framework', this.context, this.stackFilter, this.informationCollector, this.silent = false]
[{required Object exception}, {StackTrace? stack}, {String? library = 'Flutter framework'}, {DiagnosticsNode? context}, {Iterable<String> Function(Iterable<String>)? stackFilter}, {Iterable<DiagnosticsNode> Function()? informationCollector}, {bool silent = false}]
For class -> FlutterError
[String message]
[String message]
[this.diagnostics]
[List<DiagnosticsNode> diagnostics]
For class -> DiagnosticsStackTrace
[String name, StackTrace? stack, IterableFilter<String>? stackFilter, bool showSeparator = true]
[String name, StackTrace? stack, {Iterable<String> Function(Iterable<String>)? stackFilter}, {bool showSeparator = true}]
[String name, required String frame, bool showSeparator = true]
[String name, {required String frame}, {bool showSeparator = true}]
For class -> _FlutterErrorDetailsNode
[String? name, required FlutterErrorDetails value, required DiagnosticsTreeStyle? style]
[{String? name}, {required FlutterErrorDetails value}, {required DiagnosticsTreeStyle? style}]
For class -> CachingIterable
[this._prefillIterator]
[Iterator<E> _prefillIterator]
For class -> _LazyListIterator
[this._owner]
[CachingIterable<E> _owner]
For class -> Factory
[this.constructor]
[T Function() constructor]
For class -> BindingBase
[]
[]
For class -> BitField
[int length]
[int length]
[int length, bool value]
[int length, bool value]
For class -> Listenable
[]
[]
[List<Listenable?> listenables]
[List<Listenable?> listenables]
For class -> ValueListenable
[]
[]
For class -> _ListenerEntry
[this.listener]
[void Function() listener]
For class -> ChangeNotifier
For class -> _MergingListenable
[this._children]
[List<Listenable?> _children]
For class -> ValueNotifier
[this._value]
[T _value]
For class -> _OutputBuffer
For class -> TextTreeConfiguration
[required this.prefixLineOne, required this.prefixOtherLines, required this.prefixLastChildLineOne, required this.prefixOtherLinesRootNode, required this.linkCharacter, required this.propertyPrefixIfChildren, required this.propertyPrefixNoChildren, this.lineBreak = '\n', this.lineBreakProperties = true, this.afterName = ':', this.afterDescriptionIfBody = '', this.afterDescription = '', this.beforeProperties = '', this.afterProperties = '', this.mandatoryAfterProperties = '', this.propertySeparator = '', this.bodyIndent = '', this.footer = '', this.showChildren = true, this.addBlankLineIfNoChildren = true, this.isNameOnOwnLine = false, this.isBlankLineBetweenPropertiesAndChildren = true, this.beforeName = '', this.suffixLineOne = '', this.mandatoryFooter = '']
[{required String prefixLineOne}, {required String prefixOtherLines}, {required String prefixLastChildLineOne}, {required String prefixOtherLinesRootNode}, {required String linkCharacter}, {required String propertyPrefixIfChildren}, {required String propertyPrefixNoChildren}, {String lineBreak = '\n'}, {bool lineBreakProperties = true}, {String afterName = ':'}, {String afterDescriptionIfBody = ''}, {String afterDescription = ''}, {String beforeProperties = ''}, {String afterProperties = ''}, {String mandatoryAfterProperties = ''}, {String propertySeparator = ''}, {String bodyIndent = ''}, {String footer = ''}, {bool showChildren = true}, {bool addBlankLineIfNoChildren = true}, {bool isNameOnOwnLine = false}, {bool isBlankLineBetweenPropertiesAndChildren = true}, {String beforeName = ''}, {String suffixLineOne = ''}, {String mandatoryFooter = ''}]
For class -> _PrefixedStringBuilder
[required this.prefixLineOne, required String? prefixOtherLines, this.wrapWidth]
[{required String prefixLineOne}, {required String? prefixOtherLines}, {int? wrapWidth}]
For class -> _NoDefaultValue
[]
[]
For class -> TextTreeRenderer
[DiagnosticLevel minLevel = DiagnosticLevel.debug, int wrapWidth = 100, int wrapWidthProperties = 65, int maxDescendentsTruncatableNode = -1]
[{DiagnosticLevel minLevel = DiagnosticLevel.debug}, {int wrapWidth = 100}, {int wrapWidthProperties = 65}, {int maxDescendentsTruncatableNode = -1}]
For class -> DiagnosticsNode
[required this.name, this.style, this.showName = true, this.showSeparator = true, this.linePrefix]
[{required String? name}, {DiagnosticsTreeStyle? style}, {bool showName = true}, {bool showSeparator = true}, {String? linePrefix}]
[String message, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info, bool allowWrap = true]
[String message, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}, {bool allowWrap = true}]
For class -> MessageProperty
[String name, String message, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, String message, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> StringProperty
[String name, String? value, String? description, String? tooltip, bool showName = true, Object? defaultValue = kNoDefaultValue, this.quoted = true, String? ifEmpty, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, String? value, {String? description}, {String? tooltip}, {bool showName = true}, {Object? defaultValue = kNoDefaultValue}, {bool quoted = true}, {String? ifEmpty}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> _NumProperty
[String name, T? value, String? ifNull, this.unit, bool showName = true, Object? defaultValue = kNoDefaultValue, String? tooltip, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, T? value, {String? ifNull}, {String? unit}, {bool showName = true}, {Object? defaultValue = kNoDefaultValue}, {String? tooltip}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
[String name, ComputePropertyValueCallback<T?> computeValue, String? ifNull, this.unit, bool showName = true, Object? defaultValue = kNoDefaultValue, String? tooltip, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, T? Function() computeValue, {String? ifNull}, {String? unit}, {bool showName = true}, {Object? defaultValue = kNoDefaultValue}, {String? tooltip}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> DoubleProperty
[String name, double? value, String? ifNull, String? unit, String? tooltip, Object? defaultValue = kNoDefaultValue, bool showName = true, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, double? value, {String? ifNull}, {String? unit}, {String? tooltip}, {Object? defaultValue = kNoDefaultValue}, {bool showName = true}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
[String name, ComputePropertyValueCallback<double?> computeValue, String? ifNull, bool showName = true, String? unit, String? tooltip, Object? defaultValue = kNoDefaultValue, DiagnosticLevel level = DiagnosticLevel.info]
[String name, double? Function() computeValue, {String? ifNull}, {bool showName = true}, {String? unit}, {String? tooltip}, {Object? defaultValue = kNoDefaultValue}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> IntProperty
[String name, int? value, String? ifNull, bool showName = true, String? unit, Object? defaultValue = kNoDefaultValue, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, int? value, {String? ifNull}, {bool showName = true}, {String? unit}, {Object? defaultValue = kNoDefaultValue}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> PercentProperty
[String name, double? fraction, String? ifNull, bool showName = true, String? tooltip, String? unit, DiagnosticLevel level = DiagnosticLevel.info]
[String name, double? fraction, {String? ifNull}, {bool showName = true}, {String? tooltip}, {String? unit}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> FlagProperty
[String name, required bool? value, this.ifTrue, this.ifFalse, bool showName = false, Object? defaultValue, DiagnosticLevel level = DiagnosticLevel.info]
[String name, {required bool? value}, {String? ifTrue}, {String? ifFalse}, {bool showName = false}, {Object? defaultValue}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> IterableProperty
[String name, Iterable<T>? value, Object? defaultValue = kNoDefaultValue, String? ifNull, String? ifEmpty = '[]', DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, bool showName = true, bool showSeparator = true, DiagnosticLevel level = DiagnosticLevel.info]
[String name, Iterable<T>? value, {Object? defaultValue = kNoDefaultValue}, {String? ifNull}, {String? ifEmpty = '[]'}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {bool showName = true}, {bool showSeparator = true}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> EnumProperty
[String name, T? value, Object? defaultValue = kNoDefaultValue, DiagnosticLevel level = DiagnosticLevel.info]
[String name, T? value, {Object? defaultValue = kNoDefaultValue}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> ObjectFlagProperty
[String name, T? value, this.ifPresent, String? ifNull, bool showName = false, DiagnosticLevel level = DiagnosticLevel.info]
[String name, T? value, {String? ifPresent}, {String? ifNull}, {bool showName = false}, {DiagnosticLevel level = DiagnosticLevel.info}]
[String name, T? value, DiagnosticLevel level = DiagnosticLevel.info]
[String name, T? value, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> FlagsSummary
[String name, Map<String, T?> value, String? ifEmpty, bool showName = true, bool showSeparator = true, DiagnosticLevel level = DiagnosticLevel.info]
[String name, Map<String, T?> value, {String? ifEmpty}, {bool showName = true}, {bool showSeparator = true}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> DiagnosticsProperty
[String? name, T? value, String? description, String? ifNull, this.ifEmpty, bool showName = true, bool showSeparator = true, this.defaultValue = kNoDefaultValue, this.tooltip, this.missingIfNull = false, String? linePrefix, this.expandableValue = false, this.allowWrap = true, this.allowNameWrap = true, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String? name, T? value, {String? description}, {String? ifNull}, {String? ifEmpty}, {bool showName = true}, {bool showSeparator = true}, {Object? defaultValue = kNoDefaultValue}, {String? tooltip}, {bool missingIfNull = false}, {String? linePrefix}, {bool expandableValue = false}, {bool allowWrap = true}, {bool allowNameWrap = true}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
[String? name, ComputePropertyValueCallback<T> computeValue, String? description, String? ifNull, this.ifEmpty, bool showName = true, bool showSeparator = true, this.defaultValue = kNoDefaultValue, this.tooltip, this.missingIfNull = false, this.expandableValue = false, this.allowWrap = true, this.allowNameWrap = true, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String? name, T? Function() computeValue, {String? description}, {String? ifNull}, {String? ifEmpty}, {bool showName = true}, {bool showSeparator = true}, {Object? defaultValue = kNoDefaultValue}, {String? tooltip}, {bool missingIfNull = false}, {bool expandableValue = false}, {bool allowWrap = true}, {bool allowNameWrap = true}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> DiagnosticableNode
[String? name, required this.value, required DiagnosticsTreeStyle? style]
[{String? name}, {required T value}, {required DiagnosticsTreeStyle? style}]
For class -> DiagnosticableTreeNode
[String? name, required DiagnosticableTree value, required DiagnosticsTreeStyle? style]
[{String? name}, {required DiagnosticableTree value}, {required DiagnosticsTreeStyle? style}]
For class -> DiagnosticPropertiesBuilder
[]
[]
[this.properties]
[List<DiagnosticsNode> properties]
For class -> DiagnosticableTree
[]
[]
For class -> DiagnosticsBlock
[String? name, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.whitespace, bool showName = true, bool showSeparator = true, String? linePrefix, this.value, String? description, this.level = DiagnosticLevel.info, this.allowTruncate = false, List<DiagnosticsNode> children = const <DiagnosticsNode>[], List<DiagnosticsNode> properties = const <DiagnosticsNode>[]]
[{String? name}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.whitespace}, {bool showName = true}, {bool showSeparator = true}, {String? linePrefix}, {Object? value}, {String? description}, {DiagnosticLevel level = DiagnosticLevel.info}, {bool allowTruncate = false}, {List<DiagnosticsNode> children = const <DiagnosticsNode>[]}, {List<DiagnosticsNode> properties = const <DiagnosticsNode>[]}]
For class -> DiagnosticsSerializationDelegate
[int subtreeDepth, bool includeProperties]
[{int subtreeDepth}, {bool includeProperties}]
For class -> _DefaultDiagnosticsSerializationDelegate
[this.includeProperties = false, this.subtreeDepth = 0]
[{bool includeProperties = false}, {int subtreeDepth = 0}]
For class -> Key
[String value]
[String value]
[]
[]
For class -> LocalKey
[]
[]
For class -> ValueKey
[this.value]
[T value]
For class -> _TypeLiteral
For class -> LicenseParagraph
[this.text, this.indent]
[String text, int indent]
For class -> LicenseEntry
[]
[]
For class -> LicenseEntryWithLineBreaks
[this.packages, this.text]
[List<String> packages, String text]
For class -> LicenseRegistry
[]
[]
For class -> AbstractNode
For class -> ObserverList
For class -> HashedObserverList
For class -> WriteBuffer
[]
[]
For class -> ReadBuffer
[this.data]
[ByteData data]
For class -> StackFrame
[required this.number, required this.column, required this.line, required this.packageScheme, required this.package, required this.packagePath, this.className = '', required this.method, this.isConstructor = false, required this.source]
[{required int number}, {required int column}, {required int line}, {required String packageScheme}, {required String package}, {required String packagePath}, {String className = ''}, {required String method}, {bool isConstructor = false}, {required String source}]
For class -> SynchronousFuture
[this._value]
[T _value]
For class -> Unicode
[]
[]
For class -> BitField
[this._length]
[int _length]
[this._length, bool value]
[int _length, bool value]
For class -> BitField
[int length]
[int length]
[int length, bool value]
[int length, bool value]
For class -> _IsolateConfiguration
[this.callback, this.message, this.resultPort, this.debugLabel, this.flowId]
[FutureOr<R> Function(Q) callback, Q message, SendPort resultPort, String debugLabel, int flowId]
For class -> GestureArenaMember
For class -> GestureArenaEntry
[this._arena, this._pointer, this._member]
[GestureArenaManager _arena, int _pointer, GestureArenaMember _member]
For class -> _GestureArena
For class -> GestureArenaManager
For class -> _Resampler
[this._handlePointerEvent, this._handleSampleTimeChanged]
[void Function(PointerEvent) _handlePointerEvent, void Function() _handleSampleTimeChanged]
For class -> FlutterErrorDetailsForPointerEventDispatcher
[required Object exception, StackTrace? stack, String? library, DiagnosticsNode? context, this.event, this.hitTestEntry, InformationCollector? informationCollector, bool silent = false]
[{required Object exception}, {StackTrace? stack}, {String? library}, {DiagnosticsNode? context}, {PointerEvent? event}, {HitTestEntry? hitTestEntry}, {Iterable<DiagnosticsNode> Function()? informationCollector}, {bool silent = false}]
For class -> PointerEventConverter
[]
[]
For class -> Drag
For class -> DragDownDetails
[this.globalPosition = Offset.zero, Offset? localPosition]
[{Offset globalPosition = Offset.zero}, {Offset? localPosition}]
For class -> DragStartDetails
[this.sourceTimeStamp, this.globalPosition = Offset.zero, Offset? localPosition, this.kind]
[{Duration? sourceTimeStamp}, {Offset globalPosition = Offset.zero}, {Offset? localPosition}, {PointerDeviceKind? kind}]
For class -> DragUpdateDetails
[this.sourceTimeStamp, this.delta = Offset.zero, this.primaryDelta, required this.globalPosition, Offset? localPosition]
[{Duration? sourceTimeStamp}, {Offset delta = Offset.zero}, {double? primaryDelta}, {required Offset globalPosition}, {Offset? localPosition}]
For class -> DragEndDetails
[this.velocity = Velocity.zero, this.primaryVelocity]
[{Velocity velocity = Velocity.zero}, {double? primaryVelocity}]
For class -> EagerGestureRecognizer
[PointerDeviceKind? kind]
[{PointerDeviceKind? kind}]
For class -> PointerEvent
[this.embedderId = 0, this.timeStamp = Duration.zero, this.pointer = 0, this.kind = PointerDeviceKind.touch, this.device = 0, this.position = Offset.zero, this.delta = Offset.zero, this.buttons = 0, this.down = false, this.obscured = false, this.pressure = 1.0, this.pressureMin = 1.0, this.pressureMax = 1.0, this.distance = 0.0, this.distanceMax = 0.0, this.size = 0.0, this.radiusMajor = 0.0, this.radiusMinor = 0.0, this.radiusMin = 0.0, this.radiusMax = 0.0, this.orientation = 0.0, this.tilt = 0.0, this.platformData = 0, this.synthesized = false, this.transform, this.original]
[{int embedderId = 0}, {Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {Offset delta = Offset.zero}, {int buttons = 0}, {bool down = false}, {bool obscured = false}, {double pressure = 1.0}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int platformData = 0}, {bool synthesized = false}, {Matrix4? transform}, {PointerEvent? original}]
For class -> _AbstractPointerEvent
For class -> _TransformedPointerEvent
For class -> PointerAddedEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int embedderId = 0}]
For class -> _TransformedPointerAddedEvent
[this.original, this.transform]
[PointerAddedEvent original, Matrix4 transform]
For class -> PointerRemovedEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distanceMax = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, PointerRemovedEvent? original, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distanceMax = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {PointerRemovedEvent? original}, {int embedderId = 0}]
For class -> _TransformedPointerRemovedEvent
[this.original, this.transform]
[PointerRemovedEvent original, Matrix4 transform]
For class -> PointerHoverEvent
[Duration timeStamp = Duration.zero, PointerDeviceKind kind = PointerDeviceKind.touch, int pointer = 0, int device = 0, Offset position = Offset.zero, Offset delta = Offset.zero, int buttons = 0, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, bool synthesized = false, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int pointer = 0}, {int device = 0}, {Offset position = Offset.zero}, {Offset delta = Offset.zero}, {int buttons = 0}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {bool synthesized = false}, {int embedderId = 0}]
For class -> _TransformedPointerHoverEvent
[this.original, this.transform]
[PointerHoverEvent original, Matrix4 transform]
For class -> PointerEnterEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, Offset delta = Offset.zero, int buttons = 0, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, bool down = false, bool synthesized = false, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {Offset delta = Offset.zero}, {int buttons = 0}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {bool down = false}, {bool synthesized = false}, {int embedderId = 0}]
[PointerEvent event]
[PointerEvent event]
For class -> _TransformedPointerEnterEvent
[this.original, this.transform]
[PointerEnterEvent original, Matrix4 transform]
For class -> PointerExitEvent
[Duration timeStamp = Duration.zero, PointerDeviceKind kind = PointerDeviceKind.touch, int pointer = 0, int device = 0, Offset position = Offset.zero, Offset delta = Offset.zero, int buttons = 0, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, bool down = false, bool synthesized = false, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int pointer = 0}, {int device = 0}, {Offset position = Offset.zero}, {Offset delta = Offset.zero}, {int buttons = 0}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {bool down = false}, {bool synthesized = false}, {int embedderId = 0}]
[PointerEvent event]
[PointerEvent event]
For class -> _TransformedPointerExitEvent
[this.original, this.transform]
[PointerExitEvent original, Matrix4 transform]
For class -> PointerDownEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, int buttons = kPrimaryButton, bool obscured = false, double pressure = 1.0, double pressureMin = 1.0, double pressureMax = 1.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {int buttons = kPrimaryButton}, {bool obscured = false}, {double pressure = 1.0}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int embedderId = 0}]
For class -> _TransformedPointerDownEvent
[this.original, this.transform]
[PointerDownEvent original, Matrix4 transform]
For class -> PointerMoveEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, Offset delta = Offset.zero, int buttons = kPrimaryButton, bool obscured = false, double pressure = 1.0, double pressureMin = 1.0, double pressureMax = 1.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, int platformData = 0, bool synthesized = false, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {Offset delta = Offset.zero}, {int buttons = kPrimaryButton}, {bool obscured = false}, {double pressure = 1.0}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int platformData = 0}, {bool synthesized = false}, {int embedderId = 0}]
For class -> _TransformedPointerMoveEvent
[this.original, this.transform]
[PointerMoveEvent original, Matrix4 transform]
For class -> PointerUpEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, int buttons = 0, bool obscured = false, double pressure = 0.0, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {int buttons = 0}, {bool obscured = false}, {double pressure = 0.0}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int embedderId = 0}]
For class -> _TransformedPointerUpEvent
[this.original, this.transform]
[PointerUpEvent original, Matrix4 transform]
For class -> PointerSignalEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.mouse, int device = 0, Offset position = Offset.zero, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.mouse}, {int device = 0}, {Offset position = Offset.zero}, {int embedderId = 0}]
For class -> PointerScrollEvent
[Duration timeStamp = Duration.zero, PointerDeviceKind kind = PointerDeviceKind.mouse, int device = 0, Offset position = Offset.zero, this.scrollDelta = Offset.zero, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {PointerDeviceKind kind = PointerDeviceKind.mouse}, {int device = 0}, {Offset position = Offset.zero}, {Offset scrollDelta = Offset.zero}, {int embedderId = 0}]
For class -> _TransformedPointerScrollEvent
[this.original, this.transform]
[PointerScrollEvent original, Matrix4 transform]
For class -> PointerCancelEvent
[Duration timeStamp = Duration.zero, int pointer = 0, PointerDeviceKind kind = PointerDeviceKind.touch, int device = 0, Offset position = Offset.zero, int buttons = 0, bool obscured = false, double pressureMin = 1.0, double pressureMax = 1.0, double distance = 0.0, double distanceMax = 0.0, double size = 0.0, double radiusMajor = 0.0, double radiusMinor = 0.0, double radiusMin = 0.0, double radiusMax = 0.0, double orientation = 0.0, double tilt = 0.0, int embedderId = 0]
[{Duration timeStamp = Duration.zero}, {int pointer = 0}, {PointerDeviceKind kind = PointerDeviceKind.touch}, {int device = 0}, {Offset position = Offset.zero}, {int buttons = 0}, {bool obscured = false}, {double pressureMin = 1.0}, {double pressureMax = 1.0}, {double distance = 0.0}, {double distanceMax = 0.0}, {double size = 0.0}, {double radiusMajor = 0.0}, {double radiusMinor = 0.0}, {double radiusMin = 0.0}, {double radiusMax = 0.0}, {double orientation = 0.0}, {double tilt = 0.0}, {int embedderId = 0}]
For class -> _TransformedPointerCancelEvent
[this.original, this.transform]
[PointerCancelEvent original, Matrix4 transform]
For class -> ForcePressDetails
[required this.globalPosition, Offset? localPosition, required this.pressure]
[{required Offset globalPosition}, {Offset? localPosition}, {required double pressure}]
For class -> ForcePressGestureRecognizer
[this.startPressure = 0.4, this.peakPressure = 0.85, this.interpolation = _inverseLerp, Object? debugOwner, PointerDeviceKind? kind]
[{double startPressure = 0.4}, {double peakPressure = 0.85}, {double Function(double, double, double) interpolation = _inverseLerp}, {Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> HitTestable
[]
[]
For class -> HitTestDispatcher
[]
[]
For class -> HitTestTarget
[]
[]
For class -> HitTestEntry
[this.target]
[HitTestTarget target]
For class -> _TransformPart
[]
[]
For class -> _MatrixTransformPart
[this.matrix]
[Matrix4 matrix]
For class -> _OffsetTransformPart
[this.offset]
[Offset offset]
For class -> HitTestResult
[]
[]
[HitTestResult result]
[HitTestResult result]
For class -> LongPressStartDetails
[this.globalPosition = Offset.zero, Offset? localPosition]
[{Offset globalPosition = Offset.zero}, {Offset? localPosition}]
For class -> LongPressMoveUpdateDetails
[this.globalPosition = Offset.zero, Offset? localPosition, this.offsetFromOrigin = Offset.zero, Offset? localOffsetFromOrigin]
[{Offset globalPosition = Offset.zero}, {Offset? localPosition}, {Offset offsetFromOrigin = Offset.zero}, {Offset? localOffsetFromOrigin}]
For class -> LongPressEndDetails
[this.globalPosition = Offset.zero, Offset? localPosition, this.velocity = Velocity.zero]
[{Offset globalPosition = Offset.zero}, {Offset? localPosition}, {Velocity velocity = Velocity.zero}]
For class -> LongPressGestureRecognizer
[Duration? duration, double? postAcceptSlopTolerance, PointerDeviceKind? kind, Object? debugOwner]
[{Duration? duration}, {double? postAcceptSlopTolerance}, {PointerDeviceKind? kind}, {Object? debugOwner}]
For class -> _Vector
[int size]
[int size]
[List<double> values, int offset, int length]
[List<double> values, int offset, int length]
For class -> _Matrix
[int rows, int cols]
[int rows, int cols]
For class -> PolynomialFit
[int degree]
[int degree]
For class -> LeastSquaresSolver
[this.x, this.y, this.w]
[List<double> x, List<double> y, List<double> w]
For class -> DragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind, this.dragStartBehavior = DragStartBehavior.start, this.velocityTrackerBuilder = _defaultBuilder]
[{Object? debugOwner}, {PointerDeviceKind? kind}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {VelocityTracker Function(PointerEvent) velocityTrackerBuilder = _defaultBuilder}]
For class -> VerticalDragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> HorizontalDragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> PanGestureRecognizer
[Object? debugOwner]
[{Object? debugOwner}]
For class -> MultiDragPointerState
[this.initialPosition, this.kind]
[Offset initialPosition, PointerDeviceKind kind]
For class -> MultiDragGestureRecognizer
[required Object? debugOwner, PointerDeviceKind? kind]
[{required Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _ImmediatePointerState
[Offset initialPosition, PointerDeviceKind kind]
[Offset initialPosition, PointerDeviceKind kind]
For class -> ImmediateMultiDragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _HorizontalPointerState
[Offset initialPosition, PointerDeviceKind kind]
[Offset initialPosition, PointerDeviceKind kind]
For class -> HorizontalMultiDragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _VerticalPointerState
[Offset initialPosition, PointerDeviceKind kind]
[Offset initialPosition, PointerDeviceKind kind]
For class -> VerticalMultiDragGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _DelayedPointerState
[Offset initialPosition, Duration delay, PointerDeviceKind kind]
[Offset initialPosition, Duration delay, PointerDeviceKind kind]
For class -> DelayedMultiDragGestureRecognizer
[this.delay = kLongPressTimeout, Object? debugOwner, PointerDeviceKind? kind]
[{Duration delay = kLongPressTimeout}, {Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _CountdownZoned
[required Duration duration]
[{required Duration duration}]
For class -> _TapTracker
[required PointerDownEvent event, required this.entry, required Duration doubleTapMinTime]
[{required PointerDownEvent event}, {required GestureArenaEntry entry}, {required Duration doubleTapMinTime}]
For class -> DoubleTapGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> _TapGesture
[required this.gestureRecognizer, required PointerEvent event, required Duration longTapDelay]
[{required MultiTapGestureRecognizer gestureRecognizer}, {required PointerEvent event}, {required Duration longTapDelay}]
For class -> MultiTapGestureRecognizer
[this.longTapDelay = Duration.zero, Object? debugOwner, PointerDeviceKind? kind]
[{Duration longTapDelay = Duration.zero}, {Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> PointerRouter
For class -> PointerSignalResolver
For class -> GestureRecognizer
[this.debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> OneSequenceGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind]
[{Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> PrimaryPointerGestureRecognizer
[this.deadline, this.preAcceptSlopTolerance = kTouchSlop, this.postAcceptSlopTolerance = kTouchSlop, Object? debugOwner, PointerDeviceKind? kind]
[{Duration? deadline}, {double? preAcceptSlopTolerance = kTouchSlop}, {double? postAcceptSlopTolerance = kTouchSlop}, {Object? debugOwner}, {PointerDeviceKind? kind}]
For class -> OffsetPair
[required this.local, required this.global]
[{required Offset local}, {required Offset global}]
[PointerEvent event]
[PointerEvent event]
[PointerEvent event]
[PointerEvent event]
For class -> PointerEventResampler
For class -> ScaleStartDetails
[this.focalPoint = Offset.zero, Offset? localFocalPoint, this.pointerCount = 0]
[{Offset focalPoint = Offset.zero}, {Offset? localFocalPoint}, {int pointerCount = 0}]
For class -> ScaleUpdateDetails
[this.focalPoint = Offset.zero, Offset? localFocalPoint, this.scale = 1.0, this.horizontalScale = 1.0, this.verticalScale = 1.0, this.rotation = 0.0, this.pointerCount = 0]
[{Offset focalPoint = Offset.zero}, {Offset? localFocalPoint}, {double scale = 1.0}, {double horizontalScale = 1.0}, {double verticalScale = 1.0}, {double rotation = 0.0}, {int pointerCount = 0}]
For class -> ScaleEndDetails
[this.velocity = Velocity.zero, this.pointerCount = 0]
[{Velocity velocity = Velocity.zero}, {int pointerCount = 0}]
For class -> _LineBetweenPointers
[this.pointerStartLocation = Offset.zero, this.pointerStartId = 0, this.pointerEndLocation = Offset.zero, this.pointerEndId = 1]
[{Offset pointerStartLocation = Offset.zero}, {int pointerStartId = 0}, {Offset pointerEndLocation = Offset.zero}, {int pointerEndId = 1}]
For class -> ScaleGestureRecognizer
[Object? debugOwner, PointerDeviceKind? kind, this.dragStartBehavior = DragStartBehavior.down]
[{Object? debugOwner}, {PointerDeviceKind? kind}, {DragStartBehavior dragStartBehavior = DragStartBehavior.down}]
For class -> TapDownDetails
[this.globalPosition = Offset.zero, Offset? localPosition, this.kind]
[{Offset globalPosition = Offset.zero}, {Offset? localPosition}, {PointerDeviceKind? kind}]
For class -> TapUpDetails
[required this.kind, this.globalPosition = Offset.zero, Offset? localPosition]
[{required PointerDeviceKind kind}, {Offset globalPosition = Offset.zero}, {Offset? localPosition}]
For class -> BaseTapGestureRecognizer
[Object? debugOwner]
[{Object? debugOwner}]
For class -> TapGestureRecognizer
[Object? debugOwner]
[{Object? debugOwner}]
For class -> _CombiningGestureArenaEntry
[this._combiner, this._member]
[_CombiningGestureArenaMember _combiner, GestureArenaMember _member]
For class -> _CombiningGestureArenaMember
[this._owner, this._pointer]
[GestureArenaTeam _owner, int _pointer]
For class -> GestureArenaTeam
For class -> Velocity
[required this.pixelsPerSecond]
[{required Offset pixelsPerSecond}]
For class -> VelocityEstimate
[required this.pixelsPerSecond, required this.confidence, required this.duration, required this.offset]
[{required Offset pixelsPerSecond}, {required double confidence}, {required Duration duration}, {required Offset offset}]
For class -> _PointAtTime
[this.point, this.time]
[Offset point, Duration time]
For class -> VelocityTracker
[this.kind = PointerDeviceKind.touch]
[[PointerDeviceKind kind = PointerDeviceKind.touch]]
[this.kind]
[PointerDeviceKind kind]
For class -> IOSScrollViewFlingVelocityTracker
[PointerDeviceKind kind]
[PointerDeviceKind kind]
For class -> AboutListTile
[Key? key, this.icon, this.child, this.applicationName, this.applicationVersion, this.applicationIcon, this.applicationLegalese, this.aboutBoxChildren, this.dense]
[{Key? key}, {Widget? icon}, {Widget? child}, {String? applicationName}, {String? applicationVersion}, {Widget? applicationIcon}, {String? applicationLegalese}, {List<Widget>? aboutBoxChildren}, {bool? dense}]
For class -> AboutDialog
[Key? key, this.applicationName, this.applicationVersion, this.applicationIcon, this.applicationLegalese, this.children]
[{Key? key}, {String? applicationName}, {String? applicationVersion}, {Widget? applicationIcon}, {String? applicationLegalese}, {List<Widget>? children}]
For class -> LicensePage
[Key? key, this.applicationName, this.applicationVersion, this.applicationIcon, this.applicationLegalese]
[{Key? key}, {String? applicationName}, {String? applicationVersion}, {Widget? applicationIcon}, {String? applicationLegalese}]
For class -> _LicensePageState
For class -> _AboutProgram
[Key? key, required this.name, required this.version, this.icon, this.legalese]
[{Key? key}, {required String name}, {required String version}, {Widget? icon}, {String? legalese}]
For class -> _PackagesView
[Key? key, required this.about, required this.isLateral, required this.selectedId]
[{Key? key}, {required Widget about}, {required bool isLateral}, {required ValueNotifier<int?> selectedId}]
For class -> _PackagesViewState
For class -> _PackageListTile
[Key? key, required this.packageName, this.index, required this.isSelected, required this.numberLicenses, this.onTap]
[{Key? key}, {required String packageName}, {int? index}, {required bool isSelected}, {required int numberLicenses}, {void Function()? onTap}]
For class -> _LicenseData
For class -> _DetailArguments
[this.packageName, this.licenseEntries]
[String packageName, List<LicenseEntry> licenseEntries]
For class -> _PackageLicensePage
[Key? key, required this.packageName, required this.licenseEntries, required this.scrollController]
[{Key? key}, {required String packageName}, {required List<LicenseEntry> licenseEntries}, {required ScrollController? scrollController}]
For class -> _PackageLicensePageState
For class -> _PackageLicensePageTitle
[this.title, this.subtitle, this.theme, Key? key]
[String title, String subtitle, TextTheme theme, {Key? key}]
For class -> _MasterDetailFlow
[Key? key, required this.detailPageBuilder, required this.masterViewBuilder, this.actionBuilder, this.automaticallyImplyLeading = true, this.breakpoint, this.centerTitle, this.detailPageFABGutterWidth, this.detailPageFABlessGutterWidth, this.displayMode = _LayoutMode.auto, this.flexibleSpace, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonMasterPageLocation, this.leading, this.masterPageBuilder, this.masterViewWidth, this.title]
[{Key? key}, {required Widget Function(BuildContext, Object?, ScrollController?) detailPageBuilder}, {required Widget Function(BuildContext, bool) masterViewBuilder}, {List<Widget> Function(BuildContext, _ActionLevel)? actionBuilder}, {bool automaticallyImplyLeading = true}, {double? breakpoint}, {bool? centerTitle}, {double? detailPageFABGutterWidth}, {double? detailPageFABlessGutterWidth}, {_LayoutMode displayMode = _LayoutMode.auto}, {Widget? flexibleSpace}, {FloatingActionButton? floatingActionButton}, {FloatingActionButtonLocation? floatingActionButtonLocation}, {FloatingActionButtonLocation? floatingActionButtonMasterPageLocation}, {Widget? leading}, {Widget Function(BuildContext, bool)? masterPageBuilder}, {double? masterViewWidth}, {Widget? title}]
For class -> _MasterDetailFlowProxy
[this._pageOpener]
[_PageOpener _pageOpener]
For class -> _PageOpener
For class -> _MasterDetailFlowState
For class -> _MasterPage
[Key? key, this.leading, this.title, this.actionBuilder, this.centerTitle, this.flexibleSpace, this.floatingActionButton, this.floatingActionButtonLocation, this.masterViewBuilder, required this.automaticallyImplyLeading]
[{Key? key}, {Widget? leading}, {Widget? title}, {List<Widget> Function(BuildContext, _ActionLevel)? actionBuilder}, {bool? centerTitle}, {Widget? flexibleSpace}, {FloatingActionButton? floatingActionButton}, {FloatingActionButtonLocation? floatingActionButtonLocation}, {Widget Function(BuildContext, bool)? masterViewBuilder}, {required bool automaticallyImplyLeading}]
For class -> _MasterDetailScaffold
[Key? key, required this.detailPageBuilder, required this.masterViewBuilder, this.actionBuilder, this.floatingActionButton, this.floatingActionButtonLocation, this.initialArguments, this.leading, this.title, required this.automaticallyImplyLeading, this.centerTitle, this.detailPageFABlessGutterWidth, this.detailPageFABGutterWidth, this.masterViewWidth]
[{Key? key}, {required Widget Function(BuildContext, Object?, ScrollController?) detailPageBuilder}, {required Widget Function(BuildContext, bool) masterViewBuilder}, {List<Widget> Function(BuildContext, _ActionLevel)? actionBuilder}, {FloatingActionButton? floatingActionButton}, {FloatingActionButtonLocation? floatingActionButtonLocation}, {Object? initialArguments}, {Widget? leading}, {Widget? title}, {required bool automaticallyImplyLeading}, {bool? centerTitle}, {double? detailPageFABlessGutterWidth}, {double? detailPageFABGutterWidth}, {double? masterViewWidth}]
For class -> _MasterDetailScaffoldState
For class -> _DetailView
[Key? key, required _DetailPageBuilder builder, Object? arguments]
[{Key? key}, {required Widget Function(BuildContext, Object?, ScrollController?) builder}, {Object? arguments}]
For class -> AnimatedIcon
[Key? key, required this.icon, required this.progress, this.color, this.size, this.semanticLabel, this.textDirection]
[{Key? key}, {required AnimatedIconData icon}, {required Animation<double> progress}, {Color? color}, {double? size}, {String? semanticLabel}, {TextDirection? textDirection}]
For class -> _AnimatedIconPainter
[required this.paths, required this.progress, required this.color, required this.scale, required this.shouldMirror, required this.uiPathFactory]
[{required List<_PathFrames> paths}, {required Animation<double> progress}, {required Color color}, {required double scale}, {required bool shouldMirror}, {required Path Function() uiPathFactory}]
For class -> _PathFrames
[required this.commands, required this.opacities]
[{required List<_PathCommand> commands}, {required List<double> opacities}]
For class -> _PathCommand
[]
[]
For class -> _PathMoveTo
[this.points]
[List<Offset> points]
For class -> _PathCubicTo
[this.controlPoints1, this.controlPoints2, this.targetPoints]
[List<Offset> controlPoints1, List<Offset> controlPoints2, List<Offset> targetPoints]
For class -> _PathLineTo
[this.points]
[List<Offset> points]
For class -> _PathClose
[]
[]
For class -> AnimatedIcons
For class -> AnimatedIconData
[]
[]
For class -> _AnimatedIconData
[this.size, this.paths, this.matchTextDirection = false]
[Size size, List<_PathFrames> paths, {bool matchTextDirection = false}]
For class -> MaterialApp
[Key? key, this.navigatorKey, this.scaffoldMessengerKey, this.home, Map<String, WidgetBuilder> this.routes = const <String, WidgetBuilder>{}, this.initialRoute, this.onGenerateRoute, this.onGenerateInitialRoutes, this.onUnknownRoute, List<NavigatorObserver> this.navigatorObservers = const <NavigatorObserver>[], this.builder, this.title = '', this.onGenerateTitle, this.color, this.theme, this.darkTheme, this.highContrastTheme, this.highContrastDarkTheme, this.themeMode = ThemeMode.system, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {GlobalKey<NavigatorState>? navigatorKey}, {GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey}, {Widget? home}, {Map<String, Widget Function(BuildContext)> routes = const <String, WidgetBuilder>{}}, {String? initialRoute}, {Route<dynamic>? Function(RouteSettings)? onGenerateRoute}, {List<Route<dynamic>> Function(String)? onGenerateInitialRoutes}, {Route<dynamic>? Function(RouteSettings)? onUnknownRoute}, {List<NavigatorObserver> navigatorObservers = const <NavigatorObserver>[]}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {Color? color}, {ThemeData? theme}, {ThemeData? darkTheme}, {ThemeData? highContrastTheme}, {ThemeData? highContrastDarkTheme}, {ThemeMode? themeMode = ThemeMode.system}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool debugShowMaterialGrid = false}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowCheckedModeBanner = true}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
[Key? key, this.scaffoldMessengerKey, this.routeInformationProvider, required RouteInformationParser<Object> this.routeInformationParser, required RouterDelegate<Object> this.routerDelegate, this.backButtonDispatcher, this.builder, this.title = '', this.onGenerateTitle, this.color, this.theme, this.darkTheme, this.highContrastTheme, this.highContrastDarkTheme, this.themeMode = ThemeMode.system, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey}, {RouteInformationProvider? routeInformationProvider}, {required RouteInformationParser<Object> routeInformationParser}, {required RouterDelegate<Object> routerDelegate}, {BackButtonDispatcher? backButtonDispatcher}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {Color? color}, {ThemeData? theme}, {ThemeData? darkTheme}, {ThemeData? highContrastTheme}, {ThemeData? highContrastDarkTheme}, {ThemeMode? themeMode = ThemeMode.system}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool debugShowMaterialGrid = false}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowCheckedModeBanner = true}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
For class -> _MaterialScrollBehavior
For class -> _MaterialAppState
For class -> _ToolbarContainerLayout
[this.toolbarHeight]
[double toolbarHeight]
For class -> AppBar
[Key? key, this.leading, this.automaticallyImplyLeading = true, this.title, this.actions, this.flexibleSpace, this.bottom, this.elevation, this.shadowColor, this.shape, this.backgroundColor, this.foregroundColor, this.brightness, this.iconTheme, this.actionsIconTheme, this.textTheme, this.primary = true, this.centerTitle, this.excludeHeaderSemantics = false, this.titleSpacing, this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0, this.toolbarHeight, this.leadingWidth, this.backwardsCompatibility, this.toolbarTextStyle, this.titleTextStyle, this.systemOverlayStyle]
[{Key? key}, {Widget? leading}, {bool automaticallyImplyLeading = true}, {Widget? title}, {List<Widget>? actions}, {Widget? flexibleSpace}, {PreferredSizeWidget? bottom}, {double? elevation}, {Color? shadowColor}, {ShapeBorder? shape}, {Color? backgroundColor}, {Color? foregroundColor}, {Brightness? brightness}, {IconThemeData? iconTheme}, {IconThemeData? actionsIconTheme}, {TextTheme? textTheme}, {bool primary = true}, {bool? centerTitle}, {bool excludeHeaderSemantics = false}, {double? titleSpacing}, {double toolbarOpacity = 1.0}, {double bottomOpacity = 1.0}, {double? toolbarHeight}, {double? leadingWidth}, {bool? backwardsCompatibility}, {TextStyle? toolbarTextStyle}, {TextStyle? titleTextStyle}, {SystemUiOverlayStyle? systemOverlayStyle}]
For class -> _AppBarState
For class -> _FloatingAppBar
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> _FloatingAppBarState
For class -> _SliverAppBarDelegate
[required this.leading, required this.automaticallyImplyLeading, required this.title, required this.actions, required this.flexibleSpace, required this.bottom, required this.elevation, required this.shadowColor, required this.forceElevated, required this.backgroundColor, required this.foregroundColor, required this.brightness, required this.iconTheme, required this.actionsIconTheme, required this.textTheme, required this.primary, required this.centerTitle, required this.excludeHeaderSemantics, required this.titleSpacing, required this.expandedHeight, required this.collapsedHeight, required this.topPadding, required this.floating, required this.pinned, required this.vsync, required this.snapConfiguration, required this.stretchConfiguration, required this.showOnScreenConfiguration, required this.shape, required this.toolbarHeight, required this.leadingWidth, required this.backwardsCompatibility, required this.toolbarTextStyle, required this.titleTextStyle, required this.systemOverlayStyle]
[{required Widget? leading}, {required bool automaticallyImplyLeading}, {required Widget? title}, {required List<Widget>? actions}, {required Widget? flexibleSpace}, {required PreferredSizeWidget? bottom}, {required double? elevation}, {required Color? shadowColor}, {required bool forceElevated}, {required Color? backgroundColor}, {required Color? foregroundColor}, {required Brightness? brightness}, {required IconThemeData? iconTheme}, {required IconThemeData? actionsIconTheme}, {required TextTheme? textTheme}, {required bool primary}, {required bool? centerTitle}, {required bool excludeHeaderSemantics}, {required double? titleSpacing}, {required double? expandedHeight}, {required double collapsedHeight}, {required double topPadding}, {required bool floating}, {required bool pinned}, {required TickerProvider vsync}, {required FloatingHeaderSnapConfiguration? snapConfiguration}, {required OverScrollHeaderStretchConfiguration? stretchConfiguration}, {required PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}, {required ShapeBorder? shape}, {required double? toolbarHeight}, {required double? leadingWidth}, {required bool backwardsCompatibility}, {required TextStyle? toolbarTextStyle}, {required TextStyle? titleTextStyle}, {required SystemUiOverlayStyle? systemOverlayStyle}]
For class -> SliverAppBar
[Key? key, this.leading, this.automaticallyImplyLeading = true, this.title, this.actions, this.flexibleSpace, this.bottom, this.elevation, this.shadowColor, this.forceElevated = false, this.backgroundColor, this.foregroundColor, this.brightness, this.iconTheme, this.actionsIconTheme, this.textTheme, this.primary = true, this.centerTitle, this.excludeHeaderSemantics = false, this.titleSpacing, this.collapsedHeight, this.expandedHeight, this.floating = false, this.pinned = false, this.snap = false, this.stretch = false, this.stretchTriggerOffset = 100.0, this.onStretchTrigger, this.shape, this.toolbarHeight = kToolbarHeight, this.leadingWidth, this.backwardsCompatibility = true, this.toolbarTextStyle, this.titleTextStyle, this.systemOverlayStyle]
[{Key? key}, {Widget? leading}, {bool automaticallyImplyLeading = true}, {Widget? title}, {List<Widget>? actions}, {Widget? flexibleSpace}, {PreferredSizeWidget? bottom}, {double? elevation}, {Color? shadowColor}, {bool forceElevated = false}, {Color? backgroundColor}, {Color? foregroundColor}, {Brightness? brightness}, {IconThemeData? iconTheme}, {IconThemeData? actionsIconTheme}, {TextTheme? textTheme}, {bool primary = true}, {bool? centerTitle}, {bool excludeHeaderSemantics = false}, {double? titleSpacing}, {double? collapsedHeight}, {double? expandedHeight}, {bool floating = false}, {bool pinned = false}, {bool snap = false}, {bool stretch = false}, {double stretchTriggerOffset = 100.0}, {Future<void> Function()? onStretchTrigger}, {ShapeBorder? shape}, {double toolbarHeight = kToolbarHeight}, {double? leadingWidth}, {bool backwardsCompatibility = true}, {TextStyle? toolbarTextStyle}, {TextStyle? titleTextStyle}, {SystemUiOverlayStyle? systemOverlayStyle}]
For class -> _SliverAppBarState
For class -> _AppBarTitleBox
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> _RenderAppBarTitleBox
[RenderBox? child, TextDirection? textDirection]
[{RenderBox? child}, {TextDirection? textDirection}]
For class -> AppBarTheme
[this.brightness, Color? color, Color? backgroundColor, this.foregroundColor, this.elevation, this.shadowColor, this.iconTheme, this.actionsIconTheme, this.textTheme, this.centerTitle, this.titleSpacing, this.toolbarTextStyle, this.titleTextStyle, this.systemOverlayStyle, this.backwardsCompatibility]
[{Brightness? brightness}, {Color? color}, {Color? backgroundColor}, {Color? foregroundColor}, {double? elevation}, {Color? shadowColor}, {IconThemeData? iconTheme}, {IconThemeData? actionsIconTheme}, {TextTheme? textTheme}, {bool? centerTitle}, {double? titleSpacing}, {TextStyle? toolbarTextStyle}, {TextStyle? titleTextStyle}, {SystemUiOverlayStyle? systemOverlayStyle}, {bool? backwardsCompatibility}]
For class -> MaterialPointArcTween
[Offset? begin, Offset? end]
[{Offset? begin}, {Offset? end}]
For class -> _Diagonal
[this.beginId, this.endId]
[_CornerId beginId, _CornerId endId]
For class -> MaterialRectArcTween
[Rect? begin, Rect? end]
[{Rect? begin}, {Rect? end}]
For class -> MaterialRectCenterArcTween
[Rect? begin, Rect? end]
[{Rect? begin}, {Rect? end}]
For class -> Autocomplete
[Key? key, required this.optionsBuilder, this.displayStringForOption = RawAutocomplete.defaultStringForOption, this.fieldViewBuilder = _defaultFieldViewBuilder, this.onSelected, this.optionsViewBuilder]
[{Key? key}, {required Iterable<T> Function(TextEditingValue) optionsBuilder}, {String Function(T) displayStringForOption = RawAutocomplete.defaultStringForOption}, {Widget Function(BuildContext, TextEditingController, FocusNode, void Function()) fieldViewBuilder = _defaultFieldViewBuilder}, {void Function(T)? onSelected}, {Widget Function(BuildContext, void Function(T), Iterable<T>)? optionsViewBuilder}]
For class -> _AutocompleteField
[Key? key, required this.focusNode, required this.textEditingController, required this.onFieldSubmitted]
[{Key? key}, {required FocusNode focusNode}, {required TextEditingController textEditingController}, {required void Function() onFieldSubmitted}]
For class -> _AutocompleteOptions
[Key? key, required this.displayStringForOption, required this.onSelected, required this.options]
[{Key? key}, {required String Function(T) displayStringForOption}, {required void Function(T) onSelected}, {required Iterable<T> options}]
For class -> BackButtonIcon
[Key? key]
[{Key? key}]
For class -> BackButton
[Key? key, this.color, this.onPressed]
[{Key? key}, {Color? color}, {void Function()? onPressed}]
For class -> CloseButton
[Key? key, this.color, this.onPressed]
[{Key? key}, {Color? color}, {void Function()? onPressed}]
For class -> MaterialBanner
[Key? key, required this.content, this.contentTextStyle, required this.actions, this.leading, this.backgroundColor, this.padding, this.leadingPadding, this.forceActionsBelow = false, this.overflowAlignment = OverflowBarAlignment.end]
[{Key? key}, {required Widget content}, {TextStyle? contentTextStyle}, {required List<Widget> actions}, {Widget? leading}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {EdgeInsetsGeometry? leadingPadding}, {bool forceActionsBelow = false}, {OverflowBarAlignment overflowAlignment = OverflowBarAlignment.end}]
For class -> MaterialBannerThemeData
[this.backgroundColor, this.contentTextStyle, this.padding, this.leadingPadding]
[{Color? backgroundColor}, {TextStyle? contentTextStyle}, {EdgeInsetsGeometry? padding}, {EdgeInsetsGeometry? leadingPadding}]
For class -> MaterialBannerTheme
[Key? key, this.data, required Widget child]
[{Key? key}, {MaterialBannerThemeData? data}, {required Widget child}]
For class -> BottomAppBar
[Key? key, this.color, this.elevation, this.shape, this.clipBehavior = Clip.none, this.notchMargin = 4.0, this.child]
[{Key? key}, {Color? color}, {double? elevation}, {NotchedShape? shape}, {Clip clipBehavior = Clip.none}, {double notchMargin = 4.0}, {Widget? child}]
For class -> _BottomAppBarState
For class -> _BottomAppBarClipper
[required this.geometry, required this.shape, required this.notchMargin]
[{required ValueListenable<ScaffoldGeometry> geometry}, {required NotchedShape shape}, {required double notchMargin}]
For class -> BottomAppBarTheme
[this.color, this.elevation, this.shape]
[{Color? color}, {double? elevation}, {NotchedShape? shape}]
For class -> BottomNavigationBar
[Key? key, required this.items, this.onTap, this.currentIndex = 0, this.elevation, this.type, Color? fixedColor, this.backgroundColor, this.iconSize = 24.0, Color? selectedItemColor, this.unselectedItemColor, this.selectedIconTheme, this.unselectedIconTheme, this.selectedFontSize = 14.0, this.unselectedFontSize = 12.0, this.selectedLabelStyle, this.unselectedLabelStyle, this.showSelectedLabels, this.showUnselectedLabels, this.mouseCursor]
[{Key? key}, {required List<BottomNavigationBarItem> items}, {void Function(int)? onTap}, {int currentIndex = 0}, {double? elevation}, {BottomNavigationBarType? type}, {Color? fixedColor}, {Color? backgroundColor}, {double iconSize = 24.0}, {Color? selectedItemColor}, {Color? unselectedItemColor}, {IconThemeData? selectedIconTheme}, {IconThemeData? unselectedIconTheme}, {double selectedFontSize = 14.0}, {double unselectedFontSize = 12.0}, {TextStyle? selectedLabelStyle}, {TextStyle? unselectedLabelStyle}, {bool? showSelectedLabels}, {bool? showUnselectedLabels}, {MouseCursor? mouseCursor}]
For class -> _BottomNavigationTile
[this.type, this.item, this.animation, this.iconSize, this.onTap, this.colorTween, this.flex, this.selected = false, required this.selectedLabelStyle, required this.unselectedLabelStyle, required this.selectedIconTheme, required this.unselectedIconTheme, required this.showSelectedLabels, required this.showUnselectedLabels, this.indexLabel, required this.mouseCursor]
[BottomNavigationBarType type, BottomNavigationBarItem item, Animation<double> animation, double iconSize, {void Function()? onTap}, {ColorTween? colorTween}, {double? flex}, {bool selected = false}, {required TextStyle selectedLabelStyle}, {required TextStyle unselectedLabelStyle}, {required IconThemeData? selectedIconTheme}, {required IconThemeData? unselectedIconTheme}, {required bool showSelectedLabels}, {required bool showUnselectedLabels}, {String? indexLabel}, {required MouseCursor mouseCursor}]
For class -> _TileIcon
[Key? key, required this.colorTween, required this.animation, required this.iconSize, required this.selected, required this.item, required this.selectedIconTheme, required this.unselectedIconTheme]
[{Key? key}, {required ColorTween colorTween}, {required Animation<double> animation}, {required double iconSize}, {required bool selected}, {required BottomNavigationBarItem item}, {required IconThemeData? selectedIconTheme}, {required IconThemeData? unselectedIconTheme}]
For class -> _Label
[Key? key, required this.colorTween, required this.animation, required this.item, required this.selectedLabelStyle, required this.unselectedLabelStyle, required this.showSelectedLabels, required this.showUnselectedLabels]
[{Key? key}, {required ColorTween colorTween}, {required Animation<double> animation}, {required BottomNavigationBarItem item}, {required TextStyle selectedLabelStyle}, {required TextStyle unselectedLabelStyle}, {required bool showSelectedLabels}, {required bool showUnselectedLabels}]
For class -> _BottomNavigationBarState
For class -> _Circle
[required this.state, required this.index, required this.color, required TickerProvider vsync]
[{required _BottomNavigationBarState state}, {required int index}, {required Color color}, {required TickerProvider vsync}]
For class -> _RadialPainter
[required this.circles, required this.textDirection]
[{required List<_Circle> circles}, {required TextDirection textDirection}]
For class -> BottomNavigationBarThemeData
[this.backgroundColor, this.elevation, this.selectedIconTheme, this.unselectedIconTheme, this.selectedItemColor, this.unselectedItemColor, this.selectedLabelStyle, this.unselectedLabelStyle, this.showSelectedLabels, this.showUnselectedLabels, this.type]
[{Color? backgroundColor}, {double? elevation}, {IconThemeData? selectedIconTheme}, {IconThemeData? unselectedIconTheme}, {Color? selectedItemColor}, {Color? unselectedItemColor}, {TextStyle? selectedLabelStyle}, {TextStyle? unselectedLabelStyle}, {bool? showSelectedLabels}, {bool? showUnselectedLabels}, {BottomNavigationBarType? type}]
For class -> BottomNavigationBarTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required BottomNavigationBarThemeData data}, {required Widget child}]
For class -> BottomSheet
[Key? key, this.animationController, this.enableDrag = true, this.onDragStart, this.onDragEnd, this.backgroundColor, this.elevation, this.shape, this.clipBehavior, required this.onClosing, required this.builder]
[{Key? key}, {AnimationController? animationController}, {bool enableDrag = true}, {void Function(DragStartDetails)? onDragStart}, {void Function(DragEndDetails, {required bool isClosing})? onDragEnd}, {Color? backgroundColor}, {double? elevation}, {ShapeBorder? shape}, {Clip? clipBehavior}, {required void Function() onClosing}, {required Widget Function(BuildContext) builder}]
For class -> _BottomSheetState
For class -> _ModalBottomSheetLayout
[this.progress, this.isScrollControlled]
[double progress, bool isScrollControlled]
For class -> _ModalBottomSheet
[Key? key, this.route, this.backgroundColor, this.elevation, this.shape, this.clipBehavior, this.isScrollControlled = false, this.enableDrag = true]
[{Key? key}, {_ModalBottomSheetRoute<T>? route}, {Color? backgroundColor}, {double? elevation}, {ShapeBorder? shape}, {Clip? clipBehavior}, {bool isScrollControlled = false}, {bool enableDrag = true}]
For class -> _ModalBottomSheetState
For class -> _ModalBottomSheetRoute
[this.builder, required this.capturedThemes, this.barrierLabel, this.backgroundColor, this.elevation, this.shape, this.clipBehavior, this.modalBarrierColor, this.isDismissible = true, this.enableDrag = true, required this.isScrollControlled, RouteSettings? settings, this.transitionAnimationController]
[{Widget Function(BuildContext)? builder}, {required CapturedThemes capturedThemes}, {String? barrierLabel}, {Color? backgroundColor}, {double? elevation}, {ShapeBorder? shape}, {Clip? clipBehavior}, {Color? modalBarrierColor}, {bool isDismissible = true}, {bool enableDrag = true}, {required bool isScrollControlled}, {RouteSettings? settings}, {AnimationController? transitionAnimationController}]
For class -> _BottomSheetSuspendedCurve
[this.startingPoint, this.curve = Curves.easeOutCubic]
[double startingPoint, {Curve curve = Curves.easeOutCubic}]
For class -> BottomSheetThemeData
[this.backgroundColor, this.elevation, this.modalBackgroundColor, this.modalElevation, this.shape, this.clipBehavior]
[{Color? backgroundColor}, {double? elevation}, {Color? modalBackgroundColor}, {double? modalElevation}, {ShapeBorder? shape}, {Clip? clipBehavior}]
For class -> RawMaterialButton
[Key? key, required this.onPressed, this.onLongPress, this.onHighlightChanged, this.mouseCursor, this.textStyle, this.fillColor, this.focusColor, this.hoverColor, this.highlightColor, this.splashColor, this.elevation = 2.0, this.focusElevation = 4.0, this.hoverElevation = 4.0, this.highlightElevation = 8.0, this.disabledElevation = 0.0, this.padding = EdgeInsets.zero, this.visualDensity = VisualDensity.standard, this.constraints = const BoxConstraints(minWidth: 88.0, minHeight: 36.0), this.shape = const RoundedRectangleBorder(), this.animationDuration = kThemeChangeDuration, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, MaterialTapTargetSize? materialTapTargetSize, this.child, this.enableFeedback = true]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {TextStyle? textStyle}, {Color? fillColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {double elevation = 2.0}, {double focusElevation = 4.0}, {double hoverElevation = 4.0}, {double highlightElevation = 8.0}, {double disabledElevation = 0.0}, {EdgeInsetsGeometry padding = EdgeInsets.zero}, {VisualDensity visualDensity = VisualDensity.standard}, {BoxConstraints constraints = const BoxConstraints(minWidth: 88.0, minHeight: 36.0)}, {ShapeBorder shape = const RoundedRectangleBorder()}, {Duration animationDuration = kThemeChangeDuration}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {Widget? child}, {bool enableFeedback = true}]
For class -> _RawMaterialButtonState
For class -> _InputPadding
[Key? key, Widget? child, required this.minSize]
[{Key? key}, {Widget? child}, {required Size minSize}]
For class -> _RenderInputPadding
[this._minSize, RenderBox? child]
[Size _minSize, [RenderBox? child]]
For class -> ButtonBar
[Key? key, this.alignment, this.mainAxisSize, this.buttonTextTheme, this.buttonMinWidth, this.buttonHeight, this.buttonPadding, this.buttonAlignedDropdown, this.layoutBehavior, this.overflowDirection, this.overflowButtonSpacing, this.children = const <Widget>[]]
[{Key? key}, {MainAxisAlignment? alignment}, {MainAxisSize? mainAxisSize}, {ButtonTextTheme? buttonTextTheme}, {double? buttonMinWidth}, {double? buttonHeight}, {EdgeInsetsGeometry? buttonPadding}, {bool? buttonAlignedDropdown}, {ButtonBarLayoutBehavior? layoutBehavior}, {VerticalDirection? overflowDirection}, {double? overflowButtonSpacing}, {List<Widget> children = const <Widget>[]}]
For class -> _ButtonBarRow
[required List<Widget> children, Axis direction = Axis.horizontal, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection overflowDirection = VerticalDirection.down, TextBaseline? textBaseline, this.overflowButtonSpacing]
[{required List<Widget> children}, {Axis direction = Axis.horizontal}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {TextDirection? textDirection}, {VerticalDirection overflowDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {double? overflowButtonSpacing}]
For class -> _RenderButtonBarRow
[List<RenderBox>? children, Axis direction = Axis.horizontal, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, required TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, this.overflowButtonSpacing]
[{List<RenderBox>? children}, {Axis direction = Axis.horizontal}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {required TextDirection textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {double? overflowButtonSpacing}]
For class -> ButtonBarThemeData
[this.alignment, this.mainAxisSize, this.buttonTextTheme, this.buttonMinWidth, this.buttonHeight, this.buttonPadding, this.buttonAlignedDropdown, this.layoutBehavior, this.overflowDirection]
[{MainAxisAlignment? alignment}, {MainAxisSize? mainAxisSize}, {ButtonTextTheme? buttonTextTheme}, {double? buttonMinWidth}, {double? buttonHeight}, {EdgeInsetsGeometry? buttonPadding}, {bool? buttonAlignedDropdown}, {ButtonBarLayoutBehavior? layoutBehavior}, {VerticalDirection? overflowDirection}]
For class -> ButtonBarTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ButtonBarThemeData data}, {required Widget child}]
For class -> ButtonStyle
[this.textStyle, this.backgroundColor, this.foregroundColor, this.overlayColor, this.shadowColor, this.elevation, this.padding, this.minimumSize, this.side, this.shape, this.mouseCursor, this.visualDensity, this.tapTargetSize, this.animationDuration, this.enableFeedback, this.alignment]
[{MaterialStateProperty<TextStyle?>? textStyle}, {MaterialStateProperty<Color?>? backgroundColor}, {MaterialStateProperty<Color?>? foregroundColor}, {MaterialStateProperty<Color?>? overlayColor}, {MaterialStateProperty<Color?>? shadowColor}, {MaterialStateProperty<double?>? elevation}, {MaterialStateProperty<EdgeInsetsGeometry?>? padding}, {MaterialStateProperty<Size?>? minimumSize}, {MaterialStateProperty<BorderSide?>? side}, {MaterialStateProperty<OutlinedBorder?>? shape}, {MaterialStateProperty<MouseCursor?>? mouseCursor}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? tapTargetSize}, {Duration? animationDuration}, {bool? enableFeedback}, {AlignmentGeometry? alignment}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T? Function(T?, T?, double) lerpFunction]
For class -> _LerpSides
[this.a, this.b, this.t]
[MaterialStateProperty<BorderSide?>? a, MaterialStateProperty<BorderSide?>? b, double t]
For class -> _LerpShapes
[this.a, this.b, this.t]
[MaterialStateProperty<OutlinedBorder?>? a, MaterialStateProperty<OutlinedBorder?>? b, double t]
For class -> ButtonStyleButton
[Key? key, required this.onPressed, required this.onLongPress, required this.style, required this.focusNode, required this.autofocus, required this.clipBehavior, required this.child]
[{Key? key}, {required void Function()? onPressed}, {required void Function()? onLongPress}, {required ButtonStyle? style}, {required FocusNode? focusNode}, {required bool autofocus}, {required Clip clipBehavior}, {required Widget? child}]
For class -> _ButtonStyleState
For class -> _MouseCursor
[this.resolveCallback]
[MouseCursor? Function(Set<MaterialState>) resolveCallback]
For class -> _InputPadding
[Key? key, Widget? child, required this.minSize]
[{Key? key}, {Widget? child}, {required Size minSize}]
For class -> _RenderInputPadding
[this._minSize, RenderBox? child]
[Size _minSize, [RenderBox? child]]
For class -> ButtonTheme
[Key? key, ButtonTextTheme textTheme = ButtonTextTheme.normal, ButtonBarLayoutBehavior layoutBehavior = ButtonBarLayoutBehavior.padded, double minWidth = 88.0, double height = 36.0, EdgeInsetsGeometry? padding, ShapeBorder? shape, bool alignedDropdown = false, Color? buttonColor, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, ColorScheme? colorScheme, MaterialTapTargetSize? materialTapTargetSize, required Widget child]
[{Key? key}, {ButtonTextTheme textTheme = ButtonTextTheme.normal}, {ButtonBarLayoutBehavior layoutBehavior = ButtonBarLayoutBehavior.padded}, {double minWidth = 88.0}, {double height = 36.0}, {EdgeInsetsGeometry? padding}, {ShapeBorder? shape}, {bool alignedDropdown = false}, {Color? buttonColor}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {ColorScheme? colorScheme}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget child}]
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ButtonThemeData data}, {required Widget child}]
For class -> ButtonThemeData
[this.textTheme = ButtonTextTheme.normal, this.minWidth = 88.0, this.height = 36.0, EdgeInsetsGeometry? padding, ShapeBorder? shape, this.layoutBehavior = ButtonBarLayoutBehavior.padded, this.alignedDropdown = false, Color? buttonColor, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, this.colorScheme, MaterialTapTargetSize? materialTapTargetSize]
[{ButtonTextTheme textTheme = ButtonTextTheme.normal}, {double minWidth = 88.0}, {double height = 36.0}, {EdgeInsetsGeometry? padding}, {ShapeBorder? shape}, {ButtonBarLayoutBehavior layoutBehavior = ButtonBarLayoutBehavior.padded}, {bool alignedDropdown = false}, {Color? buttonColor}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {ColorScheme? colorScheme}, {MaterialTapTargetSize? materialTapTargetSize}]
For class -> CalendarDatePicker
[Key? key, required DateTime initialDate, required DateTime firstDate, required DateTime lastDate, DateTime? currentDate, required this.onDateChanged, this.onDisplayedMonthChanged, this.initialCalendarMode = DatePickerMode.day, this.selectableDayPredicate]
[{Key? key}, {required DateTime initialDate}, {required DateTime firstDate}, {required DateTime lastDate}, {DateTime? currentDate}, {required void Function(DateTime) onDateChanged}, {void Function(DateTime)? onDisplayedMonthChanged}, {DatePickerMode initialCalendarMode = DatePickerMode.day}, {bool Function(DateTime)? selectableDayPredicate}]
For class -> _CalendarDatePickerState
For class -> _DatePickerModeToggleButton
[required this.mode, required this.title, required this.onTitlePressed]
[{required DatePickerMode mode}, {required String title}, {required void Function() onTitlePressed}]
For class -> _DatePickerModeToggleButtonState
For class -> _MonthPicker
[Key? key, required this.initialMonth, required this.currentDate, required this.firstDate, required this.lastDate, required this.selectedDate, required this.onChanged, required this.onDisplayedMonthChanged, this.selectableDayPredicate]
[{Key? key}, {required DateTime initialMonth}, {required DateTime currentDate}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime selectedDate}, {required void Function(DateTime) onChanged}, {required void Function(DateTime) onDisplayedMonthChanged}, {bool Function(DateTime)? selectableDayPredicate}]
For class -> _MonthPickerState
For class -> _FocusedDate
[Key? key, required Widget child, this.date]
[{Key? key}, {required Widget child}, {DateTime? date}]
For class -> _DayPicker
[Key? key, required this.currentDate, required this.displayedMonth, required this.firstDate, required this.lastDate, required this.selectedDate, required this.onChanged, this.selectableDayPredicate]
[{Key? key}, {required DateTime currentDate}, {required DateTime displayedMonth}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime selectedDate}, {required void Function(DateTime) onChanged}, {bool Function(DateTime)? selectableDayPredicate}]
For class -> _DayPickerState
For class -> _DayPickerGridDelegate
[]
[]
For class -> YearPicker
[Key? key, DateTime? currentDate, required this.firstDate, required this.lastDate, DateTime? initialDate, required this.selectedDate, required this.onChanged, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {DateTime? currentDate}, {required DateTime firstDate}, {required DateTime lastDate}, {DateTime? initialDate}, {required DateTime selectedDate}, {required void Function(DateTime) onChanged}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _YearPickerState
For class -> _YearPickerGridDelegate
[]
[]
For class -> Card
[Key? key, this.color, this.shadowColor, this.elevation, this.shape, this.borderOnForeground = true, this.margin, this.clipBehavior, this.child, this.semanticContainer = true]
[{Key? key}, {Color? color}, {Color? shadowColor}, {double? elevation}, {ShapeBorder? shape}, {bool borderOnForeground = true}, {EdgeInsetsGeometry? margin}, {Clip? clipBehavior}, {Widget? child}, {bool semanticContainer = true}]
For class -> CardTheme
[this.clipBehavior, this.color, this.shadowColor, this.elevation, this.margin, this.shape]
[{Clip? clipBehavior}, {Color? color}, {Color? shadowColor}, {double? elevation}, {EdgeInsetsGeometry? margin}, {ShapeBorder? shape}]
For class -> Checkbox
[Key? key, required this.value, this.tristate = false, required this.onChanged, this.mouseCursor, this.activeColor, this.fillColor, this.checkColor, this.focusColor, this.hoverColor, this.overlayColor, this.splashRadius, this.materialTapTargetSize, this.visualDensity, this.focusNode, this.autofocus = false]
[{Key? key}, {required bool? value}, {bool tristate = false}, {required void Function(bool?)? onChanged}, {MouseCursor? mouseCursor}, {Color? activeColor}, {MaterialStateProperty<Color?>? fillColor}, {Color? checkColor}, {Color? focusColor}, {Color? hoverColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {MaterialTapTargetSize? materialTapTargetSize}, {VisualDensity? visualDensity}, {FocusNode? focusNode}, {bool autofocus = false}]
For class -> _CheckboxState
For class -> _CheckboxRenderObjectWidget
[Key? key, required this.value, required this.tristate, required this.activeColor, required this.checkColor, required this.inactiveColor, required this.focusColor, required this.hoverColor, required this.reactionColor, required this.inactiveReactionColor, required this.splashRadius, required this.onChanged, required this.vsync, required this.additionalConstraints, required this.hasFocus, required this.hovering]
[{Key? key}, {required bool? value}, {required bool tristate}, {required Color activeColor}, {required Color checkColor}, {required Color inactiveColor}, {required Color focusColor}, {required Color hoverColor}, {required Color reactionColor}, {required Color inactiveReactionColor}, {required double splashRadius}, {required void Function(bool?)? onChanged}, {required TickerProvider vsync}, {required BoxConstraints additionalConstraints}, {required bool hasFocus}, {required bool hovering}]
For class -> _RenderCheckbox
[bool? value, required bool tristate, required Color activeColor, required this.checkColor, required Color inactiveColor, Color? focusColor, Color? hoverColor, Color? reactionColor, Color? inactiveReactionColor, required double splashRadius, required BoxConstraints additionalConstraints, ValueChanged<bool?>? onChanged, required bool hasFocus, required bool hovering, required TickerProvider vsync]
[{bool? value}, {required bool tristate}, {required Color activeColor}, {required Color checkColor}, {required Color inactiveColor}, {Color? focusColor}, {Color? hoverColor}, {Color? reactionColor}, {Color? inactiveReactionColor}, {required double splashRadius}, {required BoxConstraints additionalConstraints}, {void Function(bool?)? onChanged}, {required bool hasFocus}, {required bool hovering}, {required TickerProvider vsync}]
For class -> CheckboxListTile
[Key? key, required this.value, required this.onChanged, this.activeColor, this.checkColor, this.tileColor, this.title, this.subtitle, this.isThreeLine = false, this.dense, this.secondary, this.selected = false, this.controlAffinity = ListTileControlAffinity.platform, this.autofocus = false, this.contentPadding, this.tristate = false, this.shape, this.selectedTileColor]
[{Key? key}, {required bool? value}, {required void Function(bool?)? onChanged}, {Color? activeColor}, {Color? checkColor}, {Color? tileColor}, {Widget? title}, {Widget? subtitle}, {bool isThreeLine = false}, {bool? dense}, {Widget? secondary}, {bool selected = false}, {ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform}, {bool autofocus = false}, {EdgeInsetsGeometry? contentPadding}, {bool tristate = false}, {ShapeBorder? shape}, {Color? selectedTileColor}]
For class -> CheckboxThemeData
[this.mouseCursor, this.fillColor, this.checkColor, this.overlayColor, this.splashRadius, this.materialTapTargetSize, this.visualDensity]
[{MaterialStateProperty<MouseCursor?>? mouseCursor}, {MaterialStateProperty<Color?>? fillColor}, {MaterialStateProperty<Color?>? checkColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {MaterialTapTargetSize? materialTapTargetSize}, {VisualDensity? visualDensity}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T Function(T?, T?, double) lerpFunction]
For class -> CheckboxTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required CheckboxThemeData data}, {required Widget child}]
For class -> ChipAttributes
[]
[]
For class -> DeletableChipAttributes
[]
[]
For class -> CheckmarkableChipAttributes
[]
[]
For class -> SelectableChipAttributes
[]
[]
For class -> DisabledChipAttributes
[]
[]
For class -> TappableChipAttributes
[]
[]
For class -> Chip
[Key? key, this.avatar, required this.label, this.labelStyle, this.labelPadding, this.deleteIcon, this.onDeleted, this.deleteIconColor, this.useDeleteButtonTooltip = true, this.deleteButtonTooltipMessage, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.padding, this.visualDensity, this.materialTapTargetSize, this.elevation, this.shadowColor]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {Widget? deleteIcon}, {void Function()? onDeleted}, {Color? deleteIconColor}, {bool useDeleteButtonTooltip = true}, {String? deleteButtonTooltipMessage}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}]
For class -> InputChip
[Key? key, this.avatar, required this.label, this.labelStyle, this.labelPadding, this.selected = false, this.isEnabled = true, this.onSelected, this.deleteIcon, this.onDeleted, this.deleteIconColor, this.useDeleteButtonTooltip = true, this.deleteButtonTooltipMessage, this.onPressed, this.pressElevation, this.disabledColor, this.selectedColor, this.tooltip, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.padding, this.visualDensity, this.materialTapTargetSize, this.elevation, this.shadowColor, this.selectedShadowColor, this.showCheckmark, this.checkmarkColor, this.avatarBorder = const CircleBorder()]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {bool selected = false}, {bool isEnabled = true}, {void Function(bool)? onSelected}, {Widget? deleteIcon}, {void Function()? onDeleted}, {Color? deleteIconColor}, {bool useDeleteButtonTooltip = true}, {String? deleteButtonTooltipMessage}, {void Function()? onPressed}, {double? pressElevation}, {Color? disabledColor}, {Color? selectedColor}, {String? tooltip}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}, {Color? selectedShadowColor}, {bool? showCheckmark}, {Color? checkmarkColor}, {ShapeBorder avatarBorder = const CircleBorder()}]
For class -> ChoiceChip
[Key? key, this.avatar, required this.label, this.labelStyle, this.labelPadding, this.onSelected, this.pressElevation, required this.selected, this.selectedColor, this.disabledColor, this.tooltip, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.padding, this.visualDensity, this.materialTapTargetSize, this.elevation, this.shadowColor, this.selectedShadowColor, this.avatarBorder = const CircleBorder()]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {void Function(bool)? onSelected}, {double? pressElevation}, {required bool selected}, {Color? selectedColor}, {Color? disabledColor}, {String? tooltip}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}, {Color? selectedShadowColor}, {ShapeBorder avatarBorder = const CircleBorder()}]
For class -> FilterChip
[Key? key, this.avatar, required this.label, this.labelStyle, this.labelPadding, this.selected = false, required this.onSelected, this.pressElevation, this.disabledColor, this.selectedColor, this.tooltip, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.padding, this.visualDensity, this.materialTapTargetSize, this.elevation, this.shadowColor, this.selectedShadowColor, this.showCheckmark, this.checkmarkColor, this.avatarBorder = const CircleBorder()]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {bool selected = false}, {required void Function(bool)? onSelected}, {double? pressElevation}, {Color? disabledColor}, {Color? selectedColor}, {String? tooltip}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}, {Color? selectedShadowColor}, {bool? showCheckmark}, {Color? checkmarkColor}, {ShapeBorder avatarBorder = const CircleBorder()}]
For class -> ActionChip
[Key? key, this.avatar, required this.label, this.labelStyle, this.labelPadding, required this.onPressed, this.pressElevation, this.tooltip, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.padding, this.visualDensity, this.materialTapTargetSize, this.elevation, this.shadowColor]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {required void Function() onPressed}, {double? pressElevation}, {String? tooltip}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}]
For class -> RawChip
[Key? key, this.avatar, required this.label, this.labelStyle, this.padding, this.visualDensity, this.labelPadding, Widget? deleteIcon, this.onDeleted, this.deleteIconColor, this.useDeleteButtonTooltip = true, this.deleteButtonTooltipMessage, this.onPressed, this.onSelected, this.pressElevation, this.tapEnabled = true, this.selected = false, this.isEnabled = true, this.disabledColor, this.selectedColor, this.tooltip, this.side, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.backgroundColor, this.materialTapTargetSize, this.elevation, this.shadowColor, this.selectedShadowColor, this.showCheckmark = true, this.checkmarkColor, this.avatarBorder = const CircleBorder()]
[{Key? key}, {Widget? avatar}, {required Widget label}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {EdgeInsetsGeometry? labelPadding}, {Widget? deleteIcon}, {void Function()? onDeleted}, {Color? deleteIconColor}, {bool useDeleteButtonTooltip = true}, {String? deleteButtonTooltipMessage}, {void Function()? onPressed}, {void Function(bool)? onSelected}, {double? pressElevation}, {bool tapEnabled = true}, {bool selected = false}, {bool isEnabled = true}, {Color? disabledColor}, {Color? selectedColor}, {String? tooltip}, {BorderSide? side}, {OutlinedBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? backgroundColor}, {MaterialTapTargetSize? materialTapTargetSize}, {double? elevation}, {Color? shadowColor}, {Color? selectedShadowColor}, {bool? showCheckmark = true}, {Color? checkmarkColor}, {ShapeBorder avatarBorder = const CircleBorder()}]
For class -> _RawChipState
For class -> _ChipRedirectingHitDetectionWidget
[Key? key, Widget? child, required this.constraints]
[{Key? key}, {Widget? child}, {required BoxConstraints constraints}]
For class -> _RenderChipRedirectingHitDetection
[BoxConstraints additionalConstraints]
[BoxConstraints additionalConstraints]
For class -> _ChipRenderWidget
[Key? key, required this.theme, this.value, this.isEnabled, required this.checkmarkAnimation, required this.avatarDrawerAnimation, required this.deleteDrawerAnimation, required this.enableAnimation, this.avatarBorder]
[{Key? key}, {required _ChipRenderTheme theme}, {bool? value}, {bool? isEnabled}, {required Animation<double> checkmarkAnimation}, {required Animation<double> avatarDrawerAnimation}, {required Animation<double> deleteDrawerAnimation}, {required Animation<double> enableAnimation}, {ShapeBorder? avatarBorder}]
For class -> _RenderChipElement
[_ChipRenderWidget chip]
[_ChipRenderWidget chip]
For class -> _ChipRenderTheme
[required this.avatar, required this.label, required this.deleteIcon, required this.brightness, required this.padding, required this.visualDensity, required this.labelPadding, required this.showAvatar, required this.showCheckmark, required this.checkmarkColor, required this.canTapBody]
[{required Widget avatar}, {required Widget label}, {required Widget deleteIcon}, {required Brightness brightness}, {required EdgeInsets padding}, {required VisualDensity visualDensity}, {required EdgeInsets labelPadding}, {required bool showAvatar}, {required bool showCheckmark}, {required Color? checkmarkColor}, {required bool canTapBody}]
For class -> _RenderChip
[required _ChipRenderTheme theme, required TextDirection textDirection, this.value, this.isEnabled, required this.checkmarkAnimation, required this.avatarDrawerAnimation, required this.deleteDrawerAnimation, required this.enableAnimation, this.avatarBorder]
[{required _ChipRenderTheme theme}, {required TextDirection textDirection}, {bool? value}, {bool? isEnabled}, {required Animation<double> checkmarkAnimation}, {required Animation<double> avatarDrawerAnimation}, {required Animation<double> deleteDrawerAnimation}, {required Animation<double> enableAnimation}, {ShapeBorder? avatarBorder}]
For class -> _ChipSizes
[required this.size, required this.overall, required this.content, required this.avatar, required this.label, required this.deleteIcon, required this.densityAdjustment]
[{required Size size}, {required Size overall}, {required double content}, {required Size avatar}, {required Size label}, {required Size deleteIcon}, {required Offset densityAdjustment}]
For class -> _LocationAwareInkRippleFactory
[this.hasDeleteButton, this.chipContext, this.deleteIconKey]
[bool hasDeleteButton, BuildContext chipContext, GlobalKey<State<StatefulWidget>> deleteIconKey]
For class -> ChipTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ChipThemeData data}, {required Widget child}]
For class -> ChipThemeData
[required this.backgroundColor, this.deleteIconColor, required this.disabledColor, required this.selectedColor, required this.secondarySelectedColor, this.shadowColor, this.selectedShadowColor, this.showCheckmark, this.checkmarkColor, this.labelPadding, required this.padding, this.side, this.shape, required this.labelStyle, required this.secondaryLabelStyle, required this.brightness, this.elevation, this.pressElevation]
[{required Color backgroundColor}, {Color? deleteIconColor}, {required Color disabledColor}, {required Color selectedColor}, {required Color secondarySelectedColor}, {Color? shadowColor}, {Color? selectedShadowColor}, {bool? showCheckmark}, {Color? checkmarkColor}, {EdgeInsetsGeometry? labelPadding}, {required EdgeInsetsGeometry padding}, {BorderSide? side}, {OutlinedBorder? shape}, {required TextStyle labelStyle}, {required TextStyle secondaryLabelStyle}, {required Brightness brightness}, {double? elevation}, {double? pressElevation}]
[Brightness? brightness, Color? primaryColor, required Color secondaryColor, required TextStyle labelStyle]
[{Brightness? brightness}, {Color? primaryColor}, {required Color secondaryColor}, {required TextStyle labelStyle}]
For class -> CircleAvatar
[Key? key, this.child, this.backgroundColor, this.backgroundImage, this.foregroundImage, this.onBackgroundImageError, this.onForegroundImageError, this.foregroundColor, this.radius, this.minRadius, this.maxRadius]
[{Key? key}, {Widget? child}, {Color? backgroundColor}, {ImageProvider<Object>? backgroundImage}, {ImageProvider<Object>? foregroundImage}, {void Function(Object, StackTrace?)? onBackgroundImageError}, {void Function(Object, StackTrace?)? onForegroundImageError}, {Color? foregroundColor}, {double? radius}, {double? minRadius}, {double? maxRadius}]
For class -> MaterialColor
[int primary, Map<int, Color> swatch]
[int primary, Map<int, Color> swatch]
For class -> MaterialAccentColor
[int primary, Map<int, Color> swatch]
[int primary, Map<int, Color> swatch]
For class -> Colors
[]
[]
For class -> ColorScheme
[required this.primary, required this.primaryVariant, required this.secondary, required this.secondaryVariant, required this.surface, required this.background, required this.error, required this.onPrimary, required this.onSecondary, required this.onSurface, required this.onBackground, required this.onError, required this.brightness]
[{required Color primary}, {required Color primaryVariant}, {required Color secondary}, {required Color secondaryVariant}, {required Color surface}, {required Color background}, {required Color error}, {required Color onPrimary}, {required Color onSecondary}, {required Color onSurface}, {required Color onBackground}, {required Color onError}, {required Brightness brightness}]
[this.primary = const Color(0xff6200ee), this.primaryVariant = const Color(0xff3700b3), this.secondary = const Color(0xff03dac6), this.secondaryVariant = const Color(0xff018786), this.surface = Colors.white, this.background = Colors.white, this.error = const Color(0xffb00020), this.onPrimary = Colors.white, this.onSecondary = Colors.black, this.onSurface = Colors.black, this.onBackground = Colors.black, this.onError = Colors.white, this.brightness = Brightness.light]
[{Color primary = const Color(0xff6200ee)}, {Color primaryVariant = const Color(0xff3700b3)}, {Color secondary = const Color(0xff03dac6)}, {Color secondaryVariant = const Color(0xff018786)}, {Color surface = Colors.white}, {Color background = Colors.white}, {Color error = const Color(0xffb00020)}, {Color onPrimary = Colors.white}, {Color onSecondary = Colors.black}, {Color onSurface = Colors.black}, {Color onBackground = Colors.black}, {Color onError = Colors.white}, {Brightness brightness = Brightness.light}]
[this.primary = const Color(0xffbb86fc), this.primaryVariant = const Color(0xff3700B3), this.secondary = const Color(0xff03dac6), this.secondaryVariant = const Color(0xff03dac6), this.surface = const Color(0xff121212), this.background = const Color(0xff121212), this.error = const Color(0xffcf6679), this.onPrimary = Colors.black, this.onSecondary = Colors.black, this.onSurface = Colors.white, this.onBackground = Colors.white, this.onError = Colors.black, this.brightness = Brightness.dark]
[{Color primary = const Color(0xffbb86fc)}, {Color primaryVariant = const Color(0xff3700B3)}, {Color secondary = const Color(0xff03dac6)}, {Color secondaryVariant = const Color(0xff03dac6)}, {Color surface = const Color(0xff121212)}, {Color background = const Color(0xff121212)}, {Color error = const Color(0xffcf6679)}, {Color onPrimary = Colors.black}, {Color onSecondary = Colors.black}, {Color onSurface = Colors.white}, {Color onBackground = Colors.white}, {Color onError = Colors.black}, {Brightness brightness = Brightness.dark}]
[this.primary = const Color(0xff0000ba), this.primaryVariant = const Color(0xff000088), this.secondary = const Color(0xff66fff9), this.secondaryVariant = const Color(0xff018786), this.surface = Colors.white, this.background = Colors.white, this.error = const Color(0xff790000), this.onPrimary = Colors.white, this.onSecondary = Colors.black, this.onSurface = Colors.black, this.onBackground = Colors.black, this.onError = Colors.white, this.brightness = Brightness.light]
[{Color primary = const Color(0xff0000ba)}, {Color primaryVariant = const Color(0xff000088)}, {Color secondary = const Color(0xff66fff9)}, {Color secondaryVariant = const Color(0xff018786)}, {Color surface = Colors.white}, {Color background = Colors.white}, {Color error = const Color(0xff790000)}, {Color onPrimary = Colors.white}, {Color onSecondary = Colors.black}, {Color onSurface = Colors.black}, {Color onBackground = Colors.black}, {Color onError = Colors.white}, {Brightness brightness = Brightness.light}]
[this.primary = const Color(0xffefb7ff), this.primaryVariant = const Color(0xffbe9eff), this.secondary = const Color(0xff66fff9), this.secondaryVariant = const Color(0xff66fff9), this.surface = const Color(0xff121212), this.background = const Color(0xff121212), this.error = const Color(0xff9b374d), this.onPrimary = Colors.black, this.onSecondary = Colors.black, this.onSurface = Colors.white, this.onBackground = Colors.white, this.onError = Colors.black, this.brightness = Brightness.dark]
[{Color primary = const Color(0xffefb7ff)}, {Color primaryVariant = const Color(0xffbe9eff)}, {Color secondary = const Color(0xff66fff9)}, {Color secondaryVariant = const Color(0xff66fff9)}, {Color surface = const Color(0xff121212)}, {Color background = const Color(0xff121212)}, {Color error = const Color(0xff9b374d)}, {Color onPrimary = Colors.black}, {Color onSecondary = Colors.black}, {Color onSurface = Colors.white}, {Color onBackground = Colors.white}, {Color onError = Colors.black}, {Brightness brightness = Brightness.dark}]
[MaterialColor primarySwatch = Colors.blue, Color? primaryColorDark, Color? accentColor, Color? cardColor, Color? backgroundColor, Color? errorColor, Brightness brightness = Brightness.light]
[{MaterialColor primarySwatch = Colors.blue}, {Color? primaryColorDark}, {Color? accentColor}, {Color? cardColor}, {Color? backgroundColor}, {Color? errorColor}, {Brightness brightness = Brightness.light}]
For class -> DataColumn
[required this.label, this.tooltip, this.numeric = false, this.onSort]
[{required Widget label}, {String? tooltip}, {bool numeric = false}, {void Function(int, bool)? onSort}]
For class -> DataRow
[this.key, this.selected = false, this.onSelectChanged, this.color, required this.cells]
[{LocalKey? key}, {bool selected = false}, {void Function(bool?)? onSelectChanged}, {MaterialStateProperty<Color?>? color}, {required List<DataCell> cells}]
[int? index, this.selected = false, this.onSelectChanged, this.color, required this.cells]
[{int? index}, {bool selected = false}, {void Function(bool?)? onSelectChanged}, {MaterialStateProperty<Color?>? color}, {required List<DataCell> cells}]
For class -> DataCell
[this.child, this.placeholder = false, this.showEditIcon = false, this.onTap]
[Widget child, {bool placeholder = false}, {bool showEditIcon = false}, {void Function()? onTap}]
For class -> DataTable
[Key? key, required this.columns, this.sortColumnIndex, this.sortAscending = true, this.onSelectAll, this.decoration, this.dataRowColor, this.dataRowHeight, this.dataTextStyle, this.headingRowColor, this.headingRowHeight, this.headingTextStyle, this.horizontalMargin, this.columnSpacing, this.showCheckboxColumn = true, this.showBottomBorder = false, this.dividerThickness, required this.rows]
[{Key? key}, {required List<DataColumn> columns}, {int? sortColumnIndex}, {bool sortAscending = true}, {void Function(bool?)? onSelectAll}, {Decoration? decoration}, {MaterialStateProperty<Color?>? dataRowColor}, {double? dataRowHeight}, {TextStyle? dataTextStyle}, {MaterialStateProperty<Color?>? headingRowColor}, {double? headingRowHeight}, {TextStyle? headingTextStyle}, {double? horizontalMargin}, {double? columnSpacing}, {bool showCheckboxColumn = true}, {bool showBottomBorder = false}, {double? dividerThickness}, {required List<DataRow> rows}]
For class -> TableRowInkWell
[Key? key, Widget? child, GestureTapCallback? onTap, GestureTapCallback? onDoubleTap, GestureLongPressCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MaterialStateProperty<Color?>? overlayColor]
[{Key? key}, {Widget? child}, {void Function()? onTap}, {void Function()? onDoubleTap}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MaterialStateProperty<Color?>? overlayColor}]
For class -> _SortArrow
[Key? key, required this.visible, required this.up, required this.duration]
[{Key? key}, {required bool visible}, {required bool? up}, {required Duration duration}]
For class -> _SortArrowState
For class -> _NullTableColumnWidth
[]
[]
For class -> _NullWidget
[]
[]
For class -> DataTableSource
For class -> DataTableThemeData
[this.decoration, this.dataRowColor, this.dataRowHeight, this.dataTextStyle, this.headingRowColor, this.headingRowHeight, this.headingTextStyle, this.horizontalMargin, this.columnSpacing, this.dividerThickness]
[{Decoration? decoration}, {MaterialStateProperty<Color?>? dataRowColor}, {double? dataRowHeight}, {TextStyle? dataTextStyle}, {MaterialStateProperty<Color?>? headingRowColor}, {double? headingRowHeight}, {TextStyle? headingTextStyle}, {double? horizontalMargin}, {double? columnSpacing}, {double? dividerThickness}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T Function(T?, T?, double) lerpFunction]
For class -> DataTableTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required DataTableThemeData data}, {required Widget child}]
For class -> DateUtils
[]
[]
For class -> DateTimeRange
[required this.start, required this.end]
[{required DateTime start}, {required DateTime end}]
For class -> _DatePickerDialog
[Key? key, required DateTime initialDate, required DateTime firstDate, required DateTime lastDate, DateTime? currentDate, this.initialEntryMode = DatePickerEntryMode.calendar, this.selectableDayPredicate, this.cancelText, this.confirmText, this.helpText, this.initialCalendarMode = DatePickerMode.day, this.errorFormatText, this.errorInvalidText, this.fieldHintText, this.fieldLabelText]
[{Key? key}, {required DateTime initialDate}, {required DateTime firstDate}, {required DateTime lastDate}, {DateTime? currentDate}, {DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar}, {bool Function(DateTime)? selectableDayPredicate}, {String? cancelText}, {String? confirmText}, {String? helpText}, {DatePickerMode initialCalendarMode = DatePickerMode.day}, {String? errorFormatText}, {String? errorInvalidText}, {String? fieldHintText}, {String? fieldLabelText}]
For class -> _DatePickerDialogState
For class -> _DatePickerHeader
[Key? key, required this.helpText, required this.titleText, this.titleSemanticsLabel, required this.titleStyle, required this.orientation, this.isShort = false, required this.icon, required this.iconTooltip, required this.onIconPressed]
[{Key? key}, {required String helpText}, {required String titleText}, {String? titleSemanticsLabel}, {required TextStyle? titleStyle}, {required Orientation orientation}, {bool isShort = false}, {required IconData icon}, {required String iconTooltip}, {required void Function() onIconPressed}]
For class -> _DateRangePickerDialog
[Key? key, this.initialDateRange, required this.firstDate, required this.lastDate, this.currentDate, this.initialEntryMode = DatePickerEntryMode.calendar, this.helpText, this.cancelText, this.confirmText, this.saveText, this.errorInvalidRangeText, this.errorFormatText, this.errorInvalidText, this.fieldStartHintText, this.fieldEndHintText, this.fieldStartLabelText, this.fieldEndLabelText]
[{Key? key}, {DateTimeRange? initialDateRange}, {required DateTime firstDate}, {required DateTime lastDate}, {DateTime? currentDate}, {DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar}, {String? helpText}, {String? cancelText}, {String? confirmText}, {String? saveText}, {String? errorInvalidRangeText}, {String? errorFormatText}, {String? errorInvalidText}, {String? fieldStartHintText}, {String? fieldEndHintText}, {String? fieldStartLabelText}, {String? fieldEndLabelText}]
For class -> _DateRangePickerDialogState
For class -> _CalendarRangePickerDialog
[Key? key, required this.selectedStartDate, required this.selectedEndDate, required this.firstDate, required this.lastDate, required this.currentDate, required this.onStartDateChanged, required this.onEndDateChanged, required this.onConfirm, required this.onCancel, required this.onToggleEntryMode, required this.confirmText, required this.helpText]
[{Key? key}, {required DateTime? selectedStartDate}, {required DateTime? selectedEndDate}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime? currentDate}, {required void Function(DateTime) onStartDateChanged}, {required void Function(DateTime?) onEndDateChanged}, {required void Function()? onConfirm}, {required void Function()? onCancel}, {required void Function()? onToggleEntryMode}, {required String confirmText}, {required String helpText}]
For class -> _CalendarDateRangePicker
[Key? key, DateTime? initialStartDate, DateTime? initialEndDate, required DateTime firstDate, required DateTime lastDate, DateTime? currentDate, required this.onStartDateChanged, required this.onEndDateChanged]
[{Key? key}, {DateTime? initialStartDate}, {DateTime? initialEndDate}, {required DateTime firstDate}, {required DateTime lastDate}, {DateTime? currentDate}, {required void Function(DateTime)? onStartDateChanged}, {required void Function(DateTime?)? onEndDateChanged}]
For class -> _CalendarDateRangePickerState
For class -> _CalendarKeyboardNavigator
[Key? key, required this.child, required this.firstDate, required this.lastDate, required this.initialFocusedDay]
[{Key? key}, {required Widget child}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime initialFocusedDay}]
For class -> _CalendarKeyboardNavigatorState
For class -> _FocusedDate
[Key? key, required Widget child, this.date, this.scrollDirection]
[{Key? key}, {required Widget child}, {DateTime? date}, {TraversalDirection? scrollDirection}]
For class -> _DayHeaders
For class -> _MonthItemGridDelegate
[]
[]
For class -> _MonthSliverGridLayout
[required this.crossAxisCount, required this.dayChildWidth, required this.edgeChildWidth, required this.reverseCrossAxis]
[{required int crossAxisCount}, {required double dayChildWidth}, {required double edgeChildWidth}, {required bool reverseCrossAxis}]
For class -> _MonthItem
[Key? key, required this.selectedDateStart, required this.selectedDateEnd, required this.currentDate, required this.onChanged, required this.firstDate, required this.lastDate, required this.displayedMonth, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required DateTime? selectedDateStart}, {required DateTime? selectedDateEnd}, {required DateTime currentDate}, {required void Function(DateTime) onChanged}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime displayedMonth}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _MonthItemState
For class -> _HighlightPainter
[required this.color, this.style = _HighlightPainterStyle.none, this.textDirection]
[{required Color color}, {_HighlightPainterStyle style = _HighlightPainterStyle.none}, {TextDirection? textDirection}]
For class -> _InputDateRangePickerDialog
[Key? key, required this.selectedStartDate, required this.selectedEndDate, required this.currentDate, required this.picker, required this.onConfirm, required this.onCancel, required this.onToggleEntryMode, required this.confirmText, required this.cancelText, required this.helpText]
[{Key? key}, {required DateTime? selectedStartDate}, {required DateTime? selectedEndDate}, {required DateTime? currentDate}, {required Widget picker}, {required void Function() onConfirm}, {required void Function() onCancel}, {required void Function() onToggleEntryMode}, {required String? confirmText}, {required String? cancelText}, {required String? helpText}]
For class -> _InputDateRangePicker
[Key? key, DateTime? initialStartDate, DateTime? initialEndDate, required DateTime firstDate, required DateTime lastDate, required this.onStartDateChanged, required this.onEndDateChanged, this.helpText, this.errorFormatText, this.errorInvalidText, this.errorInvalidRangeText, this.fieldStartHintText, this.fieldEndHintText, this.fieldStartLabelText, this.fieldEndLabelText, this.autofocus = false, this.autovalidate = false]
[{Key? key}, {DateTime? initialStartDate}, {DateTime? initialEndDate}, {required DateTime firstDate}, {required DateTime lastDate}, {required void Function(DateTime?)? onStartDateChanged}, {required void Function(DateTime?)? onEndDateChanged}, {String? helpText}, {String? errorFormatText}, {String? errorInvalidText}, {String? errorInvalidRangeText}, {String? fieldStartHintText}, {String? fieldEndHintText}, {String? fieldStartLabelText}, {String? fieldEndLabelText}, {bool autofocus = false}, {bool autovalidate = false}]
For class -> _InputDateRangePickerState
For class -> _DayPickerGridDelegate
[]
[]
For class -> DayPicker
[Key? key, required this.selectedDate, required this.currentDate, required this.onChanged, required this.firstDate, required this.lastDate, required this.displayedMonth, this.selectableDayPredicate, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required DateTime selectedDate}, {required DateTime currentDate}, {required void Function(DateTime) onChanged}, {required DateTime firstDate}, {required DateTime lastDate}, {required DateTime displayedMonth}, {bool Function(DateTime)? selectableDayPredicate}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> MonthPicker
[Key? key, required this.selectedDate, required this.onChanged, required this.firstDate, required this.lastDate, this.selectableDayPredicate, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required DateTime selectedDate}, {required void Function(DateTime) onChanged}, {required DateTime firstDate}, {required DateTime lastDate}, {bool Function(DateTime)? selectableDayPredicate}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _MonthPickerState
For class -> _MonthPickerSortKey
[double order]
[double order]
For class -> _DesktopTextSelectionControls
For class -> _DesktopTextSelectionControlsToolbar
[Key? key, required this.clipboardStatus, required this.endpoints, required this.globalEditableRegion, required this.handleCopy, required this.handleCut, required this.handlePaste, required this.handleSelectAll, required this.selectionMidpoint, required this.textLineHeight, required this.lastSecondaryTapDownPosition]
[{Key? key}, {required ClipboardStatusNotifier? clipboardStatus}, {required List<TextSelectionPoint> endpoints}, {required Rect globalEditableRegion}, {required void Function()? handleCopy}, {required void Function()? handleCut}, {required void Function()? handlePaste}, {required void Function()? handleSelectAll}, {required Offset selectionMidpoint}, {required double textLineHeight}, {required Offset? lastSecondaryTapDownPosition}]
For class -> _DesktopTextSelectionControlsToolbarState
For class -> _DesktopTextSelectionToolbar
[Key? key, required this.anchor, required this.children, this.toolbarBuilder = _defaultToolbarBuilder]
[{Key? key}, {required Offset anchor}, {required List<Widget> children}, {Widget Function(BuildContext, Widget) toolbarBuilder = _defaultToolbarBuilder}]
For class -> _DesktopTextSelectionToolbarButton
[Key? key, required this.onPressed, required this.child]
[{Key? key}, {required void Function() onPressed}, {required Widget child}]
[Key? key, required BuildContext context, required this.onPressed, required String text]
[{Key? key}, {required BuildContext context}, {required void Function() onPressed}, {required String text}]
For class -> Dialog
[Key? key, this.backgroundColor, this.elevation, this.insetAnimationDuration = const Duration(milliseconds: 100), this.insetAnimationCurve = Curves.decelerate, this.insetPadding = _defaultInsetPadding, this.clipBehavior = Clip.none, this.shape, this.child]
[{Key? key}, {Color? backgroundColor}, {double? elevation}, {Duration insetAnimationDuration = const Duration(milliseconds: 100)}, {Curve insetAnimationCurve = Curves.decelerate}, {EdgeInsets? insetPadding = _defaultInsetPadding}, {Clip clipBehavior = Clip.none}, {ShapeBorder? shape}, {Widget? child}]
For class -> AlertDialog
[Key? key, this.title, this.titlePadding, this.titleTextStyle, this.content, this.contentPadding = const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 24.0), this.contentTextStyle, this.actions, this.actionsPadding = EdgeInsets.zero, this.actionsOverflowDirection, this.actionsOverflowButtonSpacing, this.buttonPadding, this.backgroundColor, this.elevation, this.semanticLabel, this.insetPadding = _defaultInsetPadding, this.clipBehavior = Clip.none, this.shape, this.scrollable = false]
[{Key? key}, {Widget? title}, {EdgeInsetsGeometry? titlePadding}, {TextStyle? titleTextStyle}, {Widget? content}, {EdgeInsetsGeometry contentPadding = const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 24.0)}, {TextStyle? contentTextStyle}, {List<Widget>? actions}, {EdgeInsetsGeometry actionsPadding = EdgeInsets.zero}, {VerticalDirection? actionsOverflowDirection}, {double? actionsOverflowButtonSpacing}, {EdgeInsetsGeometry? buttonPadding}, {Color? backgroundColor}, {double? elevation}, {String? semanticLabel}, {EdgeInsets insetPadding = _defaultInsetPadding}, {Clip clipBehavior = Clip.none}, {ShapeBorder? shape}, {bool scrollable = false}]
For class -> SimpleDialogOption
[Key? key, this.onPressed, this.padding, this.child]
[{Key? key}, {void Function()? onPressed}, {EdgeInsets? padding}, {Widget? child}]
For class -> SimpleDialog
[Key? key, this.title, this.titlePadding = const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0), this.titleTextStyle, this.children, this.contentPadding = const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0), this.backgroundColor, this.elevation, this.semanticLabel, this.insetPadding = _defaultInsetPadding, this.clipBehavior = Clip.none, this.shape]
[{Key? key}, {Widget? title}, {EdgeInsetsGeometry titlePadding = const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0)}, {TextStyle? titleTextStyle}, {List<Widget>? children}, {EdgeInsetsGeometry contentPadding = const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0)}, {Color? backgroundColor}, {double? elevation}, {String? semanticLabel}, {EdgeInsets insetPadding = _defaultInsetPadding}, {Clip clipBehavior = Clip.none}, {ShapeBorder? shape}]
For class -> DialogRoute
[required BuildContext context, required WidgetBuilder builder, CapturedThemes? themes, Color? barrierColor = Colors.black54, bool barrierDismissible = true, String? barrierLabel, bool useSafeArea = true, RouteSettings? settings]
[{required BuildContext context}, {required Widget Function(BuildContext) builder}, {CapturedThemes? themes}, {Color? barrierColor = Colors.black54}, {bool barrierDismissible = true}, {String? barrierLabel}, {bool useSafeArea = true}, {RouteSettings? settings}]
For class -> DialogTheme
[this.backgroundColor, this.elevation, this.shape, this.titleTextStyle, this.contentTextStyle]
[{Color? backgroundColor}, {double? elevation}, {ShapeBorder? shape}, {TextStyle? titleTextStyle}, {TextStyle? contentTextStyle}]
For class -> Divider
[Key? key, this.height, this.thickness, this.indent, this.endIndent, this.color]
[{Key? key}, {double? height}, {double? thickness}, {double? indent}, {double? endIndent}, {Color? color}]
For class -> VerticalDivider
[Key? key, this.width, this.thickness, this.indent, this.endIndent, this.color]
[{Key? key}, {double? width}, {double? thickness}, {double? indent}, {double? endIndent}, {Color? color}]
For class -> DividerThemeData
[this.color, this.space, this.thickness, this.indent, this.endIndent]
[{Color? color}, {double? space}, {double? thickness}, {double? indent}, {double? endIndent}]
For class -> DividerTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required DividerThemeData data}, {required Widget child}]
For class -> Drawer
[Key? key, this.elevation = 16.0, this.child, this.semanticLabel]
[{Key? key}, {double elevation = 16.0}, {Widget? child}, {String? semanticLabel}]
For class -> DrawerController
[GlobalKey? key, required this.child, required this.alignment, this.isDrawerOpen = false, this.drawerCallback, this.dragStartBehavior = DragStartBehavior.start, this.scrimColor, this.edgeDragWidth, this.enableOpenDragGesture = true]
[{GlobalKey<State<StatefulWidget>>? key}, {required Widget child}, {required DrawerAlignment alignment}, {bool isDrawerOpen = false}, {void Function(bool)? drawerCallback}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {Color? scrimColor}, {double? edgeDragWidth}, {bool enableOpenDragGesture = true}]
For class -> DrawerControllerState
For class -> DrawerHeader
[Key? key, this.decoration, this.margin = const EdgeInsets.only(bottom: 8.0), this.padding = const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0), this.duration = const Duration(milliseconds: 250), this.curve = Curves.fastOutSlowIn, required this.child]
[{Key? key}, {Decoration? decoration}, {EdgeInsetsGeometry? margin = const EdgeInsets.only(bottom: 8.0)}, {EdgeInsetsGeometry padding = const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0)}, {Duration duration = const Duration(milliseconds: 250)}, {Curve curve = Curves.fastOutSlowIn}, {required Widget? child}]
For class -> _DropdownMenuPainter
[this.color, this.elevation, this.selectedIndex, required this.resize, required this.getSelectedItemOffset]
[{Color? color}, {int? elevation}, {int? selectedIndex}, {required Animation<double> resize}, {required double Function() getSelectedItemOffset}]
For class -> _DropdownScrollBehavior
[]
[]
For class -> _DropdownMenuItemButton
[Key? key, this.padding, required this.route, required this.buttonRect, required this.constraints, required this.itemIndex]
[{Key? key}, {EdgeInsets? padding}, {required _DropdownRoute<T> route}, {required Rect buttonRect}, {required BoxConstraints constraints}, {required int itemIndex}]
For class -> _DropdownMenuItemButtonState
For class -> _DropdownMenu
[Key? key, this.padding, required this.route, required this.buttonRect, required this.constraints, this.dropdownColor]
[{Key? key}, {EdgeInsets? padding}, {required _DropdownRoute<T> route}, {required Rect buttonRect}, {required BoxConstraints constraints}, {Color? dropdownColor}]
For class -> _DropdownMenuState
For class -> _DropdownMenuRouteLayout
[required this.buttonRect, required this.route, required this.textDirection]
[{required Rect buttonRect}, {required _DropdownRoute<T> route}, {required TextDirection? textDirection}]
For class -> _DropdownRouteResult
[this.result]
[T? result]
For class -> _MenuLimits
[this.top, this.bottom, this.height, this.scrollOffset]
[double top, double bottom, double height, double scrollOffset]
For class -> _DropdownRoute
[required this.items, required this.padding, required this.buttonRect, required this.selectedIndex, this.elevation = 8, required this.capturedThemes, required this.style, this.barrierLabel, this.itemHeight, this.dropdownColor]
[{required List<_MenuItem<T>> items}, {required EdgeInsetsGeometry padding}, {required Rect buttonRect}, {required int selectedIndex}, {int elevation = 8}, {required CapturedThemes capturedThemes}, {required TextStyle style}, {String? barrierLabel}, {double? itemHeight}, {Color? dropdownColor}]
For class -> _DropdownRoutePage
[Key? key, required this.route, required this.constraints, this.items, required this.padding, required this.buttonRect, required this.selectedIndex, this.elevation = 8, required this.capturedThemes, this.style, required this.dropdownColor]
[{Key? key}, {required _DropdownRoute<T> route}, {required BoxConstraints constraints}, {List<_MenuItem<T>>? items}, {required EdgeInsetsGeometry padding}, {required Rect buttonRect}, {required int selectedIndex}, {int elevation = 8}, {required CapturedThemes capturedThemes}, {TextStyle? style}, {required Color? dropdownColor}]
For class -> _MenuItem
[Key? key, required this.onLayout, required this.item]
[{Key? key}, {required void Function(Size) onLayout}, {required DropdownMenuItem<T>? item}]
For class -> _RenderMenuItem
[this.onLayout, RenderBox? child]
[void Function(Size) onLayout, [RenderBox? child]]
For class -> _DropdownMenuItemContainer
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> DropdownMenuItem
[Key? key, this.onTap, this.value, required Widget child]
[{Key? key}, {void Function()? onTap}, {T? value}, {required Widget child}]
For class -> DropdownButtonHideUnderline
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> DropdownButton
[Key? key, required this.items, this.selectedItemBuilder, this.value, this.hint, this.disabledHint, this.onChanged, this.onTap, this.elevation = 8, this.style, this.underline, this.icon, this.iconDisabledColor, this.iconEnabledColor, this.iconSize = 24.0, this.isDense = false, this.isExpanded = false, this.itemHeight = kMinInteractiveDimension, this.focusColor, this.focusNode, this.autofocus = false, this.dropdownColor]
[{Key? key}, {required List<DropdownMenuItem<T>>? items}, {List<Widget> Function(BuildContext)? selectedItemBuilder}, {T? value}, {Widget? hint}, {Widget? disabledHint}, {void Function(T?)? onChanged}, {void Function()? onTap}, {int elevation = 8}, {TextStyle? style}, {Widget? underline}, {Widget? icon}, {Color? iconDisabledColor}, {Color? iconEnabledColor}, {double iconSize = 24.0}, {bool isDense = false}, {bool isExpanded = false}, {double? itemHeight = kMinInteractiveDimension}, {Color? focusColor}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? dropdownColor}]
For class -> _DropdownButtonState
For class -> DropdownButtonFormField
[Key? key, required List<DropdownMenuItem<T>>? items, DropdownButtonBuilder? selectedItemBuilder, T? value, Widget? hint, Widget? disabledHint, this.onChanged, VoidCallback? onTap, int elevation = 8, TextStyle? style, Widget? icon, Color? iconDisabledColor, Color? iconEnabledColor, double iconSize = 24.0, bool isDense = true, bool isExpanded = false, double? itemHeight, Color? focusColor, FocusNode? focusNode, bool autofocus = false, Color? dropdownColor, InputDecoration? decoration, FormFieldSetter<T>? onSaved, FormFieldValidator<T>? validator, @Deprecated('Use autovalidateMode parameter which provide more specific ' 'behaviour related to auto validation. ' 'This feature was deprecated after v1.19.0.') bool autovalidate = false, AutovalidateMode? autovalidateMode]
[{Key? key}, {required List<DropdownMenuItem<T>>? items}, {List<Widget> Function(BuildContext)? selectedItemBuilder}, {T? value}, {Widget? hint}, {Widget? disabledHint}, {void Function(T?)? onChanged}, {void Function()? onTap}, {int elevation = 8}, {TextStyle? style}, {Widget? icon}, {Color? iconDisabledColor}, {Color? iconEnabledColor}, {double iconSize = 24.0}, {bool isDense = true}, {bool isExpanded = false}, {double? itemHeight}, {Color? focusColor}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? dropdownColor}, {InputDecoration? decoration}, {void Function(T?)? onSaved}, {String? Function(T?)? validator}, {bool autovalidate = false}, {AutovalidateMode? autovalidateMode}]
For class -> _DropdownButtonFormFieldState
For class -> ElevatedButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip clipBehavior = Clip.none, required Widget? child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool autofocus = false}, {Clip clipBehavior = Clip.none}, {required Widget? child}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _ElevatedButtonDefaultBackground
[this.primary, this.onSurface]
[Color? primary, Color? onSurface]
For class -> _ElevatedButtonDefaultForeground
[this.onPrimary, this.onSurface]
[Color? onPrimary, Color? onSurface]
For class -> _ElevatedButtonDefaultOverlay
[this.onPrimary]
[Color onPrimary]
For class -> _ElevatedButtonDefaultElevation
[this.elevation]
[double elevation]
For class -> _ElevatedButtonDefaultMouseCursor
[this.enabledCursor, this.disabledCursor]
[MouseCursor? enabledCursor, MouseCursor? disabledCursor]
For class -> _ElevatedButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _ElevatedButtonWithIconChild
[Key? key, required this.label, required this.icon]
[{Key? key}, {required Widget label}, {required Widget icon}]
For class -> ElevatedButtonThemeData
[this.style]
[{ButtonStyle? style}]
For class -> ElevatedButtonTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ElevatedButtonThemeData data}, {required Widget child}]
For class -> ElevationOverlay
[]
[]
For class -> ExpandIcon
[Key? key, this.isExpanded = false, this.size = 24.0, required this.onPressed, this.padding = const EdgeInsets.all(8.0), this.color, this.disabledColor, this.expandedColor]
[{Key? key}, {bool isExpanded = false}, {double size = 24.0}, {required void Function(bool)? onPressed}, {EdgeInsetsGeometry padding = const EdgeInsets.all(8.0)}, {Color? color}, {Color? disabledColor}, {Color? expandedColor}]
For class -> _ExpandIconState
For class -> _SaltedKey
[this.salt, this.value]
[S salt, V value]
For class -> ExpansionPanel
[required this.headerBuilder, required this.body, this.isExpanded = false, this.canTapOnHeader = false, this.backgroundColor]
[{required Widget Function(BuildContext, bool) headerBuilder}, {required Widget body}, {bool isExpanded = false}, {bool canTapOnHeader = false}, {Color? backgroundColor}]
For class -> ExpansionPanelRadio
[required this.value, required ExpansionPanelHeaderBuilder headerBuilder, required Widget body, bool canTapOnHeader = false, Color? backgroundColor]
[{required Object value}, {required Widget Function(BuildContext, bool) headerBuilder}, {required Widget body}, {bool canTapOnHeader = false}, {Color? backgroundColor}]
For class -> ExpansionPanelList
[Key? key, this.children = const <ExpansionPanel>[], this.expansionCallback, this.animationDuration = kThemeAnimationDuration, this.expandedHeaderPadding = _kPanelHeaderExpandedDefaultPadding, this.dividerColor, this.elevation = 2]
[{Key? key}, {List<ExpansionPanel> children = const <ExpansionPanel>[]}, {void Function(int, bool)? expansionCallback}, {Duration animationDuration = kThemeAnimationDuration}, {EdgeInsets expandedHeaderPadding = _kPanelHeaderExpandedDefaultPadding}, {Color? dividerColor}, {int elevation = 2}]
[Key? key, this.children = const <ExpansionPanelRadio>[], this.expansionCallback, this.animationDuration = kThemeAnimationDuration, this.initialOpenPanelValue, this.expandedHeaderPadding = _kPanelHeaderExpandedDefaultPadding, this.dividerColor, this.elevation = 2]
[{Key? key}, {List<ExpansionPanel> children = const <ExpansionPanelRadio>[]}, {void Function(int, bool)? expansionCallback}, {Duration animationDuration = kThemeAnimationDuration}, {Object? initialOpenPanelValue}, {EdgeInsets expandedHeaderPadding = _kPanelHeaderExpandedDefaultPadding}, {Color? dividerColor}, {int elevation = 2}]
For class -> _ExpansionPanelListState
For class -> ExpansionTile
[Key? key, this.leading, required this.title, this.subtitle, this.backgroundColor, this.onExpansionChanged, this.children = const <Widget>[], this.trailing, this.initiallyExpanded = false, this.maintainState = false, this.tilePadding, this.expandedCrossAxisAlignment, this.expandedAlignment, this.childrenPadding, this.collapsedBackgroundColor]
[{Key? key}, {Widget? leading}, {required Widget title}, {Widget? subtitle}, {Color? backgroundColor}, {void Function(bool)? onExpansionChanged}, {List<Widget> children = const <Widget>[]}, {Widget? trailing}, {bool initiallyExpanded = false}, {bool maintainState = false}, {EdgeInsetsGeometry? tilePadding}, {CrossAxisAlignment? expandedCrossAxisAlignment}, {Alignment? expandedAlignment}, {EdgeInsetsGeometry? childrenPadding}, {Color? collapsedBackgroundColor}]
For class -> _ExpansionTileState
For class -> Feedback
[]
[]
For class -> FlatButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, required Widget child, double? height, double? minWidth]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget child}, {double? height}, {double? minWidth}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, EdgeInsetsGeometry? padding, ShapeBorder? shape, Clip clipBehavior, FocusNode? focusNode, bool autofocus, MaterialTapTargetSize? materialTapTargetSize, required Widget icon, required Widget label, double? minWidth, double? height]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {EdgeInsetsGeometry? padding}, {ShapeBorder? shape}, {Clip clipBehavior}, {FocusNode? focusNode}, {bool autofocus}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget icon}, {required Widget label}, {double? minWidth}, {double? height}]
For class -> _FlatButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, EdgeInsetsGeometry? padding, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, required Widget icon, required Widget label, double? minWidth, double? height]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {EdgeInsetsGeometry? padding}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget icon}, {required Widget label}, {double? minWidth}, {double? height}]
For class -> FlexibleSpaceBar
[Key? key, this.title, this.background, this.centerTitle, this.titlePadding, this.collapseMode = CollapseMode.parallax, this.stretchModes = const <StretchMode>[StretchMode.zoomBackground]]
[{Key? key}, {Widget? title}, {Widget? background}, {bool? centerTitle}, {EdgeInsetsGeometry? titlePadding}, {CollapseMode collapseMode = CollapseMode.parallax}, {List<StretchMode> stretchModes = const <StretchMode>[StretchMode.zoomBackground]}]
For class -> _FlexibleSpaceBarState
For class -> FlexibleSpaceBarSettings
[Key? key, required this.toolbarOpacity, required this.minExtent, required this.maxExtent, required this.currentExtent, required Widget child]
[{Key? key}, {required double toolbarOpacity}, {required double minExtent}, {required double maxExtent}, {required double currentExtent}, {required Widget child}]
For class -> _DefaultHeroTag
[]
[]
For class -> FloatingActionButton
[Key? key, this.child, this.tooltip, this.foregroundColor, this.backgroundColor, this.focusColor, this.hoverColor, this.splashColor, this.heroTag = const _DefaultHeroTag(), this.elevation, this.focusElevation, this.hoverElevation, this.highlightElevation, this.disabledElevation, required this.onPressed, this.mouseCursor, this.mini = false, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.materialTapTargetSize, this.isExtended = false]
[{Key? key}, {Widget? child}, {String? tooltip}, {Color? foregroundColor}, {Color? backgroundColor}, {Color? focusColor}, {Color? hoverColor}, {Color? splashColor}, {Object? heroTag = const _DefaultHeroTag()}, {double? elevation}, {double? focusElevation}, {double? hoverElevation}, {double? highlightElevation}, {double? disabledElevation}, {required void Function()? onPressed}, {MouseCursor? mouseCursor}, {bool mini = false}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {bool isExtended = false}]
[Key? key, this.tooltip, this.foregroundColor, this.backgroundColor, this.focusColor, this.hoverColor, this.heroTag = const _DefaultHeroTag(), this.elevation, this.focusElevation, this.hoverElevation, this.splashColor, this.highlightElevation, this.disabledElevation, required this.onPressed, this.mouseCursor = SystemMouseCursors.click, this.shape, this.isExtended = true, this.materialTapTargetSize, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, Widget? icon, required Widget label]
[{Key? key}, {String? tooltip}, {Color? foregroundColor}, {Color? backgroundColor}, {Color? focusColor}, {Color? hoverColor}, {Object? heroTag = const _DefaultHeroTag()}, {double? elevation}, {double? focusElevation}, {double? hoverElevation}, {Color? splashColor}, {double? highlightElevation}, {double? disabledElevation}, {required void Function()? onPressed}, {MouseCursor? mouseCursor = SystemMouseCursors.click}, {ShapeBorder? shape}, {bool isExtended = true}, {MaterialTapTargetSize? materialTapTargetSize}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Widget? icon}, {required Widget label}]
For class -> _ChildOverflowBox
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> _RenderChildOverflowBox
[RenderBox? child, TextDirection? textDirection]
[{RenderBox? child}, {TextDirection? textDirection}]
For class -> FloatingActionButtonLocation
[]
[]
For class -> StandardFabLocation
[]
[]
For class -> _StartTopFabLocation
[]
[]
For class -> _MiniStartTopFabLocation
[]
[]
For class -> _CenterTopFabLocation
[]
[]
For class -> _MiniCenterTopFabLocation
[]
[]
For class -> _EndTopFabLocation
[]
[]
For class -> _MiniEndTopFabLocation
[]
[]
For class -> _StartFloatFabLocation
[]
[]
For class -> _MiniStartFloatFabLocation
[]
[]
For class -> _CenterFloatFabLocation
[]
[]
For class -> _MiniCenterFloatFabLocation
[]
[]
For class -> _EndFloatFabLocation
[]
[]
For class -> _MiniEndFloatFabLocation
[]
[]
For class -> _StartDockedFabLocation
[]
[]
For class -> _MiniStartDockedFabLocation
[]
[]
For class -> _CenterDockedFabLocation
[]
[]
For class -> _MiniCenterDockedFabLocation
[]
[]
For class -> _EndDockedFabLocation
[]
[]
For class -> _MiniEndDockedFabLocation
[]
[]
For class -> FloatingActionButtonAnimator
[]
[]
For class -> _ScalingFabMotionAnimator
[]
[]
For class -> _AnimationSwap
[Animation<T> first, Animation<T> next, this.parent, this.swapThreshold]
[Animation<T> first, Animation<T> next, Animation<double> parent, double swapThreshold]
For class -> FloatingActionButtonThemeData
[this.foregroundColor, this.backgroundColor, this.focusColor, this.hoverColor, this.splashColor, this.elevation, this.focusElevation, this.hoverElevation, this.disabledElevation, this.highlightElevation, this.shape]
[{Color? foregroundColor}, {Color? backgroundColor}, {Color? focusColor}, {Color? hoverColor}, {Color? splashColor}, {double? elevation}, {double? focusElevation}, {double? hoverElevation}, {double? disabledElevation}, {double? highlightElevation}, {ShapeBorder? shape}]
For class -> FlutterLogo
[Key? key, this.size, this.textColor = const Color(0xFF757575), this.style = FlutterLogoStyle.markOnly, this.duration = const Duration(milliseconds: 750), this.curve = Curves.fastOutSlowIn]
[{Key? key}, {double? size}, {Color textColor = const Color(0xFF757575)}, {FlutterLogoStyle style = FlutterLogoStyle.markOnly}, {Duration duration = const Duration(milliseconds: 750)}, {Curve curve = Curves.fastOutSlowIn}]
For class -> GridTile
[Key? key, this.header, this.footer, required this.child]
[{Key? key}, {Widget? header}, {Widget? footer}, {required Widget child}]
For class -> GridTileBar
[Key? key, this.backgroundColor, this.leading, this.title, this.subtitle, this.trailing]
[{Key? key}, {Color? backgroundColor}, {Widget? leading}, {Widget? title}, {Widget? subtitle}, {Widget? trailing}]
For class -> _PlatformAdaptiveIcons
For class -> Icons
[]
[]
For class -> IconButton
[Key? key, this.iconSize = 24.0, this.visualDensity, this.padding = const EdgeInsets.all(8.0), this.alignment = Alignment.center, this.splashRadius, required this.icon, this.color, this.focusColor, this.hoverColor, this.highlightColor, this.splashColor, this.disabledColor, required this.onPressed, this.mouseCursor = SystemMouseCursors.click, this.focusNode, this.autofocus = false, this.tooltip, this.enableFeedback = true, this.constraints]
[{Key? key}, {double iconSize = 24.0}, {VisualDensity? visualDensity}, {EdgeInsetsGeometry padding = const EdgeInsets.all(8.0)}, {AlignmentGeometry alignment = Alignment.center}, {double? splashRadius}, {required Widget icon}, {Color? color}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Color? disabledColor}, {required void Function()? onPressed}, {MouseCursor mouseCursor = SystemMouseCursors.click}, {FocusNode? focusNode}, {bool autofocus = false}, {String? tooltip}, {bool enableFeedback = true}, {BoxConstraints? constraints}]
For class -> Ink
[Key? key, this.padding, Color? color, Decoration? decoration, this.width, this.height, this.child]
[{Key? key}, {EdgeInsetsGeometry? padding}, {Color? color}, {Decoration? decoration}, {double? width}, {double? height}, {Widget? child}]
[Key? key, this.padding, required ImageProvider image, ImageErrorListener? onImageError, ColorFilter? colorFilter, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, Rect? centerSlice, ImageRepeat repeat = ImageRepeat.noRepeat, bool matchTextDirection = false, this.width, this.height, this.child]
[{Key? key}, {EdgeInsetsGeometry? padding}, {required ImageProvider<Object> image}, {void Function(Object, StackTrace?)? onImageError}, {ColorFilter? colorFilter}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {Rect? centerSlice}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {bool matchTextDirection = false}, {double? width}, {double? height}, {Widget? child}]
For class -> _InkState
For class -> InkDecoration
[required Decoration? decoration, required ImageConfiguration configuration, required MaterialInkController controller, required RenderBox referenceBox, VoidCallback? onRemoved]
[{required Decoration? decoration}, {required ImageConfiguration configuration}, {required MaterialInkController controller}, {required RenderBox referenceBox}, {void Function()? onRemoved}]
For class -> InkHighlight
[required MaterialInkController controller, required RenderBox referenceBox, required Color color, required TextDirection textDirection, BoxShape shape = BoxShape.rectangle, double? radius, BorderRadius? borderRadius, ShapeBorder? customBorder, RectCallback? rectCallback, VoidCallback? onRemoved, Duration fadeDuration = _kDefaultHighlightFadeDuration]
[{required MaterialInkController controller}, {required RenderBox referenceBox}, {required Color color}, {required TextDirection textDirection}, {BoxShape shape = BoxShape.rectangle}, {double? radius}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {Rect Function()? rectCallback}, {void Function()? onRemoved}, {Duration fadeDuration = _kDefaultHighlightFadeDuration}]
For class -> _InkRippleFactory
[]
[]
For class -> InkRipple
[required MaterialInkController controller, required RenderBox referenceBox, required Offset position, required Color color, required TextDirection textDirection, bool containedInkWell = false, RectCallback? rectCallback, BorderRadius? borderRadius, ShapeBorder? customBorder, double? radius, VoidCallback? onRemoved]
[{required MaterialInkController controller}, {required RenderBox referenceBox}, {required Offset position}, {required Color color}, {required TextDirection textDirection}, {bool containedInkWell = false}, {Rect Function()? rectCallback}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {double? radius}, {void Function()? onRemoved}]
For class -> _InkSplashFactory
[]
[]
For class -> InkSplash
[required MaterialInkController controller, required RenderBox referenceBox, required TextDirection textDirection, Offset? position, required Color color, bool containedInkWell = false, RectCallback? rectCallback, BorderRadius? borderRadius, ShapeBorder? customBorder, double? radius, VoidCallback? onRemoved]
[{required MaterialInkController controller}, {required RenderBox referenceBox}, {required TextDirection textDirection}, {Offset? position}, {required Color color}, {bool containedInkWell = false}, {Rect Function()? rectCallback}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {double? radius}, {void Function()? onRemoved}]
For class -> InteractiveInkFeature
[required MaterialInkController controller, required RenderBox referenceBox, required Color color, VoidCallback? onRemoved]
[{required MaterialInkController controller}, {required RenderBox referenceBox}, {required Color color}, {void Function()? onRemoved}]
For class -> InteractiveInkFeatureFactory
[]
[]
For class -> _ParentInkResponseState
For class -> _ParentInkResponseProvider
[required this.state, required Widget child]
[{required _ParentInkResponseState state}, {required Widget child}]
For class -> InkResponse
[Key? key, this.child, this.onTap, this.onTapDown, this.onTapCancel, this.onDoubleTap, this.onLongPress, this.onHighlightChanged, this.onHover, this.mouseCursor, this.containedInkWell = false, this.highlightShape = BoxShape.circle, this.radius, this.borderRadius, this.customBorder, this.focusColor, this.hoverColor, this.highlightColor, this.overlayColor, this.splashColor, this.splashFactory, this.enableFeedback = true, this.excludeFromSemantics = false, this.focusNode, this.canRequestFocus = true, this.onFocusChange, this.autofocus = false]
[{Key? key}, {Widget? child}, {void Function()? onTap}, {void Function(TapDownDetails)? onTapDown}, {void Function()? onTapCancel}, {void Function()? onDoubleTap}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {void Function(bool)? onHover}, {MouseCursor? mouseCursor}, {bool containedInkWell = false}, {BoxShape highlightShape = BoxShape.circle}, {double? radius}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {MaterialStateProperty<Color?>? overlayColor}, {Color? splashColor}, {InteractiveInkFeatureFactory? splashFactory}, {bool enableFeedback = true}, {bool excludeFromSemantics = false}, {FocusNode? focusNode}, {bool canRequestFocus = true}, {void Function(bool)? onFocusChange}, {bool autofocus = false}]
For class -> _InkResponseStateWidget
[this.child, this.onTap, this.onTapDown, this.onTapCancel, this.onDoubleTap, this.onLongPress, this.onHighlightChanged, this.onHover, this.mouseCursor, this.containedInkWell = false, this.highlightShape = BoxShape.circle, this.radius, this.borderRadius, this.customBorder, this.focusColor, this.hoverColor, this.highlightColor, this.overlayColor, this.splashColor, this.splashFactory, this.enableFeedback = true, this.excludeFromSemantics = false, this.focusNode, this.canRequestFocus = true, this.onFocusChange, this.autofocus = false, this.parentState, this.getRectCallback, required this.debugCheckContext]
[{Widget? child}, {void Function()? onTap}, {void Function(TapDownDetails)? onTapDown}, {void Function()? onTapCancel}, {void Function()? onDoubleTap}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {void Function(bool)? onHover}, {MouseCursor? mouseCursor}, {bool containedInkWell = false}, {BoxShape highlightShape = BoxShape.circle}, {double? radius}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {MaterialStateProperty<Color?>? overlayColor}, {Color? splashColor}, {InteractiveInkFeatureFactory? splashFactory}, {bool enableFeedback = true}, {bool excludeFromSemantics = false}, {FocusNode? focusNode}, {bool canRequestFocus = true}, {void Function(bool)? onFocusChange}, {bool autofocus = false}, {_ParentInkResponseState? parentState}, {Rect Function()? Function(RenderBox)? getRectCallback}, {required bool Function(BuildContext) debugCheckContext}]
For class -> _InkResponseState
For class -> InkWell
[Key? key, Widget? child, GestureTapCallback? onTap, GestureTapCallback? onDoubleTap, GestureLongPressCallback? onLongPress, GestureTapDownCallback? onTapDown, GestureTapCancelCallback? onTapCancel, ValueChanged<bool>? onHighlightChanged, ValueChanged<bool>? onHover, MouseCursor? mouseCursor, Color? focusColor, Color? hoverColor, Color? highlightColor, MaterialStateProperty<Color?>? overlayColor, Color? splashColor, InteractiveInkFeatureFactory? splashFactory, double? radius, BorderRadius? borderRadius, ShapeBorder? customBorder, bool? enableFeedback = true, bool excludeFromSemantics = false, FocusNode? focusNode, bool canRequestFocus = true, ValueChanged<bool>? onFocusChange, bool autofocus = false]
[{Key? key}, {Widget? child}, {void Function()? onTap}, {void Function()? onDoubleTap}, {void Function()? onLongPress}, {void Function(TapDownDetails)? onTapDown}, {void Function()? onTapCancel}, {void Function(bool)? onHighlightChanged}, {void Function(bool)? onHover}, {MouseCursor? mouseCursor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {MaterialStateProperty<Color?>? overlayColor}, {Color? splashColor}, {InteractiveInkFeatureFactory? splashFactory}, {double? radius}, {BorderRadius? borderRadius}, {ShapeBorder? customBorder}, {bool? enableFeedback = true}, {bool excludeFromSemantics = false}, {FocusNode? focusNode}, {bool canRequestFocus = true}, {void Function(bool)? onFocusChange}, {bool autofocus = false}]
For class -> InputBorder
[this.borderSide = BorderSide.none]
[{BorderSide borderSide = BorderSide.none}]
For class -> _NoInputBorder
[]
[]
For class -> UnderlineInputBorder
[BorderSide borderSide = const BorderSide(), this.borderRadius = const BorderRadius.only(topLeft: Radius.circular(4.0), topRight: Radius.circular(4.0))]
[{BorderSide borderSide = const BorderSide()}, {BorderRadius borderRadius = const BorderRadius.only(topLeft: Radius.circular(4.0), topRight: Radius.circular(4.0))}]
For class -> OutlineInputBorder
[BorderSide borderSide = const BorderSide(), this.borderRadius = const BorderRadius.all(Radius.circular(4.0)), this.gapPadding = 4.0]
[{BorderSide borderSide = const BorderSide()}, {BorderRadius borderRadius = const BorderRadius.all(Radius.circular(4.0))}, {double gapPadding = 4.0}]
For class -> InputDatePickerFormField
[Key? key, DateTime? initialDate, required DateTime firstDate, required DateTime lastDate, this.onDateSubmitted, this.onDateSaved, this.selectableDayPredicate, this.errorFormatText, this.errorInvalidText, this.fieldHintText, this.fieldLabelText, this.autofocus = false]
[{Key? key}, {DateTime? initialDate}, {required DateTime firstDate}, {required DateTime lastDate}, {void Function(DateTime)? onDateSubmitted}, {void Function(DateTime)? onDateSaved}, {bool Function(DateTime)? selectableDayPredicate}, {String? errorFormatText}, {String? errorInvalidText}, {String? fieldHintText}, {String? fieldLabelText}, {bool autofocus = false}]
For class -> _InputDatePickerFormFieldState
For class -> _InputBorderGap
For class -> _InputBorderTween
[InputBorder? begin, InputBorder? end]
[{InputBorder? begin}, {InputBorder? end}]
For class -> _InputBorderPainter
[required Listenable repaint, required this.borderAnimation, required this.border, required this.gapAnimation, required this.gap, required this.textDirection, required this.fillColor, required this.hoverAnimation, required this.hoverColorTween]
[{required Listenable repaint}, {required Animation<double> borderAnimation}, {required _InputBorderTween border}, {required Animation<double> gapAnimation}, {required _InputBorderGap gap}, {required TextDirection textDirection}, {required Color fillColor}, {required Animation<double> hoverAnimation}, {required ColorTween hoverColorTween}]
For class -> _BorderContainer
[Key? key, required this.border, required this.gap, required this.gapAnimation, required this.fillColor, required this.hoverColor, required this.isHovering, this.child]
[{Key? key}, {required InputBorder border}, {required _InputBorderGap gap}, {required Animation<double> gapAnimation}, {required Color fillColor}, {required Color hoverColor}, {required bool isHovering}, {Widget? child}]
For class -> _BorderContainerState
For class -> _Shaker
[Key? key, required Animation<double> animation, this.child]
[{Key? key}, {required Animation<double> animation}, {Widget? child}]
For class -> _HelperError
[Key? key, this.textAlign, this.helperText, this.helperStyle, this.helperMaxLines, this.errorText, this.errorStyle, this.errorMaxLines]
[{Key? key}, {TextAlign? textAlign}, {String? helperText}, {TextStyle? helperStyle}, {int? helperMaxLines}, {String? errorText}, {TextStyle? errorStyle}, {int? errorMaxLines}]
For class -> _HelperErrorState
For class -> _Decoration
[required this.contentPadding, required this.isCollapsed, required this.floatingLabelHeight, required this.floatingLabelProgress, this.border, this.borderGap, required this.alignLabelWithHint, required this.isDense, this.visualDensity, this.icon, this.input, this.label, this.hint, this.prefix, this.suffix, this.prefixIcon, this.suffixIcon, this.helperError, this.counter, this.container, this.fixTextFieldOutlineLabel = false]
[{required EdgeInsetsGeometry contentPadding}, {required bool isCollapsed}, {required double floatingLabelHeight}, {required double floatingLabelProgress}, {InputBorder? border}, {_InputBorderGap? borderGap}, {required bool alignLabelWithHint}, {required bool? isDense}, {VisualDensity? visualDensity}, {Widget? icon}, {Widget? input}, {Widget? label}, {Widget? hint}, {Widget? prefix}, {Widget? suffix}, {Widget? prefixIcon}, {Widget? suffixIcon}, {Widget? helperError}, {Widget? counter}, {Widget? container}, {bool fixTextFieldOutlineLabel = false}]
For class -> _RenderDecorationLayout
[required this.boxToBaseline, required this.inputBaseline, required this.outlineBaseline, required this.subtextBaseline, required this.containerHeight, required this.subtextHeight]
[{required Map<RenderBox?, double> boxToBaseline}, {required double inputBaseline}, {required double outlineBaseline}, {required double subtextBaseline}, {required double containerHeight}, {required double subtextHeight}]
For class -> _RenderDecoration
[required _Decoration decoration, required TextDirection textDirection, required TextBaseline textBaseline, required bool isFocused, required bool expands, TextAlignVertical? textAlignVertical]
[{required _Decoration decoration}, {required TextDirection textDirection}, {required TextBaseline textBaseline}, {required bool isFocused}, {required bool expands}, {TextAlignVertical? textAlignVertical}]
For class -> _DecorationElement
[_Decorator widget]
[_Decorator widget]
For class -> _Decorator
[Key? key, required this.textAlignVertical, required this.decoration, required this.textDirection, required this.textBaseline, required this.isFocused, required this.expands]
[{Key? key}, {required TextAlignVertical? textAlignVertical}, {required _Decoration decoration}, {required TextDirection textDirection}, {required TextBaseline textBaseline}, {required bool isFocused}, {required bool expands}]
For class -> _AffixText
[required this.labelIsFloating, this.text, this.style, this.child]
[{required bool labelIsFloating}, {String? text}, {TextStyle? style}, {Widget? child}]
For class -> InputDecorator
[Key? key, required this.decoration, this.baseStyle, this.textAlign, this.textAlignVertical, this.isFocused = false, this.isHovering = false, this.expands = false, this.isEmpty = false, this.child]
[{Key? key}, {required InputDecoration decoration}, {TextStyle? baseStyle}, {TextAlign? textAlign}, {TextAlignVertical? textAlignVertical}, {bool isFocused = false}, {bool isHovering = false}, {bool expands = false}, {bool isEmpty = false}, {Widget? child}]
For class -> _InputDecoratorState
For class -> InputDecoration
[this.icon, this.labelText, this.labelStyle, this.helperText, this.helperStyle, this.helperMaxLines, this.hintText, this.hintStyle, this.hintTextDirection, this.hintMaxLines, this.errorText, this.errorStyle, this.errorMaxLines, @Deprecated('Use floatingLabelBehavior instead. ' 'This feature was deprecated after v1.13.2.') this.hasFloatingPlaceholder = true, this.floatingLabelBehavior, this.isCollapsed = false, this.isDense, this.contentPadding, this.prefixIcon, this.prefixIconConstraints, this.prefix, this.prefixText, this.prefixStyle, this.suffixIcon, this.suffix, this.suffixText, this.suffixStyle, this.suffixIconConstraints, this.counter, this.counterText, this.counterStyle, this.filled, this.fillColor, this.focusColor, this.hoverColor, this.errorBorder, this.focusedBorder, this.focusedErrorBorder, this.disabledBorder, this.enabledBorder, this.border, this.enabled = true, this.semanticCounterText, this.alignLabelWithHint]
[{Widget? icon}, {String? labelText}, {TextStyle? labelStyle}, {String? helperText}, {TextStyle? helperStyle}, {int? helperMaxLines}, {String? hintText}, {TextStyle? hintStyle}, {TextDirection? hintTextDirection}, {int? hintMaxLines}, {String? errorText}, {TextStyle? errorStyle}, {int? errorMaxLines}, {bool hasFloatingPlaceholder = true}, {FloatingLabelBehavior? floatingLabelBehavior}, {bool isCollapsed = false}, {bool? isDense}, {EdgeInsetsGeometry? contentPadding}, {Widget? prefixIcon}, {BoxConstraints? prefixIconConstraints}, {Widget? prefix}, {String? prefixText}, {TextStyle? prefixStyle}, {Widget? suffixIcon}, {Widget? suffix}, {String? suffixText}, {TextStyle? suffixStyle}, {BoxConstraints? suffixIconConstraints}, {Widget? counter}, {String? counterText}, {TextStyle? counterStyle}, {bool? filled}, {Color? fillColor}, {Color? focusColor}, {Color? hoverColor}, {InputBorder? errorBorder}, {InputBorder? focusedBorder}, {InputBorder? focusedErrorBorder}, {InputBorder? disabledBorder}, {InputBorder? enabledBorder}, {InputBorder? border}, {bool enabled = true}, {String? semanticCounterText}, {bool? alignLabelWithHint}]
[required this.hintText, @Deprecated('Use floatingLabelBehavior instead. ' 'This feature was deprecated after v1.13.2.') this.hasFloatingPlaceholder = true, this.floatingLabelBehavior, this.hintStyle, this.hintTextDirection, this.filled = false, this.fillColor, this.focusColor, this.hoverColor, this.border = InputBorder.none, this.enabled = true]
[{required String? hintText}, {bool hasFloatingPlaceholder = true}, {FloatingLabelBehavior? floatingLabelBehavior}, {TextStyle? hintStyle}, {TextDirection? hintTextDirection}, {bool? filled = false}, {Color? fillColor}, {Color? focusColor}, {Color? hoverColor}, {InputBorder? border = InputBorder.none}, {bool enabled = true}]
For class -> InputDecorationTheme
[this.labelStyle, this.helperStyle, this.helperMaxLines, this.hintStyle, this.errorStyle, this.errorMaxLines, @Deprecated('Use floatingLabelBehavior instead. ' 'This feature was deprecated after v1.13.2.') this.hasFloatingPlaceholder = true, this.floatingLabelBehavior = FloatingLabelBehavior.auto, this.isDense = false, this.contentPadding, this.isCollapsed = false, this.prefixStyle, this.suffixStyle, this.counterStyle, this.filled = false, this.fillColor, this.focusColor, this.hoverColor, this.errorBorder, this.focusedBorder, this.focusedErrorBorder, this.disabledBorder, this.enabledBorder, this.border, this.alignLabelWithHint = false]
[{TextStyle? labelStyle}, {TextStyle? helperStyle}, {int? helperMaxLines}, {TextStyle? hintStyle}, {TextStyle? errorStyle}, {int? errorMaxLines}, {bool hasFloatingPlaceholder = true}, {FloatingLabelBehavior floatingLabelBehavior = FloatingLabelBehavior.auto}, {bool isDense = false}, {EdgeInsetsGeometry? contentPadding}, {bool isCollapsed = false}, {TextStyle? prefixStyle}, {TextStyle? suffixStyle}, {TextStyle? counterStyle}, {bool filled = false}, {Color? fillColor}, {Color? focusColor}, {Color? hoverColor}, {InputBorder? errorBorder}, {InputBorder? focusedBorder}, {InputBorder? focusedErrorBorder}, {InputBorder? disabledBorder}, {InputBorder? enabledBorder}, {InputBorder? border}, {bool alignLabelWithHint = false}]
For class -> ListTileTheme
[Key? key, this.dense = false, this.shape, this.style = ListTileStyle.list, this.selectedColor, this.iconColor, this.textColor, this.contentPadding, this.tileColor, this.selectedTileColor, this.enableFeedback, this.horizontalTitleGap, this.minVerticalPadding, this.minLeadingWidth, required Widget child]
[{Key? key}, {bool dense = false}, {ShapeBorder? shape}, {ListTileStyle style = ListTileStyle.list}, {Color? selectedColor}, {Color? iconColor}, {Color? textColor}, {EdgeInsetsGeometry? contentPadding}, {Color? tileColor}, {Color? selectedTileColor}, {bool? enableFeedback}, {double? horizontalTitleGap}, {double? minVerticalPadding}, {double? minLeadingWidth}, {required Widget child}]
For class -> ListTile
[Key? key, this.leading, this.title, this.subtitle, this.trailing, this.isThreeLine = false, this.dense, this.visualDensity, this.shape, this.contentPadding, this.enabled = true, this.onTap, this.onLongPress, this.mouseCursor, this.selected = false, this.focusColor, this.hoverColor, this.focusNode, this.autofocus = false, this.tileColor, this.selectedTileColor, this.enableFeedback, this.horizontalTitleGap, this.minVerticalPadding, this.minLeadingWidth]
[{Key? key}, {Widget? leading}, {Widget? title}, {Widget? subtitle}, {Widget? trailing}, {bool isThreeLine = false}, {bool? dense}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {EdgeInsetsGeometry? contentPadding}, {bool enabled = true}, {void Function()? onTap}, {void Function()? onLongPress}, {MouseCursor? mouseCursor}, {bool selected = false}, {Color? focusColor}, {Color? hoverColor}, {FocusNode? focusNode}, {bool autofocus = false}, {Color? tileColor}, {Color? selectedTileColor}, {bool? enableFeedback}, {double? horizontalTitleGap}, {double? minVerticalPadding}, {double? minLeadingWidth}]
For class -> _ListTile
[Key? key, this.leading, required this.title, this.subtitle, this.trailing, required this.isThreeLine, required this.isDense, required this.visualDensity, required this.textDirection, required this.titleBaselineType, required this.horizontalTitleGap, required this.minVerticalPadding, required this.minLeadingWidth, this.subtitleBaselineType]
[{Key? key}, {Widget? leading}, {required Widget title}, {Widget? subtitle}, {Widget? trailing}, {required bool isThreeLine}, {required bool isDense}, {required VisualDensity visualDensity}, {required TextDirection textDirection}, {required TextBaseline titleBaselineType}, {required double horizontalTitleGap}, {required double minVerticalPadding}, {required double minLeadingWidth}, {TextBaseline? subtitleBaselineType}]
For class -> _ListTileElement
[_ListTile widget]
[_ListTile widget]
For class -> _RenderListTile
[required bool isDense, required VisualDensity visualDensity, required bool isThreeLine, required TextDirection textDirection, required TextBaseline titleBaselineType, TextBaseline? subtitleBaselineType, required double horizontalTitleGap, required double minVerticalPadding, required double minLeadingWidth]
[{required bool isDense}, {required VisualDensity visualDensity}, {required bool isThreeLine}, {required TextDirection textDirection}, {required TextBaseline titleBaselineType}, {TextBaseline? subtitleBaselineType}, {required double horizontalTitleGap}, {required double minVerticalPadding}, {required double minLeadingWidth}]
For class -> MaterialInkController
For class -> Material
[Key? key, this.type = MaterialType.canvas, this.elevation = 0.0, this.color, this.shadowColor, this.textStyle, this.borderRadius, this.shape, this.borderOnForeground = true, this.clipBehavior = Clip.none, this.animationDuration = kThemeChangeDuration, this.child]
[{Key? key}, {MaterialType type = MaterialType.canvas}, {double elevation = 0.0}, {Color? color}, {Color? shadowColor}, {TextStyle? textStyle}, {BorderRadiusGeometry? borderRadius}, {ShapeBorder? shape}, {bool borderOnForeground = true}, {Clip clipBehavior = Clip.none}, {Duration animationDuration = kThemeChangeDuration}, {Widget? child}]
For class -> _MaterialState
For class -> _RenderInkFeatures
[RenderBox? child, required this.vsync, required this.absorbHitTest, this.color]
[{RenderBox? child}, {required TickerProvider vsync}, {required bool absorbHitTest}, {Color? color}]
For class -> _InkFeatures
[Key? key, this.color, required this.vsync, required this.absorbHitTest, Widget? child]
[{Key? key}, {Color? color}, {required TickerProvider vsync}, {required bool absorbHitTest}, {Widget? child}]
For class -> InkFeature
[required MaterialInkController controller, required this.referenceBox, this.onRemoved]
[{required MaterialInkController controller}, {required RenderBox referenceBox}, {void Function()? onRemoved}]
For class -> ShapeBorderTween
[ShapeBorder? begin, ShapeBorder? end]
[{ShapeBorder? begin}, {ShapeBorder? end}]
For class -> _MaterialInterior
[Key? key, required this.child, required this.shape, this.borderOnForeground = true, this.clipBehavior = Clip.none, required this.elevation, required this.color, required this.shadowColor, Curve curve = Curves.linear, required Duration duration]
[{Key? key}, {required Widget child}, {required ShapeBorder shape}, {bool borderOnForeground = true}, {Clip clipBehavior = Clip.none}, {required double elevation}, {required Color color}, {required Color shadowColor}, {Curve curve = Curves.linear}, {required Duration duration}]
For class -> _MaterialInteriorState
For class -> _ShapeBorderPaint
[required this.child, required this.shape, this.borderOnForeground = true]
[{required Widget child}, {required ShapeBorder shape}, {bool borderOnForeground = true}]
For class -> _ShapeBorderPainter
[this.border, this.textDirection]
[ShapeBorder border, TextDirection? textDirection]
For class -> MaterialButton
[Key? key, required this.onPressed, this.onLongPress, this.onHighlightChanged, this.mouseCursor, this.textTheme, this.textColor, this.disabledTextColor, this.color, this.disabledColor, this.focusColor, this.hoverColor, this.highlightColor, this.splashColor, this.colorBrightness, this.elevation, this.focusElevation, this.hoverElevation, this.highlightElevation, this.disabledElevation, this.padding, this.visualDensity, this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.materialTapTargetSize, this.animationDuration, this.minWidth, this.height, this.enableFeedback = true, this.child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {double? elevation}, {double? focusElevation}, {double? hoverElevation}, {double? highlightElevation}, {double? disabledElevation}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {Duration? animationDuration}, {double? minWidth}, {double? height}, {bool enableFeedback = true}, {Widget? child}]
For class -> MaterialLocalizations
For class -> _MaterialLocalizationsDelegate
[]
[]
For class -> DefaultMaterialLocalizations
[]
[]
For class -> MaterialStateColor
[int defaultValue]
[int defaultValue]
For class -> _MaterialStateColor
[this._resolve]
[Color Function(Set<MaterialState>) _resolve]
For class -> MaterialStateMouseCursor
[]
[]
For class -> _EnabledAndDisabledMouseCursor
[required this.enabledCursor, required this.disabledCursor, required this.name]
[{required MouseCursor enabledCursor}, {required MouseCursor disabledCursor}, {required String name}]
For class -> MaterialStateBorderSide
[]
[]
For class -> MaterialStateOutlinedBorder
[]
[]
For class -> MaterialStateProperty
For class -> _MaterialStatePropertyWith
[this._resolve]
[T Function(Set<MaterialState>) _resolve]
For class -> _MaterialStatePropertyAll
[this.value]
[T value]
For class -> MergeableMaterialItem
[this.key]
[LocalKey key]
For class -> MaterialSlice
[required LocalKey key, required this.child, this.color]
[{required LocalKey key}, {required Widget child}, {Color? color}]
For class -> MaterialGap
[required LocalKey key, this.size = 16.0]
[{required LocalKey key}, {double size = 16.0}]
For class -> MergeableMaterial
[Key? key, this.mainAxis = Axis.vertical, this.elevation = 2, this.hasDividers = false, this.children = const <MergeableMaterialItem>[], this.dividerColor]
[{Key? key}, {Axis mainAxis = Axis.vertical}, {int elevation = 2}, {bool hasDividers = false}, {List<MergeableMaterialItem> children = const <MergeableMaterialItem>[]}, {Color? dividerColor}]
For class -> _AnimationTuple
[required this.controller, required this.startAnimation, required this.endAnimation, required this.gapAnimation, this.gapStart = 0.0]
[{required AnimationController controller}, {required CurvedAnimation startAnimation}, {required CurvedAnimation endAnimation}, {required CurvedAnimation gapAnimation}, {double gapStart = 0.0}]
For class -> _MergeableMaterialState
For class -> _MergeableMaterialSliceKey
[this.value]
[LocalKey value]
For class -> _MergeableMaterialListBody
[required List<Widget> children, Axis mainAxis = Axis.vertical, required this.items, required this.boxShadows]
[{required List<Widget> children}, {Axis mainAxis = Axis.vertical}, {required List<MergeableMaterialItem> items}, {required List<BoxShadow> boxShadows}]
For class -> _RenderMergeableMaterialListBody
[List<RenderBox>? children, AxisDirection axisDirection = AxisDirection.down, required this.boxShadows]
[{List<RenderBox>? children}, {AxisDirection axisDirection = AxisDirection.down}, {required List<BoxShadow> boxShadows}]
For class -> NavigationRail
[this.backgroundColor, this.extended = false, this.leading, this.trailing, required this.destinations, required this.selectedIndex, this.onDestinationSelected, this.elevation, this.groupAlignment, this.labelType, this.unselectedLabelTextStyle, this.selectedLabelTextStyle, this.unselectedIconTheme, this.selectedIconTheme, this.minWidth, this.minExtendedWidth]
[{Color? backgroundColor}, {bool extended = false}, {Widget? leading}, {Widget? trailing}, {required List<NavigationRailDestination> destinations}, {required int selectedIndex}, {void Function(int)? onDestinationSelected}, {double? elevation}, {double? groupAlignment}, {NavigationRailLabelType? labelType}, {TextStyle? unselectedLabelTextStyle}, {TextStyle? selectedLabelTextStyle}, {IconThemeData? unselectedIconTheme}, {IconThemeData? selectedIconTheme}, {double? minWidth}, {double? minExtendedWidth}]
For class -> _NavigationRailState
For class -> _RailDestination
[required this.minWidth, required this.minExtendedWidth, required this.icon, required this.label, required this.destinationAnimation, required this.extendedTransitionAnimation, required this.labelType, required this.selected, required this.iconTheme, required this.labelTextStyle, required this.onTap, required this.indexLabel, this.padding]
[{required double minWidth}, {required double minExtendedWidth}, {required Widget icon}, {required Widget label}, {required Animation<double> destinationAnimation}, {required Animation<double> extendedTransitionAnimation}, {required NavigationRailLabelType labelType}, {required bool selected}, {required IconThemeData iconTheme}, {required TextStyle labelTextStyle}, {required void Function() onTap}, {required String indexLabel}, {EdgeInsetsGeometry? padding}]
For class -> NavigationRailDestination
[required this.icon, Widget? selectedIcon, this.label, this.padding]
[{required Widget icon}, {Widget? selectedIcon}, {Widget? label}, {EdgeInsetsGeometry? padding}]
For class -> _ExtendedNavigationRailAnimation
[Key? key, required this.animation, required Widget child]
[{Key? key}, {required Animation<double> animation}, {required Widget child}]
For class -> NavigationRailThemeData
[this.backgroundColor, this.elevation, this.unselectedLabelTextStyle, this.selectedLabelTextStyle, this.unselectedIconTheme, this.selectedIconTheme, this.groupAlignment, this.labelType]
[{Color? backgroundColor}, {double? elevation}, {TextStyle? unselectedLabelTextStyle}, {TextStyle? selectedLabelTextStyle}, {IconThemeData? unselectedIconTheme}, {IconThemeData? selectedIconTheme}, {double? groupAlignment}, {NavigationRailLabelType? labelType}]
For class -> NavigationRailTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required NavigationRailThemeData data}, {required Widget child}]
For class -> OutlinedButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip clipBehavior = Clip.none, required Widget child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool autofocus = false}, {Clip clipBehavior = Clip.none}, {required Widget child}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _OutlinedButtonDefaultForeground
[this.primary, this.onSurface]
[Color? primary, Color? onSurface]
For class -> _OutlinedButtonDefaultOverlay
[this.primary]
[Color primary]
For class -> _OutlinedButtonDefaultMouseCursor
[this.enabledCursor, this.disabledCursor]
[MouseCursor enabledCursor, MouseCursor disabledCursor]
For class -> _OutlinedButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _OutlinedButtonWithIconChild
[Key? key, required this.label, required this.icon]
[{Key? key}, {required Widget label}, {required Widget icon}]
For class -> OutlinedButtonThemeData
[this.style]
[{ButtonStyle? style}]
For class -> OutlinedButtonTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required OutlinedButtonThemeData data}, {required Widget child}]
For class -> OutlineButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, double? highlightElevation, this.borderSide, this.disabledBorderColor, this.highlightedBorderColor, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, Widget? child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {double? highlightElevation}, {BorderSide? borderSide}, {Color? disabledBorderColor}, {Color? highlightedBorderColor}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {Widget? child}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, double? highlightElevation, Color? highlightedBorderColor, Color? disabledBorderColor, BorderSide? borderSide, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior, FocusNode? focusNode, bool autofocus, MaterialTapTargetSize? materialTapTargetSize, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {double? highlightElevation}, {Color? highlightedBorderColor}, {Color? disabledBorderColor}, {BorderSide? borderSide}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior}, {FocusNode? focusNode}, {bool autofocus}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget icon}, {required Widget label}]
For class -> _OutlineButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, double? highlightElevation, Color? highlightedBorderColor, Color? disabledBorderColor, BorderSide? borderSide, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {double? highlightElevation}, {Color? highlightedBorderColor}, {Color? disabledBorderColor}, {BorderSide? borderSide}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {required Widget icon}, {required Widget label}]
For class -> _OutlineButton
[Key? key, required this.onPressed, this.onLongPress, this.mouseCursor, required this.brightness, this.textTheme, required this.textColor, required this.disabledTextColor, this.color, required this.focusColor, required this.hoverColor, required this.highlightColor, required this.splashColor, required this.highlightElevation, this.borderSide, this.disabledBorderColor, required this.highlightedBorderColor, required this.padding, this.visualDensity, required this.shape, this.clipBehavior = Clip.none, this.focusNode, this.autofocus = false, this.child, this.materialTapTargetSize]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {MouseCursor? mouseCursor}, {required Brightness brightness}, {ButtonTextTheme? textTheme}, {required Color textColor}, {required Color disabledTextColor}, {Color? color}, {required Color focusColor}, {required Color hoverColor}, {required Color highlightColor}, {required Color splashColor}, {required double highlightElevation}, {BorderSide? borderSide}, {Color? disabledBorderColor}, {required Color highlightedBorderColor}, {required EdgeInsetsGeometry padding}, {VisualDensity? visualDensity}, {required ShapeBorder shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {Widget? child}, {MaterialTapTargetSize? materialTapTargetSize}]
For class -> _OutlineButtonState
For class -> _OutlineBorder
[required this.shape, required this.side]
[{required ShapeBorder shape}, {required BorderSide side}]
For class -> MaterialPageRoute
[required this.builder, RouteSettings? settings, this.maintainState = true, bool fullscreenDialog = false]
[{required Widget Function(BuildContext) builder}, {RouteSettings? settings}, {bool maintainState = true}, {bool fullscreenDialog = false}]
For class -> MaterialPage
[required this.child, this.maintainState = true, this.fullscreenDialog = false, LocalKey? key, String? name, Object? arguments]
[{required Widget child}, {bool maintainState = true}, {bool fullscreenDialog = false}, {LocalKey? key}, {String? name}, {Object? arguments}]
For class -> _PageBasedMaterialPageRoute
[required MaterialPage<T> page]
[{required MaterialPage<T> page}]
For class -> _FadeUpwardsPageTransition
[Key? key, required Animation<double> routeAnimation, required this.child]
[{Key? key}, {required Animation<double> routeAnimation}, {required Widget child}]
For class -> _OpenUpwardsPageTransition
[Key? key, required this.animation, required this.secondaryAnimation, required this.child]
[{Key? key}, {required Animation<double> animation}, {required Animation<double> secondaryAnimation}, {required Widget child}]
For class -> _ZoomPageTransition
[Key? key, required this.animation, required this.secondaryAnimation, this.child]
[{Key? key}, {required Animation<double> animation}, {required Animation<double> secondaryAnimation}, {Widget? child}]
For class -> _ZoomEnterTransition
[Key? key, required this.animation, this.reverse = false, this.child]
[{Key? key}, {required Animation<double> animation}, {bool reverse = false}, {Widget? child}]
For class -> _ZoomExitTransition
[Key? key, required this.animation, this.reverse = false, this.child]
[{Key? key}, {required Animation<double> animation}, {bool reverse = false}, {Widget? child}]
For class -> PageTransitionsBuilder
[]
[]
For class -> FadeUpwardsPageTransitionsBuilder
[]
[]
For class -> OpenUpwardsPageTransitionsBuilder
[]
[]
For class -> ZoomPageTransitionsBuilder
[]
[]
For class -> CupertinoPageTransitionsBuilder
[]
[]
For class -> PageTransitionsTheme
[Map<TargetPlatform, PageTransitionsBuilder>? builders]
[{Map<TargetPlatform, PageTransitionsBuilder>? builders}]
For class -> PaginatedDataTable
[Key? key, this.header, this.actions, required this.columns, this.sortColumnIndex, this.sortAscending = true, this.onSelectAll, this.dataRowHeight = kMinInteractiveDimension, this.headingRowHeight = 56.0, this.horizontalMargin = 24.0, this.columnSpacing = 56.0, this.showCheckboxColumn = true, this.initialFirstRowIndex = 0, this.onPageChanged, this.rowsPerPage = defaultRowsPerPage, this.availableRowsPerPage = const <int>[defaultRowsPerPage, defaultRowsPerPage * 2, defaultRowsPerPage * 5, defaultRowsPerPage * 10], this.onRowsPerPageChanged, this.dragStartBehavior = DragStartBehavior.start, required this.source]
[{Key? key}, {Widget? header}, {List<Widget>? actions}, {required List<DataColumn> columns}, {int? sortColumnIndex}, {bool sortAscending = true}, {void Function(bool?)? onSelectAll}, {double dataRowHeight = kMinInteractiveDimension}, {double headingRowHeight = 56.0}, {double horizontalMargin = 24.0}, {double columnSpacing = 56.0}, {bool showCheckboxColumn = true}, {int? initialFirstRowIndex = 0}, {void Function(int)? onPageChanged}, {int rowsPerPage = defaultRowsPerPage}, {List<int> availableRowsPerPage = const <int>[defaultRowsPerPage, defaultRowsPerPage * 2, defaultRowsPerPage * 5, defaultRowsPerPage * 10]}, {void Function(int?)? onRowsPerPageChanged}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {required DataTableSource source}]
For class -> PaginatedDataTableState
For class -> PopupMenuEntry
[Key? key]
[{Key? key}]
For class -> PopupMenuDivider
[Key? key, this.height = _kMenuDividerHeight]
[{Key? key}, {double height = _kMenuDividerHeight}]
For class -> _PopupMenuDividerState
For class -> _MenuItem
[Key? key, required this.onLayout, required Widget? child]
[{Key? key}, {required void Function(Size) onLayout}, {required Widget? child}]
For class -> _RenderMenuItem
[this.onLayout, RenderBox? child]
[void Function(Size) onLayout, [RenderBox? child]]
For class -> PopupMenuItem
[Key? key, this.value, this.enabled = true, this.height = kMinInteractiveDimension, this.textStyle, this.mouseCursor, required this.child]
[{Key? key}, {T? value}, {bool enabled = true}, {double height = kMinInteractiveDimension}, {TextStyle? textStyle}, {MouseCursor? mouseCursor}, {required Widget? child}]
For class -> PopupMenuItemState
For class -> CheckedPopupMenuItem
[Key? key, T? value, this.checked = false, bool enabled = true, Widget? child]
[{Key? key}, {T? value}, {bool checked = false}, {bool enabled = true}, {Widget? child}]
For class -> _CheckedPopupMenuItemState
For class -> _PopupMenu
[Key? key, required this.route, required this.semanticLabel]
[{Key? key}, {required _PopupMenuRoute<T> route}, {required String? semanticLabel}]
For class -> _PopupMenuRouteLayout
[this.position, this.itemSizes, this.selectedItemIndex, this.textDirection]
[RelativeRect position, List<Size?> itemSizes, int? selectedItemIndex, TextDirection textDirection]
For class -> _PopupMenuRoute
[required this.position, required this.items, this.initialValue, this.elevation, required this.barrierLabel, this.semanticLabel, this.shape, this.color, required this.capturedThemes]
[{required RelativeRect position}, {required List<PopupMenuEntry<T>> items}, {T? initialValue}, {double? elevation}, {required String barrierLabel}, {String? semanticLabel}, {ShapeBorder? shape}, {Color? color}, {required CapturedThemes capturedThemes}]
For class -> PopupMenuButton
[Key? key, required this.itemBuilder, this.initialValue, this.onSelected, this.onCanceled, this.tooltip, this.elevation, this.padding = const EdgeInsets.all(8.0), this.child, this.icon, this.iconSize, this.offset = Offset.zero, this.enabled = true, this.shape, this.color, this.enableFeedback]
[{Key? key}, {required List<PopupMenuEntry<T>> Function(BuildContext) itemBuilder}, {T? initialValue}, {void Function(T)? onSelected}, {void Function()? onCanceled}, {String? tooltip}, {double? elevation}, {EdgeInsetsGeometry padding = const EdgeInsets.all(8.0)}, {Widget? child}, {Widget? icon}, {double? iconSize}, {Offset offset = Offset.zero}, {bool enabled = true}, {ShapeBorder? shape}, {Color? color}, {bool? enableFeedback}]
For class -> PopupMenuButtonState
For class -> PopupMenuThemeData
[this.color, this.shape, this.elevation, this.textStyle, this.enableFeedback]
[{Color? color}, {ShapeBorder? shape}, {double? elevation}, {TextStyle? textStyle}, {bool? enableFeedback}]
For class -> PopupMenuTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required PopupMenuThemeData data}, {required Widget child}]
For class -> ProgressIndicator
[Key? key, this.value, this.backgroundColor, this.valueColor, this.semanticsLabel, this.semanticsValue]
[{Key? key}, {double? value}, {Color? backgroundColor}, {Animation<Color?>? valueColor}, {String? semanticsLabel}, {String? semanticsValue}]
For class -> _LinearProgressIndicatorPainter
[required this.backgroundColor, required this.valueColor, this.value, required this.animationValue, required this.textDirection]
[{required Color backgroundColor}, {required Color valueColor}, {double? value}, {required double animationValue}, {required TextDirection textDirection}]
For class -> LinearProgressIndicator
[Key? key, double? value, Color? backgroundColor, Animation<Color?>? valueColor, this.minHeight, String? semanticsLabel, String? semanticsValue]
[{Key? key}, {double? value}, {Color? backgroundColor}, {Animation<Color?>? valueColor}, {double? minHeight}, {String? semanticsLabel}, {String? semanticsValue}]
For class -> _LinearProgressIndicatorState
For class -> _CircularProgressIndicatorPainter
[this.backgroundColor, required this.valueColor, required this.value, required this.headValue, required this.tailValue, required this.offsetValue, required this.rotationValue, required this.strokeWidth]
[{Color? backgroundColor}, {required Color valueColor}, {required double? value}, {required double headValue}, {required double tailValue}, {required double offsetValue}, {required double rotationValue}, {required double strokeWidth}]
For class -> CircularProgressIndicator
[Key? key, double? value, Color? backgroundColor, Animation<Color?>? valueColor, this.strokeWidth = 4.0, String? semanticsLabel, String? semanticsValue]
[{Key? key}, {double? value}, {Color? backgroundColor}, {Animation<Color?>? valueColor}, {double strokeWidth = 4.0}, {String? semanticsLabel}, {String? semanticsValue}]
[Key? key, double? value, Color? backgroundColor, Animation<Color?>? valueColor, this.strokeWidth = 4.0, String? semanticsLabel, String? semanticsValue]
[{Key? key}, {double? value}, {Color? backgroundColor}, {Animation<Color?>? valueColor}, {double strokeWidth = 4.0}, {String? semanticsLabel}, {String? semanticsValue}]
For class -> _CircularProgressIndicatorState
For class -> _RefreshProgressIndicatorPainter
[required Color valueColor, required double? value, required double headValue, required double tailValue, required double offsetValue, required double rotationValue, required double strokeWidth, required this.arrowheadScale]
[{required Color valueColor}, {required double? value}, {required double headValue}, {required double tailValue}, {required double offsetValue}, {required double rotationValue}, {required double strokeWidth}, {required double arrowheadScale}]
For class -> RefreshProgressIndicator
[Key? key, double? value, Color? backgroundColor, Animation<Color?>? valueColor, double strokeWidth = 2.0, String? semanticsLabel, String? semanticsValue]
[{Key? key}, {double? value}, {Color? backgroundColor}, {Animation<Color?>? valueColor}, {double strokeWidth = 2.0}, {String? semanticsLabel}, {String? semanticsValue}]
For class -> _RefreshProgressIndicatorState
For class -> Radio
[Key? key, required this.value, required this.groupValue, required this.onChanged, this.mouseCursor, this.toggleable = false, this.activeColor, this.fillColor, this.focusColor, this.hoverColor, this.overlayColor, this.splashRadius, this.materialTapTargetSize, this.visualDensity, this.focusNode, this.autofocus = false]
[{Key? key}, {required T value}, {required T? groupValue}, {required void Function(T?)? onChanged}, {MouseCursor? mouseCursor}, {bool toggleable = false}, {Color? activeColor}, {MaterialStateProperty<Color?>? fillColor}, {Color? focusColor}, {Color? hoverColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {MaterialTapTargetSize? materialTapTargetSize}, {VisualDensity? visualDensity}, {FocusNode? focusNode}, {bool autofocus = false}]
For class -> _RadioState
For class -> _RadioRenderObjectWidget
[Key? key, required this.selected, required this.activeColor, required this.inactiveColor, required this.focusColor, required this.hoverColor, required this.reactionColor, required this.inactiveReactionColor, required this.additionalConstraints, this.onChanged, required this.toggleable, required this.vsync, required this.hasFocus, required this.hovering, required this.splashRadius]
[{Key? key}, {required bool selected}, {required Color activeColor}, {required Color inactiveColor}, {required Color focusColor}, {required Color hoverColor}, {required Color reactionColor}, {required Color inactiveReactionColor}, {required BoxConstraints additionalConstraints}, {void Function(bool?)? onChanged}, {required bool toggleable}, {required TickerProvider vsync}, {required bool hasFocus}, {required bool hovering}, {required double splashRadius}]
For class -> _RenderRadio
[required bool value, required Color activeColor, required Color inactiveColor, required Color focusColor, required Color hoverColor, required Color reactionColor, required Color inactiveReactionColor, required double splashRadius, required ValueChanged<bool?>? onChanged, required bool tristate, required BoxConstraints additionalConstraints, required TickerProvider vsync, required bool hasFocus, required bool hovering]
[{required bool value}, {required Color activeColor}, {required Color inactiveColor}, {required Color focusColor}, {required Color hoverColor}, {required Color reactionColor}, {required Color inactiveReactionColor}, {required double splashRadius}, {required void Function(bool?)? onChanged}, {required bool tristate}, {required BoxConstraints additionalConstraints}, {required TickerProvider vsync}, {required bool hasFocus}, {required bool hovering}]
For class -> RadioListTile
[Key? key, required this.value, required this.groupValue, required this.onChanged, this.toggleable = false, this.activeColor, this.title, this.subtitle, this.isThreeLine = false, this.dense, this.secondary, this.selected = false, this.controlAffinity = ListTileControlAffinity.platform, this.autofocus = false, this.contentPadding, this.shape, this.tileColor, this.selectedTileColor]
[{Key? key}, {required T value}, {required T? groupValue}, {required void Function(T?)? onChanged}, {bool toggleable = false}, {Color? activeColor}, {Widget? title}, {Widget? subtitle}, {bool isThreeLine = false}, {bool? dense}, {Widget? secondary}, {bool selected = false}, {ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform}, {bool autofocus = false}, {EdgeInsetsGeometry? contentPadding}, {ShapeBorder? shape}, {Color? tileColor}, {Color? selectedTileColor}]
For class -> RadioThemeData
[this.mouseCursor, this.fillColor, this.overlayColor, this.splashRadius, this.materialTapTargetSize, this.visualDensity]
[{MaterialStateProperty<MouseCursor?>? mouseCursor}, {MaterialStateProperty<Color?>? fillColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {MaterialTapTargetSize? materialTapTargetSize}, {VisualDensity? visualDensity}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T Function(T?, T?, double) lerpFunction]
For class -> RadioTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required RadioThemeData data}, {required Widget child}]
For class -> RaisedButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, double? elevation, double? focusElevation, double? hoverElevation, double? highlightElevation, double? disabledElevation, EdgeInsetsGeometry? padding, VisualDensity? visualDensity, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, MaterialTapTargetSize? materialTapTargetSize, Duration? animationDuration, Widget? child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {double? elevation}, {double? focusElevation}, {double? hoverElevation}, {double? highlightElevation}, {double? disabledElevation}, {EdgeInsetsGeometry? padding}, {VisualDensity? visualDensity}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {MaterialTapTargetSize? materialTapTargetSize}, {Duration? animationDuration}, {Widget? child}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, double? elevation, double? highlightElevation, double? disabledElevation, ShapeBorder? shape, Clip clipBehavior, FocusNode? focusNode, bool autofocus, EdgeInsetsGeometry? padding, MaterialTapTargetSize? materialTapTargetSize, Duration? animationDuration, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {double? elevation}, {double? highlightElevation}, {double? disabledElevation}, {ShapeBorder? shape}, {Clip clipBehavior}, {FocusNode? focusNode}, {bool autofocus}, {EdgeInsetsGeometry? padding}, {MaterialTapTargetSize? materialTapTargetSize}, {Duration? animationDuration}, {required Widget icon}, {required Widget label}]
For class -> _RaisedButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHighlightChanged, MouseCursor? mouseCursor, ButtonTextTheme? textTheme, Color? textColor, Color? disabledTextColor, Color? color, Color? disabledColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, Brightness? colorBrightness, double? elevation, double? highlightElevation, double? disabledElevation, ShapeBorder? shape, Clip clipBehavior = Clip.none, FocusNode? focusNode, bool autofocus = false, EdgeInsetsGeometry? padding, MaterialTapTargetSize? materialTapTargetSize, Duration? animationDuration, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {void Function(bool)? onHighlightChanged}, {MouseCursor? mouseCursor}, {ButtonTextTheme? textTheme}, {Color? textColor}, {Color? disabledTextColor}, {Color? color}, {Color? disabledColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {Brightness? colorBrightness}, {double? elevation}, {double? highlightElevation}, {double? disabledElevation}, {ShapeBorder? shape}, {Clip clipBehavior = Clip.none}, {FocusNode? focusNode}, {bool autofocus = false}, {EdgeInsetsGeometry? padding}, {MaterialTapTargetSize? materialTapTargetSize}, {Duration? animationDuration}, {required Widget icon}, {required Widget label}]
For class -> RangeSlider
[Key? key, required this.values, required this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0.0, this.max = 1.0, this.divisions, this.labels, this.activeColor, this.inactiveColor, this.semanticFormatterCallback]
[{Key? key}, {required RangeValues values}, {required void Function(RangeValues)? onChanged}, {void Function(RangeValues)? onChangeStart}, {void Function(RangeValues)? onChangeEnd}, {double min = 0.0}, {double max = 1.0}, {int? divisions}, {RangeLabels? labels}, {Color? activeColor}, {Color? inactiveColor}, {String Function(double)? semanticFormatterCallback}]
For class -> _RangeSliderState
For class -> _RangeSliderRenderObjectWidget
[Key? key, required this.values, required this.divisions, required this.labels, required this.sliderTheme, required this.textScaleFactor, required this.screenSize, required this.onChanged, required this.onChangeStart, required this.onChangeEnd, required this.state, required this.semanticFormatterCallback]
[{Key? key}, {required RangeValues values}, {required int? divisions}, {required RangeLabels? labels}, {required SliderThemeData sliderTheme}, {required double textScaleFactor}, {required Size screenSize}, {required void Function(RangeValues)? onChanged}, {required void Function(RangeValues)? onChangeStart}, {required void Function(RangeValues)? onChangeEnd}, {required _RangeSliderState state}, {required String Function(double)? semanticFormatterCallback}]
For class -> _RenderRangeSlider
[required RangeValues values, required int? divisions, required RangeLabels? labels, required SliderThemeData sliderTheme, required ThemeData? theme, required double textScaleFactor, required Size screenSize, required TargetPlatform platform, required ValueChanged<RangeValues>? onChanged, required SemanticFormatterCallback? semanticFormatterCallback, required this.onChangeStart, required this.onChangeEnd, required _RangeSliderState state, required TextDirection textDirection]
[{required RangeValues values}, {required int? divisions}, {required RangeLabels? labels}, {required SliderThemeData sliderTheme}, {required ThemeData? theme}, {required double textScaleFactor}, {required Size screenSize}, {required TargetPlatform platform}, {required void Function(RangeValues)? onChanged}, {required String Function(double)? semanticFormatterCallback}, {required void Function(RangeValues)? onChangeStart}, {required void Function(RangeValues)? onChangeEnd}, {required _RangeSliderState state}, {required TextDirection textDirection}]
For class -> _ValueIndicatorRenderObjectWidget
[required this.state]
[{required _RangeSliderState state}]
For class -> _RenderValueIndicator
[required _RangeSliderState state]
[{required _RangeSliderState state}]
For class -> RefreshIndicator
[Key? key, required this.child, this.displacement = 40.0, required this.onRefresh, this.color, this.backgroundColor, this.notificationPredicate = defaultScrollNotificationPredicate, this.semanticsLabel, this.semanticsValue, this.strokeWidth = 2.0, this.triggerMode = RefreshIndicatorTriggerMode.onEdge]
[{Key? key}, {required Widget child}, {double displacement = 40.0}, {required Future<void> Function() onRefresh}, {Color? color}, {Color? backgroundColor}, {bool Function(ScrollNotification) notificationPredicate = defaultScrollNotificationPredicate}, {String? semanticsLabel}, {String? semanticsValue}, {double strokeWidth = 2.0}, {RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge}]
For class -> RefreshIndicatorState
For class -> ReorderableListView
[Key? key, required List<Widget> children, required this.onReorder, this.proxyDecorator, this.buildDefaultDragHandles = true, this.padding, this.header, this.scrollDirection = Axis.vertical, this.reverse = false, this.scrollController, this.primary, this.physics, this.shrinkWrap = false, this.anchor = 0.0, this.cacheExtent, this.dragStartBehavior = DragStartBehavior.start, this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required List<Widget> children}, {required void Function(int, int) onReorder}, {Widget Function(Widget, int, Animation<double>)? proxyDecorator}, {bool buildDefaultDragHandles = true}, {EdgeInsets? padding}, {Widget? header}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? scrollController}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {double anchor = 0.0}, {double? cacheExtent}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, required this.itemBuilder, required this.itemCount, required this.onReorder, this.proxyDecorator, this.buildDefaultDragHandles = true, this.padding, this.header, this.scrollDirection = Axis.vertical, this.reverse = false, this.scrollController, this.primary, this.physics, this.shrinkWrap = false, this.anchor = 0.0, this.cacheExtent, this.dragStartBehavior = DragStartBehavior.start, this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required Widget Function(BuildContext, int) itemBuilder}, {required int itemCount}, {required void Function(int, int) onReorder}, {Widget Function(Widget, int, Animation<double>)? proxyDecorator}, {bool buildDefaultDragHandles = true}, {EdgeInsets? padding}, {Widget? header}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? scrollController}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {double anchor = 0.0}, {double? cacheExtent}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> _ReorderableListViewState
For class -> _ReorderableListContent
[required this.itemBuilder, required this.itemCount, required this.onReorder, required this.proxyDecorator, required this.buildDefaultDragHandles, required this.padding, required this.header, required this.scrollDirection, required this.reverse, required this.scrollController, required this.primary, required this.physics, required this.shrinkWrap, required this.anchor, required this.cacheExtent, required this.dragStartBehavior, required this.keyboardDismissBehavior, required this.restorationId, required this.clipBehavior]
[{required Widget Function(BuildContext, int) itemBuilder}, {required int itemCount}, {required void Function(int, int) onReorder}, {required Widget Function(Widget, int, Animation<double>)? proxyDecorator}, {required bool buildDefaultDragHandles}, {required EdgeInsets? padding}, {required Widget? header}, {required Axis scrollDirection}, {required bool reverse}, {required ScrollController? scrollController}, {required bool? primary}, {required ScrollPhysics? physics}, {required bool shrinkWrap}, {required double anchor}, {required double? cacheExtent}, {required DragStartBehavior dragStartBehavior}, {required ScrollViewKeyboardDismissBehavior keyboardDismissBehavior}, {required String? restorationId}, {required Clip clipBehavior}]
For class -> _ReorderableListContentState
For class -> _ReorderableListViewChildGlobalKey
[this.subKey, this.state]
[Key subKey, State<StatefulWidget> state]
For class -> ScaffoldMessenger
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> ScaffoldMessengerState
For class -> _ScaffoldMessengerScope
[Key? key, required Widget child, required ScaffoldMessengerState scaffoldMessengerState]
[{Key? key}, {required Widget child}, {required ScaffoldMessengerState scaffoldMessengerState}]
For class -> ScaffoldPrelayoutGeometry
[required this.bottomSheetSize, required this.contentBottom, required this.contentTop, required this.floatingActionButtonSize, required this.minInsets, required this.minViewPadding, required this.scaffoldSize, required this.snackBarSize, required this.textDirection]
[{required Size bottomSheetSize}, {required double contentBottom}, {required double contentTop}, {required Size floatingActionButtonSize}, {required EdgeInsets minInsets}, {required EdgeInsets minViewPadding}, {required Size scaffoldSize}, {required Size snackBarSize}, {required TextDirection textDirection}]
For class -> _TransitionSnapshotFabLocation
[this.begin, this.end, this.animator, this.progress]
[FloatingActionButtonLocation begin, FloatingActionButtonLocation end, FloatingActionButtonAnimator animator, double progress]
For class -> ScaffoldGeometry
[this.bottomNavigationBarTop, this.floatingActionButtonArea]
[{double? bottomNavigationBarTop}, {Rect? floatingActionButtonArea}]
For class -> _ScaffoldGeometryNotifier
[this.geometry, this.context]
[ScaffoldGeometry geometry, BuildContext context]
For class -> _BodyBoxConstraints
[double minWidth = 0.0, double maxWidth = double.infinity, double minHeight = 0.0, double maxHeight = double.infinity, required this.bottomWidgetsHeight, required this.appBarHeight]
[{double minWidth = 0.0}, {double maxWidth = double.infinity}, {double minHeight = 0.0}, {double maxHeight = double.infinity}, {required double bottomWidgetsHeight}, {required double appBarHeight}]
For class -> _BodyBuilder
[Key? key, required this.extendBody, required this.extendBodyBehindAppBar, required this.body]
[{Key? key}, {required bool extendBody}, {required bool extendBodyBehindAppBar}, {required Widget body}]
For class -> _ScaffoldLayout
[required this.minInsets, required this.minViewPadding, required this.textDirection, required this.geometryNotifier, required this.previousFloatingActionButtonLocation, required this.currentFloatingActionButtonLocation, required this.floatingActionButtonMoveAnimationProgress, required this.floatingActionButtonMotionAnimator, required this.isSnackBarFloating, required this.snackBarWidth, required this.extendBody, required this.extendBodyBehindAppBar]
[{required EdgeInsets minInsets}, {required EdgeInsets minViewPadding}, {required TextDirection textDirection}, {required _ScaffoldGeometryNotifier geometryNotifier}, {required FloatingActionButtonLocation previousFloatingActionButtonLocation}, {required FloatingActionButtonLocation currentFloatingActionButtonLocation}, {required double floatingActionButtonMoveAnimationProgress}, {required FloatingActionButtonAnimator floatingActionButtonMotionAnimator}, {required bool isSnackBarFloating}, {required double? snackBarWidth}, {required bool extendBody}, {required bool extendBodyBehindAppBar}]
For class -> _FloatingActionButtonTransition
[Key? key, required this.child, required this.fabMoveAnimation, required this.fabMotionAnimator, required this.geometryNotifier, required this.currentController]
[{Key? key}, {required Widget? child}, {required Animation<double> fabMoveAnimation}, {required FloatingActionButtonAnimator fabMotionAnimator}, {required _ScaffoldGeometryNotifier geometryNotifier}, {required AnimationController currentController}]
For class -> _FloatingActionButtonTransitionState
For class -> Scaffold
[Key? key, this.appBar, this.body, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.drawer, this.onDrawerChanged, this.endDrawer, this.onEndDrawerChanged, this.bottomNavigationBar, this.bottomSheet, this.backgroundColor, this.resizeToAvoidBottomInset, this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.start, this.extendBody = false, this.extendBodyBehindAppBar = false, this.drawerScrimColor, this.drawerEdgeDragWidth, this.drawerEnableOpenDragGesture = true, this.endDrawerEnableOpenDragGesture = true, this.restorationId]
[{Key? key}, {PreferredSizeWidget? appBar}, {Widget? body}, {Widget? floatingActionButton}, {FloatingActionButtonLocation? floatingActionButtonLocation}, {FloatingActionButtonAnimator? floatingActionButtonAnimator}, {List<Widget>? persistentFooterButtons}, {Widget? drawer}, {void Function(bool)? onDrawerChanged}, {Widget? endDrawer}, {void Function(bool)? onEndDrawerChanged}, {Widget? bottomNavigationBar}, {Widget? bottomSheet}, {Color? backgroundColor}, {bool? resizeToAvoidBottomInset}, {bool primary = true}, {DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start}, {bool extendBody = false}, {bool extendBodyBehindAppBar = false}, {Color? drawerScrimColor}, {double? drawerEdgeDragWidth}, {bool drawerEnableOpenDragGesture = true}, {bool endDrawerEnableOpenDragGesture = true}, {String? restorationId}]
For class -> ScaffoldState
For class -> ScaffoldFeatureController
[this._widget, this._completer, this.close, this.setState]
[T _widget, Completer<U> _completer, void Function() close, void Function(void Function())? setState]
For class -> _BottomSheetSuspendedCurve
[this.startingPoint, this.curve = Curves.easeOutCubic]
[double startingPoint, {Curve curve = Curves.easeOutCubic}]
For class -> _StandardBottomSheet
[Key? key, required this.animationController, this.enableDrag = true, required this.onClosing, required this.onDismissed, required this.builder, this.isPersistent = false, this.backgroundColor, this.elevation, this.shape, this.clipBehavior]
[{Key? key}, {required AnimationController animationController}, {bool enableDrag = true}, {required void Function()? onClosing}, {required void Function()? onDismissed}, {required Widget Function(BuildContext) builder}, {bool isPersistent = false}, {Color? backgroundColor}, {double? elevation}, {ShapeBorder? shape}, {Clip? clipBehavior}]
For class -> _StandardBottomSheetState
For class -> PersistentBottomSheetController
[_StandardBottomSheet widget, Completer<T> completer, VoidCallback close, StateSetter setState, this._isLocalHistoryEntry]
[_StandardBottomSheet widget, Completer<T> completer, void Function() close, void Function(void Function()) setState, bool _isLocalHistoryEntry]
For class -> _ScaffoldScope
[Key? key, required this.hasDrawer, required this.geometryNotifier, required Widget child]
[{Key? key}, {required bool hasDrawer}, {required _ScaffoldGeometryNotifier geometryNotifier}, {required Widget child}]
For class -> Scrollbar
[Key? key, required this.child, this.controller, this.isAlwaysShown, this.showTrackOnHover, this.hoverThickness, this.thickness, this.radius, this.notificationPredicate]
[{Key? key}, {required Widget child}, {ScrollController? controller}, {bool? isAlwaysShown}, {bool? showTrackOnHover}, {double? hoverThickness}, {double? thickness}, {Radius? radius}, {bool Function(ScrollNotification)? notificationPredicate}]
For class -> _ScrollbarState
For class -> _MaterialScrollbar
[Key? key, required Widget child, ScrollController? controller, bool? isAlwaysShown, this.showTrackOnHover, this.hoverThickness, double? thickness, Radius? radius, ScrollNotificationPredicate? notificationPredicate]
[{Key? key}, {required Widget child}, {ScrollController? controller}, {bool? isAlwaysShown}, {bool? showTrackOnHover}, {double? hoverThickness}, {double? thickness}, {Radius? radius}, {bool Function(ScrollNotification)? notificationPredicate}]
For class -> _MaterialScrollbarState
For class -> ScrollbarThemeData
[this.thickness, this.showTrackOnHover, this.isAlwaysShown, this.radius, this.thumbColor, this.trackColor, this.trackBorderColor, this.crossAxisMargin, this.mainAxisMargin, this.minThumbLength]
[{MaterialStateProperty<double?>? thickness}, {bool? showTrackOnHover}, {bool? isAlwaysShown}, {Radius? radius}, {MaterialStateProperty<Color?>? thumbColor}, {MaterialStateProperty<Color?>? trackColor}, {MaterialStateProperty<Color?>? trackBorderColor}, {double? crossAxisMargin}, {double? mainAxisMargin}, {double? minThumbLength}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T Function(T?, T?, double) lerpFunction]
For class -> ScrollbarTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ScrollbarThemeData data}, {required Widget child}]
For class -> SearchDelegate
[this.searchFieldLabel, this.searchFieldStyle, this.searchFieldDecorationTheme, this.keyboardType, this.textInputAction = TextInputAction.search]
[{String? searchFieldLabel}, {TextStyle? searchFieldStyle}, {InputDecorationTheme? searchFieldDecorationTheme}, {TextInputType? keyboardType}, {TextInputAction textInputAction = TextInputAction.search}]
For class -> _SearchPageRoute
[required this.delegate]
[{required SearchDelegate<T> delegate}]
For class -> _SearchPage
[required this.delegate, required this.animation]
[{required SearchDelegate<T> delegate}, {required Animation<double> animation}]
For class -> _SearchPageState
For class -> _TextSpanEditingController
[required TextSpan textSpan]
[{required TextSpan textSpan}]
For class -> _SelectableTextSelectionGestureDetectorBuilder
[required _SelectableTextState state]
[{required _SelectableTextState state}]
For class -> SelectableText
[String this.data, Key? key, this.focusNode, this.style, this.strutStyle, this.textAlign, this.textDirection, this.textScaleFactor, this.showCursor = false, this.autofocus = false, ToolbarOptions? toolbarOptions, this.minLines, this.maxLines, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorColor, this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollPhysics, this.textHeightBehavior, this.textWidthBasis, this.onSelectionChanged]
[String data, {Key? key}, {FocusNode? focusNode}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign? textAlign}, {TextDirection? textDirection}, {double? textScaleFactor}, {bool showCursor = false}, {bool autofocus = false}, {ToolbarOptions? toolbarOptions}, {int? minLines}, {int? maxLines}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius? cursorRadius}, {Color? cursorColor}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {void Function()? onTap}, {ScrollPhysics? scrollPhysics}, {TextHeightBehavior? textHeightBehavior}, {TextWidthBasis? textWidthBasis}, {void Function(TextSelection, SelectionChangedCause?)? onSelectionChanged}]
[TextSpan this.textSpan, Key? key, this.focusNode, this.style, this.strutStyle, this.textAlign, this.textDirection, this.textScaleFactor, this.showCursor = false, this.autofocus = false, ToolbarOptions? toolbarOptions, this.minLines, this.maxLines, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorColor, this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.scrollPhysics, this.textHeightBehavior, this.textWidthBasis, this.onSelectionChanged]
[TextSpan textSpan, {Key? key}, {FocusNode? focusNode}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign? textAlign}, {TextDirection? textDirection}, {double? textScaleFactor}, {bool showCursor = false}, {bool autofocus = false}, {ToolbarOptions? toolbarOptions}, {int? minLines}, {int? maxLines}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius? cursorRadius}, {Color? cursorColor}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {void Function()? onTap}, {ScrollPhysics? scrollPhysics}, {TextHeightBehavior? textHeightBehavior}, {TextWidthBasis? textWidthBasis}, {void Function(TextSelection, SelectionChangedCause?)? onSelectionChanged}]
For class -> _SelectableTextState
For class -> Slider
[Key? key, required this.value, required this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0.0, this.max = 1.0, this.divisions, this.label, this.activeColor, this.inactiveColor, this.mouseCursor, this.semanticFormatterCallback, this.focusNode, this.autofocus = false]
[{Key? key}, {required double value}, {required void Function(double)? onChanged}, {void Function(double)? onChangeStart}, {void Function(double)? onChangeEnd}, {double min = 0.0}, {double max = 1.0}, {int? divisions}, {String? label}, {Color? activeColor}, {Color? inactiveColor}, {MouseCursor? mouseCursor}, {String Function(double)? semanticFormatterCallback}, {FocusNode? focusNode}, {bool autofocus = false}]
[Key? key, required this.value, required this.onChanged, this.onChangeStart, this.onChangeEnd, this.min = 0.0, this.max = 1.0, this.divisions, this.label, this.mouseCursor, this.activeColor, this.inactiveColor, this.semanticFormatterCallback, this.focusNode, this.autofocus = false]
[{Key? key}, {required double value}, {required void Function(double)? onChanged}, {void Function(double)? onChangeStart}, {void Function(double)? onChangeEnd}, {double min = 0.0}, {double max = 1.0}, {int? divisions}, {String? label}, {MouseCursor? mouseCursor}, {Color? activeColor}, {Color? inactiveColor}, {String Function(double)? semanticFormatterCallback}, {FocusNode? focusNode}, {bool autofocus = false}]
For class -> _SliderState
For class -> _SliderRenderObjectWidget
[Key? key, required this.value, required this.divisions, required this.label, required this.sliderTheme, required this.textScaleFactor, required this.screenSize, required this.onChanged, required this.onChangeStart, required this.onChangeEnd, required this.state, required this.semanticFormatterCallback, required this.hasFocus, required this.hovering]
[{Key? key}, {required double value}, {required int? divisions}, {required String? label}, {required SliderThemeData sliderTheme}, {required double textScaleFactor}, {required Size screenSize}, {required void Function(double)? onChanged}, {required void Function(double)? onChangeStart}, {required void Function(double)? onChangeEnd}, {required _SliderState state}, {required String Function(double)? semanticFormatterCallback}, {required bool hasFocus}, {required bool hovering}]
For class -> _RenderSlider
[required double value, required int? divisions, required String? label, required SliderThemeData sliderTheme, required double textScaleFactor, required Size screenSize, required TargetPlatform platform, required ValueChanged<double>? onChanged, required SemanticFormatterCallback? semanticFormatterCallback, required this.onChangeStart, required this.onChangeEnd, required _SliderState state, required TextDirection textDirection, required bool hasFocus, required bool hovering]
[{required double value}, {required int? divisions}, {required String? label}, {required SliderThemeData sliderTheme}, {required double textScaleFactor}, {required Size screenSize}, {required TargetPlatform platform}, {required void Function(double)? onChanged}, {required String Function(double)? semanticFormatterCallback}, {required void Function(double)? onChangeStart}, {required void Function(double)? onChangeEnd}, {required _SliderState state}, {required TextDirection textDirection}, {required bool hasFocus}, {required bool hovering}]
For class -> _AdjustSliderIntent
[required this.type]
[{required _SliderAdjustmentType type}]
[]
[]
[]
[]
[]
[]
[]
[]
For class -> _ValueIndicatorRenderObjectWidget
[required this.state]
[{required _SliderState state}]
For class -> _RenderValueIndicator
[required _SliderState state]
[{required _SliderState state}]
For class -> SliderTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required SliderThemeData data}, {required Widget child}]
For class -> SliderThemeData
[this.trackHeight, this.activeTrackColor, this.inactiveTrackColor, this.disabledActiveTrackColor, this.disabledInactiveTrackColor, this.activeTickMarkColor, this.inactiveTickMarkColor, this.disabledActiveTickMarkColor, this.disabledInactiveTickMarkColor, this.thumbColor, this.overlappingShapeStrokeColor, this.disabledThumbColor, this.overlayColor, this.valueIndicatorColor, this.overlayShape, this.tickMarkShape, this.thumbShape, this.trackShape, this.valueIndicatorShape, this.rangeTickMarkShape, this.rangeThumbShape, this.rangeTrackShape, this.rangeValueIndicatorShape, this.showValueIndicator, this.valueIndicatorTextStyle, this.minThumbSeparation, this.thumbSelector]
[{double? trackHeight}, {Color? activeTrackColor}, {Color? inactiveTrackColor}, {Color? disabledActiveTrackColor}, {Color? disabledInactiveTrackColor}, {Color? activeTickMarkColor}, {Color? inactiveTickMarkColor}, {Color? disabledActiveTickMarkColor}, {Color? disabledInactiveTickMarkColor}, {Color? thumbColor}, {Color? overlappingShapeStrokeColor}, {Color? disabledThumbColor}, {Color? overlayColor}, {Color? valueIndicatorColor}, {SliderComponentShape? overlayShape}, {SliderTickMarkShape? tickMarkShape}, {SliderComponentShape? thumbShape}, {SliderTrackShape? trackShape}, {SliderComponentShape? valueIndicatorShape}, {RangeSliderTickMarkShape? rangeTickMarkShape}, {RangeSliderThumbShape? rangeThumbShape}, {RangeSliderTrackShape? rangeTrackShape}, {RangeSliderValueIndicatorShape? rangeValueIndicatorShape}, {ShowValueIndicator? showValueIndicator}, {TextStyle? valueIndicatorTextStyle}, {double? minThumbSeparation}, {Thumb? Function(TextDirection, RangeValues, double, Size, Size, double)? thumbSelector}]
[required Color primaryColor, required Color primaryColorDark, required Color primaryColorLight, required TextStyle valueIndicatorTextStyle]
[{required Color primaryColor}, {required Color primaryColorDark}, {required Color primaryColorLight}, {required TextStyle valueIndicatorTextStyle}]
For class -> SliderComponentShape
[]
[]
For class -> SliderTickMarkShape
[]
[]
For class -> SliderTrackShape
[]
[]
For class -> RangeSliderThumbShape
[]
[]
For class -> RangeSliderValueIndicatorShape
[]
[]
For class -> RangeSliderTickMarkShape
[]
[]
For class -> RangeSliderTrackShape
[]
[]
For class -> BaseSliderTrackShape
For class -> RectangularSliderTrackShape
[this.disabledThumbGapWidth = 2.0]
[{double disabledThumbGapWidth = 2.0}]
For class -> RoundedRectSliderTrackShape
[]
[]
For class -> RectangularRangeSliderTrackShape
[]
[]
For class -> RoundedRectRangeSliderTrackShape
[]
[]
For class -> RoundSliderTickMarkShape
[this.tickMarkRadius]
[{double? tickMarkRadius}]
For class -> RoundRangeSliderTickMarkShape
[this.tickMarkRadius]
[{double? tickMarkRadius}]
For class -> _EmptySliderTickMarkShape
For class -> _EmptySliderComponentShape
For class -> RoundSliderThumbShape
[this.enabledThumbRadius = 10.0, this.disabledThumbRadius, this.elevation = 1.0, this.pressedElevation = 6.0]
[{double enabledThumbRadius = 10.0}, {double? disabledThumbRadius}, {double elevation = 1.0}, {double pressedElevation = 6.0}]
For class -> RoundRangeSliderThumbShape
[this.enabledThumbRadius = 10.0, this.disabledThumbRadius, this.elevation = 1.0, this.pressedElevation = 6.0]
[{double enabledThumbRadius = 10.0}, {double? disabledThumbRadius}, {double elevation = 1.0}, {double pressedElevation = 6.0}]
For class -> RoundSliderOverlayShape
[this.overlayRadius = 24.0]
[{double overlayRadius = 24.0}]
For class -> RectangularSliderValueIndicatorShape
[]
[]
For class -> RectangularRangeSliderValueIndicatorShape
[]
[]
For class -> _RectangularSliderValueIndicatorPathPainter
[]
[]
For class -> PaddleSliderValueIndicatorShape
[]
[]
For class -> PaddleRangeSliderValueIndicatorShape
[]
[]
For class -> _PaddleSliderValueIndicatorPathPainter
[]
[]
For class -> RangeValues
[this.start, this.end]
[double start, double end]
For class -> RangeLabels
[this.start, this.end]
[String start, String end]
For class -> SnackBarAction
[Key? key, this.textColor, this.disabledTextColor, required this.label, required this.onPressed]
[{Key? key}, {Color? textColor}, {Color? disabledTextColor}, {required String label}, {required void Function() onPressed}]
For class -> _SnackBarActionState
For class -> SnackBar
[Key? key, required this.content, this.backgroundColor, this.elevation, this.margin, this.padding, this.width, this.shape, this.behavior, this.action, this.duration = _snackBarDisplayDuration, this.animation, this.onVisible]
[{Key? key}, {required Widget content}, {Color? backgroundColor}, {double? elevation}, {EdgeInsetsGeometry? margin}, {EdgeInsetsGeometry? padding}, {double? width}, {ShapeBorder? shape}, {SnackBarBehavior? behavior}, {SnackBarAction? action}, {Duration duration = _snackBarDisplayDuration}, {Animation<double>? animation}, {void Function()? onVisible}]
For class -> _SnackBarState
For class -> SnackBarThemeData
[this.backgroundColor, this.actionTextColor, this.disabledActionTextColor, this.contentTextStyle, this.elevation, this.shape, this.behavior]
[{Color? backgroundColor}, {Color? actionTextColor}, {Color? disabledActionTextColor}, {TextStyle? contentTextStyle}, {double? elevation}, {ShapeBorder? shape}, {SnackBarBehavior? behavior}]
For class -> Step
[required this.title, this.subtitle, required this.content, this.state = StepState.indexed, this.isActive = false]
[{required Widget title}, {Widget? subtitle}, {required Widget content}, {StepState state = StepState.indexed}, {bool isActive = false}]
For class -> Stepper
[Key? key, required this.steps, this.physics, this.type = StepperType.vertical, this.currentStep = 0, this.onStepTapped, this.onStepContinue, this.onStepCancel, this.controlsBuilder]
[{Key? key}, {required List<Step> steps}, {ScrollPhysics? physics}, {StepperType type = StepperType.vertical}, {int currentStep = 0}, {void Function(int)? onStepTapped}, {void Function()? onStepContinue}, {void Function()? onStepCancel}, {Widget Function(BuildContext, {void Function()? onStepCancel, void Function()? onStepContinue})? controlsBuilder}]
For class -> _StepperState
For class -> _TrianglePainter
[required this.color]
[{required Color color}]
For class -> Switch
[Key? key, required this.value, required this.onChanged, this.activeColor, this.activeTrackColor, this.inactiveThumbColor, this.inactiveTrackColor, this.activeThumbImage, this.onActiveThumbImageError, this.inactiveThumbImage, this.onInactiveThumbImageError, this.thumbColor, this.trackColor, this.materialTapTargetSize, this.dragStartBehavior = DragStartBehavior.start, this.mouseCursor, this.focusColor, this.hoverColor, this.overlayColor, this.splashRadius, this.focusNode, this.autofocus = false]
[{Key? key}, {required bool value}, {required void Function(bool)? onChanged}, {Color? activeColor}, {Color? activeTrackColor}, {Color? inactiveThumbColor}, {Color? inactiveTrackColor}, {ImageProvider<Object>? activeThumbImage}, {void Function(Object, StackTrace?)? onActiveThumbImageError}, {ImageProvider<Object>? inactiveThumbImage}, {void Function(Object, StackTrace?)? onInactiveThumbImageError}, {MaterialStateProperty<Color?>? thumbColor}, {MaterialStateProperty<Color?>? trackColor}, {MaterialTapTargetSize? materialTapTargetSize}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {MouseCursor? mouseCursor}, {Color? focusColor}, {Color? hoverColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {FocusNode? focusNode}, {bool autofocus = false}]
[Key? key, required this.value, required this.onChanged, this.activeColor, this.activeTrackColor, this.inactiveThumbColor, this.inactiveTrackColor, this.activeThumbImage, this.onActiveThumbImageError, this.inactiveThumbImage, this.onInactiveThumbImageError, this.materialTapTargetSize, this.thumbColor, this.trackColor, this.dragStartBehavior = DragStartBehavior.start, this.mouseCursor, this.focusColor, this.hoverColor, this.overlayColor, this.splashRadius, this.focusNode, this.autofocus = false]
[{Key? key}, {required bool value}, {required void Function(bool)? onChanged}, {Color? activeColor}, {Color? activeTrackColor}, {Color? inactiveThumbColor}, {Color? inactiveTrackColor}, {ImageProvider<Object>? activeThumbImage}, {void Function(Object, StackTrace?)? onActiveThumbImageError}, {ImageProvider<Object>? inactiveThumbImage}, {void Function(Object, StackTrace?)? onInactiveThumbImageError}, {MaterialTapTargetSize? materialTapTargetSize}, {MaterialStateProperty<Color?>? thumbColor}, {MaterialStateProperty<Color?>? trackColor}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {MouseCursor? mouseCursor}, {Color? focusColor}, {Color? hoverColor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}, {FocusNode? focusNode}, {bool autofocus = false}]
For class -> _SwitchState
For class -> _SwitchRenderObjectWidget
[Key? key, required this.value, required this.activeColor, required this.inactiveColor, required this.hoverColor, required this.focusColor, required this.reactionColor, required this.inactiveReactionColor, required this.splashRadius, required this.activeThumbImage, required this.onActiveThumbImageError, required this.inactiveThumbImage, required this.onInactiveThumbImageError, required this.activeTrackColor, required this.inactiveTrackColor, required this.configuration, required this.onChanged, required this.additionalConstraints, required this.dragStartBehavior, required this.hasFocus, required this.hovering, required this.state, required this.surfaceColor]
[{Key? key}, {required bool value}, {required Color activeColor}, {required Color inactiveColor}, {required Color hoverColor}, {required Color focusColor}, {required Color reactionColor}, {required Color inactiveReactionColor}, {required double splashRadius}, {required ImageProvider<Object>? activeThumbImage}, {required void Function(Object, StackTrace?)? onActiveThumbImageError}, {required ImageProvider<Object>? inactiveThumbImage}, {required void Function(Object, StackTrace?)? onInactiveThumbImageError}, {required Color activeTrackColor}, {required Color inactiveTrackColor}, {required ImageConfiguration configuration}, {required void Function(bool)? onChanged}, {required BoxConstraints additionalConstraints}, {required DragStartBehavior dragStartBehavior}, {required bool hasFocus}, {required bool hovering}, {required _SwitchState state}, {required Color surfaceColor}]
For class -> _RenderSwitch
[required bool value, required Color activeColor, required Color inactiveColor, required Color hoverColor, required Color focusColor, required Color reactionColor, required Color inactiveReactionColor, required double splashRadius, required ImageProvider? activeThumbImage, required ImageErrorListener? onActiveThumbImageError, required ImageProvider? inactiveThumbImage, required ImageErrorListener? onInactiveThumbImageError, required Color activeTrackColor, required Color inactiveTrackColor, required ImageConfiguration configuration, required BoxConstraints additionalConstraints, required TextDirection textDirection, required ValueChanged<bool?>? onChanged, required DragStartBehavior dragStartBehavior, required bool hasFocus, required bool hovering, required this.state, required Color surfaceColor]
[{required bool value}, {required Color activeColor}, {required Color inactiveColor}, {required Color hoverColor}, {required Color focusColor}, {required Color reactionColor}, {required Color inactiveReactionColor}, {required double splashRadius}, {required ImageProvider<Object>? activeThumbImage}, {required void Function(Object, StackTrace?)? onActiveThumbImageError}, {required ImageProvider<Object>? inactiveThumbImage}, {required void Function(Object, StackTrace?)? onInactiveThumbImageError}, {required Color activeTrackColor}, {required Color inactiveTrackColor}, {required ImageConfiguration configuration}, {required BoxConstraints additionalConstraints}, {required TextDirection textDirection}, {required void Function(bool?)? onChanged}, {required DragStartBehavior dragStartBehavior}, {required bool hasFocus}, {required bool hovering}, {required _SwitchState state}, {required Color surfaceColor}]
For class -> SwitchListTile
[Key? key, required this.value, required this.onChanged, this.tileColor, this.activeColor, this.activeTrackColor, this.inactiveThumbColor, this.inactiveTrackColor, this.activeThumbImage, this.inactiveThumbImage, this.title, this.subtitle, this.isThreeLine = false, this.dense, this.contentPadding, this.secondary, this.selected = false, this.autofocus = false, this.controlAffinity = ListTileControlAffinity.platform, this.shape, this.selectedTileColor]
[{Key? key}, {required bool value}, {required void Function(bool)? onChanged}, {Color? tileColor}, {Color? activeColor}, {Color? activeTrackColor}, {Color? inactiveThumbColor}, {Color? inactiveTrackColor}, {ImageProvider<Object>? activeThumbImage}, {ImageProvider<Object>? inactiveThumbImage}, {Widget? title}, {Widget? subtitle}, {bool isThreeLine = false}, {bool? dense}, {EdgeInsetsGeometry? contentPadding}, {Widget? secondary}, {bool selected = false}, {bool autofocus = false}, {ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform}, {ShapeBorder? shape}, {Color? selectedTileColor}]
[Key? key, required this.value, required this.onChanged, this.tileColor, this.activeColor, this.activeTrackColor, this.inactiveThumbColor, this.inactiveTrackColor, this.activeThumbImage, this.inactiveThumbImage, this.title, this.subtitle, this.isThreeLine = false, this.dense, this.contentPadding, this.secondary, this.selected = false, this.autofocus = false, this.controlAffinity = ListTileControlAffinity.platform, this.shape, this.selectedTileColor]
[{Key? key}, {required bool value}, {required void Function(bool)? onChanged}, {Color? tileColor}, {Color? activeColor}, {Color? activeTrackColor}, {Color? inactiveThumbColor}, {Color? inactiveTrackColor}, {ImageProvider<Object>? activeThumbImage}, {ImageProvider<Object>? inactiveThumbImage}, {Widget? title}, {Widget? subtitle}, {bool isThreeLine = false}, {bool? dense}, {EdgeInsetsGeometry? contentPadding}, {Widget? secondary}, {bool selected = false}, {bool autofocus = false}, {ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform}, {ShapeBorder? shape}, {Color? selectedTileColor}]
For class -> SwitchThemeData
[this.thumbColor, this.trackColor, this.materialTapTargetSize, this.mouseCursor, this.overlayColor, this.splashRadius]
[{MaterialStateProperty<Color?>? thumbColor}, {MaterialStateProperty<Color?>? trackColor}, {MaterialTapTargetSize? materialTapTargetSize}, {MaterialStateProperty<MouseCursor?>? mouseCursor}, {MaterialStateProperty<Color?>? overlayColor}, {double? splashRadius}]
For class -> _LerpProperties
[this.a, this.b, this.t, this.lerpFunction]
[MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T Function(T?, T?, double) lerpFunction]
For class -> SwitchTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required SwitchThemeData data}, {required Widget child}]
For class -> Tab
[Key? key, this.text, this.icon, this.iconMargin = const EdgeInsets.only(bottom: 10.0), this.child]
[{Key? key}, {String? text}, {Widget? icon}, {EdgeInsetsGeometry iconMargin = const EdgeInsets.only(bottom: 10.0)}, {Widget? child}]
For class -> _TabStyle
[Key? key, required Animation<double> animation, required this.selected, required this.labelColor, required this.unselectedLabelColor, required this.labelStyle, required this.unselectedLabelStyle, required this.child]
[{Key? key}, {required Animation<double> animation}, {required bool selected}, {required Color? labelColor}, {required Color? unselectedLabelColor}, {required TextStyle? labelStyle}, {required TextStyle? unselectedLabelStyle}, {required Widget child}]
For class -> _TabLabelBarRenderer
[List<RenderBox>? children, required Axis direction, required MainAxisSize mainAxisSize, required MainAxisAlignment mainAxisAlignment, required CrossAxisAlignment crossAxisAlignment, required TextDirection textDirection, required VerticalDirection verticalDirection, required this.onPerformLayout]
[{List<RenderBox>? children}, {required Axis direction}, {required MainAxisSize mainAxisSize}, {required MainAxisAlignment mainAxisAlignment}, {required CrossAxisAlignment crossAxisAlignment}, {required TextDirection textDirection}, {required VerticalDirection verticalDirection}, {required void Function(List<double>, TextDirection, double) onPerformLayout}]
For class -> _TabLabelBar
[Key? key, List<Widget> children = const <Widget>[], required this.onPerformLayout]
[{Key? key}, {List<Widget> children = const <Widget>[]}, {required void Function(List<double>, TextDirection, double) onPerformLayout}]
For class -> _IndicatorPainter
[required this.controller, required this.indicator, required this.indicatorSize, required this.tabKeys, required _IndicatorPainter? old, required this.indicatorPadding]
[{required TabController controller}, {required Decoration indicator}, {required TabBarIndicatorSize? indicatorSize}, {required List<GlobalKey<State<StatefulWidget>>> tabKeys}, {required _IndicatorPainter? old}, {required EdgeInsetsGeometry indicatorPadding}]
For class -> _ChangeAnimation
[this.controller]
[TabController controller]
For class -> _DragAnimation
[this.controller, this.index]
[TabController controller, int index]
For class -> _TabBarScrollPosition
[required ScrollPhysics physics, required ScrollContext context, required ScrollPosition? oldPosition, required this.tabBar]
[{required ScrollPhysics physics}, {required ScrollContext context}, {required ScrollPosition? oldPosition}, {required _TabBarState tabBar}]
For class -> _TabBarScrollController
[this.tabBar]
[_TabBarState tabBar]
For class -> TabBar
[Key? key, required this.tabs, this.controller, this.isScrollable = false, this.indicatorColor, this.automaticIndicatorColorAdjustment = true, this.indicatorWeight = 2.0, this.indicatorPadding = EdgeInsets.zero, this.indicator, this.indicatorSize, this.labelColor, this.labelStyle, this.labelPadding, this.unselectedLabelColor, this.unselectedLabelStyle, this.dragStartBehavior = DragStartBehavior.start, this.overlayColor, this.mouseCursor, this.enableFeedback, this.onTap, this.physics]
[{Key? key}, {required List<Widget> tabs}, {TabController? controller}, {bool isScrollable = false}, {Color? indicatorColor}, {bool automaticIndicatorColorAdjustment = true}, {double indicatorWeight = 2.0}, {EdgeInsetsGeometry indicatorPadding = EdgeInsets.zero}, {Decoration? indicator}, {TabBarIndicatorSize? indicatorSize}, {Color? labelColor}, {TextStyle? labelStyle}, {EdgeInsetsGeometry? labelPadding}, {Color? unselectedLabelColor}, {TextStyle? unselectedLabelStyle}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {MaterialStateProperty<Color?>? overlayColor}, {MouseCursor? mouseCursor}, {bool? enableFeedback}, {void Function(int)? onTap}, {ScrollPhysics? physics}]
For class -> _TabBarState
For class -> TabBarView
[Key? key, required this.children, this.controller, this.physics, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required List<Widget> children}, {TabController? controller}, {ScrollPhysics? physics}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _TabBarViewState
For class -> TabPageSelectorIndicator
[Key? key, required this.backgroundColor, required this.borderColor, required this.size]
[{Key? key}, {required Color backgroundColor}, {required Color borderColor}, {required double size}]
For class -> TabPageSelector
[Key? key, this.controller, this.indicatorSize = 12.0, this.color, this.selectedColor]
[{Key? key}, {TabController? controller}, {double indicatorSize = 12.0}, {Color? color}, {Color? selectedColor}]
For class -> TabBarTheme
[this.indicator, this.indicatorSize, this.labelColor, this.labelPadding, this.labelStyle, this.unselectedLabelColor, this.unselectedLabelStyle]
[{Decoration? indicator}, {TabBarIndicatorSize? indicatorSize}, {Color? labelColor}, {EdgeInsetsGeometry? labelPadding}, {TextStyle? labelStyle}, {Color? unselectedLabelColor}, {TextStyle? unselectedLabelStyle}]
For class -> TabController
[int initialIndex = 0, required this.length, required TickerProvider vsync]
[{int initialIndex = 0}, {required int length}, {required TickerProvider vsync}]
[required int index, required int previousIndex, required AnimationController? animationController, required this.length]
[{required int index}, {required int previousIndex}, {required AnimationController? animationController}, {required int length}]
For class -> _TabControllerScope
[Key? key, required this.controller, required this.enabled, required Widget child]
[{Key? key}, {required TabController controller}, {required bool enabled}, {required Widget child}]
For class -> DefaultTabController
[Key? key, required this.length, this.initialIndex = 0, required this.child]
[{Key? key}, {required int length}, {int initialIndex = 0}, {required Widget child}]
For class -> _DefaultTabControllerState
For class -> UnderlineTabIndicator
[this.borderSide = const BorderSide(width: 2.0, color: Colors.white), this.insets = EdgeInsets.zero]
[{BorderSide borderSide = const BorderSide(width: 2.0, color: Colors.white)}, {EdgeInsetsGeometry insets = EdgeInsets.zero}]
For class -> _UnderlinePainter
[this.decoration, VoidCallback? onChanged]
[UnderlineTabIndicator decoration, void Function()? onChanged]
For class -> TextButton
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip clipBehavior = Clip.none, required Widget child]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool autofocus = false}, {Clip clipBehavior = Clip.none}, {required Widget child}]
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _TextButtonDefaultForeground
[this.primary, this.onSurface]
[Color? primary, Color? onSurface]
For class -> _TextButtonDefaultOverlay
[this.primary]
[Color primary]
For class -> _TextButtonDefaultMouseCursor
[this.enabledCursor, this.disabledCursor]
[MouseCursor enabledCursor, MouseCursor disabledCursor]
For class -> _TextButtonWithIcon
[Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, required Widget icon, required Widget label]
[{Key? key}, {required void Function()? onPressed}, {void Function()? onLongPress}, {ButtonStyle? style}, {FocusNode? focusNode}, {bool? autofocus}, {Clip? clipBehavior}, {required Widget icon}, {required Widget label}]
For class -> _TextButtonWithIconChild
[Key? key, required this.label, required this.icon]
[{Key? key}, {required Widget label}, {required Widget icon}]
For class -> TextButtonThemeData
[this.style]
[{ButtonStyle? style}]
For class -> TextButtonTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required TextButtonThemeData data}, {required Widget child}]
For class -> _TextFieldSelectionGestureDetectorBuilder
[required _TextFieldState state]
[{required _TextFieldState state}]
For class -> TextField
[Key? key, this.controller, this.focusNode, this.decoration = const InputDecoration(), TextInputType? keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.style, this.strutStyle, this.textAlign = TextAlign.start, this.textAlignVertical, this.textDirection, this.readOnly = false, ToolbarOptions? toolbarOptions, this.showCursor, this.autofocus = false, this.obscuringCharacter = '•', this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, this.enableSuggestions = true, this.maxLines = 1, this.minLines, this.expands = false, this.maxLength, @Deprecated('Use maxLengthEnforcement parameter which provides more specific ' 'behavior related to the maxLength limit. ' 'This feature was deprecated after v1.25.0-5.0.pre.') this.maxLengthEnforced = true, this.maxLengthEnforcement, this.onChanged, this.onEditingComplete, this.onSubmitted, this.onAppPrivateCommand, this.inputFormatters, this.enabled, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorColor, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.selectionControls, this.onTap, this.mouseCursor, this.buildCounter, this.scrollController, this.scrollPhysics, this.autofillHints, this.restorationId]
[{Key? key}, {TextEditingController? controller}, {FocusNode? focusNode}, {InputDecoration? decoration = const InputDecoration()}, {TextInputType? keyboardType}, {TextInputAction? textInputAction}, {TextCapitalization textCapitalization = TextCapitalization.none}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign textAlign = TextAlign.start}, {TextAlignVertical? textAlignVertical}, {TextDirection? textDirection}, {bool readOnly = false}, {ToolbarOptions? toolbarOptions}, {bool? showCursor}, {bool autofocus = false}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {int? maxLength}, {bool maxLengthEnforced = true}, {MaxLengthEnforcement? maxLengthEnforcement}, {void Function(String)? onChanged}, {void Function()? onEditingComplete}, {void Function(String)? onSubmitted}, {void Function(String, Map<String, dynamic>)? onAppPrivateCommand}, {List<TextInputFormatter>? inputFormatters}, {bool? enabled}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius? cursorRadius}, {Color? cursorColor}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {Brightness? keyboardAppearance}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {void Function()? onTap}, {MouseCursor? mouseCursor}, {Widget? Function(BuildContext, {required int currentLength, required bool isFocused, required int? maxLength})? buildCounter}, {ScrollController? scrollController}, {ScrollPhysics? scrollPhysics}, {Iterable<String>? autofillHints}, {String? restorationId}]
For class -> _TextFieldState
For class -> TextFormField
[Key? key, this.controller, String? initialValue, FocusNode? focusNode, InputDecoration? decoration = const InputDecoration(), TextInputType? keyboardType, TextCapitalization textCapitalization = TextCapitalization.none, TextInputAction? textInputAction, TextStyle? style, StrutStyle? strutStyle, TextDirection? textDirection, TextAlign textAlign = TextAlign.start, TextAlignVertical? textAlignVertical, bool autofocus = false, bool readOnly = false, ToolbarOptions? toolbarOptions, bool? showCursor, String obscuringCharacter = '•', bool obscureText = false, bool autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, bool enableSuggestions = true, @Deprecated('Use autovalidateMode parameter which provide more specific ' 'behaviour related to auto validation. ' 'This feature was deprecated after v1.19.0.') bool autovalidate = false, @Deprecated('Use maxLengthEnforcement parameter which provides more specific ' 'behavior related to the maxLength limit. ' 'This feature was deprecated after v1.25.0-5.0.pre.') bool maxLengthEnforced = true, MaxLengthEnforcement? maxLengthEnforcement, int? maxLines = 1, int? minLines, bool expands = false, int? maxLength, ValueChanged<String>? onChanged, GestureTapCallback? onTap, VoidCallback? onEditingComplete, ValueChanged<String>? onFieldSubmitted, FormFieldSetter<String>? onSaved, FormFieldValidator<String>? validator, List<TextInputFormatter>? inputFormatters, bool? enabled, double cursorWidth = 2.0, double? cursorHeight, Radius? cursorRadius, Color? cursorColor, Brightness? keyboardAppearance, EdgeInsets scrollPadding = const EdgeInsets.all(20.0), bool enableInteractiveSelection = true, TextSelectionControls? selectionControls, InputCounterWidgetBuilder? buildCounter, ScrollPhysics? scrollPhysics, Iterable<String>? autofillHints, AutovalidateMode? autovalidateMode]
[{Key? key}, {TextEditingController? controller}, {String? initialValue}, {FocusNode? focusNode}, {InputDecoration? decoration = const InputDecoration()}, {TextInputType? keyboardType}, {TextCapitalization textCapitalization = TextCapitalization.none}, {TextInputAction? textInputAction}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextDirection? textDirection}, {TextAlign textAlign = TextAlign.start}, {TextAlignVertical? textAlignVertical}, {bool autofocus = false}, {bool readOnly = false}, {ToolbarOptions? toolbarOptions}, {bool? showCursor}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {bool autovalidate = false}, {bool maxLengthEnforced = true}, {MaxLengthEnforcement? maxLengthEnforcement}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {int? maxLength}, {void Function(String)? onChanged}, {void Function()? onTap}, {void Function()? onEditingComplete}, {void Function(String)? onFieldSubmitted}, {void Function(String?)? onSaved}, {String? Function(String?)? validator}, {List<TextInputFormatter>? inputFormatters}, {bool? enabled}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius? cursorRadius}, {Color? cursorColor}, {Brightness? keyboardAppearance}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {bool enableInteractiveSelection = true}, {TextSelectionControls? selectionControls}, {Widget? Function(BuildContext, {required int currentLength, required bool isFocused, required int? maxLength})? buildCounter}, {ScrollPhysics? scrollPhysics}, {Iterable<String>? autofillHints}, {AutovalidateMode? autovalidateMode}]
For class -> _TextFormFieldState
For class -> MaterialTextSelectionControls
For class -> _TextSelectionToolbarItemData
[required this.label, required this.onPressed]
[{required String label}, {required void Function() onPressed}]
For class -> _TextSelectionControlsToolbar
[Key? key, required this.clipboardStatus, required this.delegate, required this.endpoints, required this.globalEditableRegion, required this.handleCut, required this.handleCopy, required this.handlePaste, required this.handleSelectAll, required this.selectionMidpoint, required this.textLineHeight]
[{Key? key}, {required ClipboardStatusNotifier clipboardStatus}, {required TextSelectionDelegate delegate}, {required List<TextSelectionPoint> endpoints}, {required Rect globalEditableRegion}, {required void Function()? handleCut}, {required void Function()? handleCopy}, {required void Function()? handlePaste}, {required void Function()? handleSelectAll}, {required Offset selectionMidpoint}, {required double textLineHeight}]
For class -> _TextSelectionControlsToolbarState
For class -> _TextSelectionHandlePainter
[required this.color]
[{required Color color}]
For class -> TextSelectionThemeData
[this.cursorColor, this.selectionColor, this.selectionHandleColor]
[{Color? cursorColor}, {Color? selectionColor}, {Color? selectionHandleColor}]
For class -> TextSelectionTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required TextSelectionThemeData data}, {required Widget child}]
For class -> TextSelectionToolbar
[Key? key, required this.anchorAbove, required this.anchorBelow, this.toolbarBuilder = _defaultToolbarBuilder, required this.children]
[{Key? key}, {required Offset anchorAbove}, {required Offset anchorBelow}, {Widget Function(BuildContext, Widget) toolbarBuilder = _defaultToolbarBuilder}, {required List<Widget> children}]
For class -> _TextSelectionToolbarOverflowable
[Key? key, required this.isAbove, required this.toolbarBuilder, required this.children]
[{Key? key}, {required bool isAbove}, {required Widget Function(BuildContext, Widget) toolbarBuilder}, {required List<Widget> children}]
For class -> _TextSelectionToolbarOverflowableState
For class -> _TextSelectionToolbarTrailingEdgeAlign
[Key? key, required Widget child, required this.overflowOpen, required this.textDirection]
[{Key? key}, {required Widget child}, {required bool overflowOpen}, {required TextDirection textDirection}]
For class -> _TextSelectionToolbarTrailingEdgeAlignRenderBox
[required bool overflowOpen, required TextDirection textDirection]
[{required bool overflowOpen}, {required TextDirection textDirection}]
For class -> _TextSelectionToolbarItemsLayout
[Key? key, required this.isAbove, required this.overflowOpen, required List<Widget> children]
[{Key? key}, {required bool isAbove}, {required bool overflowOpen}, {required List<Widget> children}]
For class -> _TextSelectionToolbarItemsLayoutElement
[MultiChildRenderObjectWidget widget]
[MultiChildRenderObjectWidget widget]
For class -> _RenderTextSelectionToolbarItemsLayout
[required bool isAbove, required bool overflowOpen]
[{required bool isAbove}, {required bool overflowOpen}]
For class -> _TextSelectionToolbarContainer
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> _TextSelectionToolbarOverflowButton
[Key? key, required this.icon, this.onPressed, this.tooltip]
[{Key? key}, {required Icon icon}, {void Function()? onPressed}, {String? tooltip}]
For class -> TextSelectionToolbarTextButton
[Key? key, required this.child, required this.padding, this.onPressed]
[{Key? key}, {required Widget child}, {required EdgeInsets padding}, {void Function()? onPressed}]
For class -> TextTheme
[TextStyle? headline1, TextStyle? headline2, TextStyle? headline3, TextStyle? headline4, TextStyle? headline5, TextStyle? headline6, TextStyle? subtitle1, TextStyle? subtitle2, TextStyle? bodyText1, TextStyle? bodyText2, this.caption, this.button, this.overline, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline1. ' 'This feature was deprecated after v1.13.8.') TextStyle? display4, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline2. ' 'This feature was deprecated after v1.13.8.') TextStyle? display3, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline3. ' 'This feature was deprecated after v1.13.8.') TextStyle? display2, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline4. ' 'This feature was deprecated after v1.13.8.') TextStyle? display1, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline5. ' 'This feature was deprecated after v1.13.8.') TextStyle? headline, @Deprecated('This is the term used in the 2014 version of material design. The modern term is headline6. ' 'This feature was deprecated after v1.13.8.') TextStyle? title, @Deprecated('This is the term used in the 2014 version of material design. The modern term is subtitle1. ' 'This feature was deprecated after v1.13.8.') TextStyle? subhead, @Deprecated('This is the term used in the 2014 version of material design. The modern term is subtitle2. ' 'This feature was deprecated after v1.13.8.') TextStyle? subtitle, @Deprecated('This is the term used in the 2014 version of material design. The modern term is bodyText1. ' 'This feature was deprecated after v1.13.8.') TextStyle? body2, @Deprecated('This is the term used in the 2014 version of material design. The modern term is bodyText2. ' 'This feature was deprecated after v1.13.8.') TextStyle? body1]
[{TextStyle? headline1}, {TextStyle? headline2}, {TextStyle? headline3}, {TextStyle? headline4}, {TextStyle? headline5}, {TextStyle? headline6}, {TextStyle? subtitle1}, {TextStyle? subtitle2}, {TextStyle? bodyText1}, {TextStyle? bodyText2}, {TextStyle? caption}, {TextStyle? button}, {TextStyle? overline}, {TextStyle? display4}, {TextStyle? display3}, {TextStyle? display2}, {TextStyle? display1}, {TextStyle? headline}, {TextStyle? title}, {TextStyle? subhead}, {TextStyle? subtitle}, {TextStyle? body2}, {TextStyle? body1}]
For class -> Theme
[Key? key, required this.data, required this.child]
[{Key? key}, {required ThemeData data}, {required Widget child}]
For class -> _InheritedTheme
[Key? key, required this.theme, required Widget child]
[{Key? key}, {required Theme theme}, {required Widget child}]
For class -> ThemeDataTween
[ThemeData? begin, ThemeData? end]
[{ThemeData? begin}, {ThemeData? end}]
For class -> AnimatedTheme
[Key? key, required this.data, Curve curve = Curves.linear, Duration duration = kThemeAnimationDuration, VoidCallback? onEnd, required this.child]
[{Key? key}, {required ThemeData data}, {Curve curve = Curves.linear}, {Duration duration = kThemeAnimationDuration}, {void Function()? onEnd}, {required Widget child}]
For class -> _AnimatedThemeState
For class -> ThemeData
[Brightness? brightness, VisualDensity? visualDensity, MaterialColor? primarySwatch, Color? primaryColor, Brightness? primaryColorBrightness, Color? primaryColorLight, Color? primaryColorDark, Color? accentColor, Brightness? accentColorBrightness, Color? canvasColor, Color? shadowColor, Color? scaffoldBackgroundColor, Color? bottomAppBarColor, Color? cardColor, Color? dividerColor, Color? focusColor, Color? hoverColor, Color? highlightColor, Color? splashColor, InteractiveInkFeatureFactory? splashFactory, Color? selectedRowColor, Color? unselectedWidgetColor, Color? disabledColor, Color? buttonColor, ButtonThemeData? buttonTheme, ToggleButtonsThemeData? toggleButtonsTheme, Color? secondaryHeaderColor, @Deprecated('Use TextSelectionThemeData.selectionColor instead. ' 'This feature was deprecated after v1.23.0-4.0.pre.') Color? textSelectionColor, @Deprecated('Use TextSelectionThemeData.cursorColor instead. ' 'This feature was deprecated after v1.23.0-4.0.pre.') Color? cursorColor, @Deprecated('Use TextSelectionThemeData.selectionHandleColor instead. ' 'This feature was deprecated after v1.23.0-4.0.pre.') Color? textSelectionHandleColor, Color? backgroundColor, Color? dialogBackgroundColor, Color? indicatorColor, Color? hintColor, Color? errorColor, Color? toggleableActiveColor, String? fontFamily, TextTheme? textTheme, TextTheme? primaryTextTheme, TextTheme? accentTextTheme, InputDecorationTheme? inputDecorationTheme, IconThemeData? iconTheme, IconThemeData? primaryIconTheme, IconThemeData? accentIconTheme, SliderThemeData? sliderTheme, TabBarTheme? tabBarTheme, TooltipThemeData? tooltipTheme, CardTheme? cardTheme, ChipThemeData? chipTheme, TargetPlatform? platform, MaterialTapTargetSize? materialTapTargetSize, bool? applyElevationOverlayColor, PageTransitionsTheme? pageTransitionsTheme, AppBarTheme? appBarTheme, ScrollbarThemeData? scrollbarTheme, BottomAppBarTheme? bottomAppBarTheme, ColorScheme? colorScheme, DialogTheme? dialogTheme, FloatingActionButtonThemeData? floatingActionButtonTheme, NavigationRailThemeData? navigationRailTheme, Typography? typography, NoDefaultCupertinoThemeData? cupertinoOverrideTheme, SnackBarThemeData? snackBarTheme, BottomSheetThemeData? bottomSheetTheme, PopupMenuThemeData? popupMenuTheme, MaterialBannerThemeData? bannerTheme, DividerThemeData? dividerTheme, ButtonBarThemeData? buttonBarTheme, BottomNavigationBarThemeData? bottomNavigationBarTheme, TimePickerThemeData? timePickerTheme, TextButtonThemeData? textButtonTheme, ElevatedButtonThemeData? elevatedButtonTheme, OutlinedButtonThemeData? outlinedButtonTheme, TextSelectionThemeData? textSelectionTheme, DataTableThemeData? dataTableTheme, CheckboxThemeData? checkboxTheme, RadioThemeData? radioTheme, SwitchThemeData? switchTheme, bool? fixTextFieldOutlineLabel, @Deprecated('No longer used by the framework, please remove any reference to it. ' 'This feature was deprecated after v1.23.0-4.0.pre.') bool? useTextSelectionTheme]
[{Brightness? brightness}, {VisualDensity? visualDensity}, {MaterialColor? primarySwatch}, {Color? primaryColor}, {Brightness? primaryColorBrightness}, {Color? primaryColorLight}, {Color? primaryColorDark}, {Color? accentColor}, {Brightness? accentColorBrightness}, {Color? canvasColor}, {Color? shadowColor}, {Color? scaffoldBackgroundColor}, {Color? bottomAppBarColor}, {Color? cardColor}, {Color? dividerColor}, {Color? focusColor}, {Color? hoverColor}, {Color? highlightColor}, {Color? splashColor}, {InteractiveInkFeatureFactory? splashFactory}, {Color? selectedRowColor}, {Color? unselectedWidgetColor}, {Color? disabledColor}, {Color? buttonColor}, {ButtonThemeData? buttonTheme}, {ToggleButtonsThemeData? toggleButtonsTheme}, {Color? secondaryHeaderColor}, {Color? textSelectionColor}, {Color? cursorColor}, {Color? textSelectionHandleColor}, {Color? backgroundColor}, {Color? dialogBackgroundColor}, {Color? indicatorColor}, {Color? hintColor}, {Color? errorColor}, {Color? toggleableActiveColor}, {String? fontFamily}, {TextTheme? textTheme}, {TextTheme? primaryTextTheme}, {TextTheme? accentTextTheme}, {InputDecorationTheme? inputDecorationTheme}, {IconThemeData? iconTheme}, {IconThemeData? primaryIconTheme}, {IconThemeData? accentIconTheme}, {SliderThemeData? sliderTheme}, {TabBarTheme? tabBarTheme}, {TooltipThemeData? tooltipTheme}, {CardTheme? cardTheme}, {ChipThemeData? chipTheme}, {TargetPlatform? platform}, {MaterialTapTargetSize? materialTapTargetSize}, {bool? applyElevationOverlayColor}, {PageTransitionsTheme? pageTransitionsTheme}, {AppBarTheme? appBarTheme}, {ScrollbarThemeData? scrollbarTheme}, {BottomAppBarTheme? bottomAppBarTheme}, {ColorScheme? colorScheme}, {DialogTheme? dialogTheme}, {FloatingActionButtonThemeData? floatingActionButtonTheme}, {NavigationRailThemeData? navigationRailTheme}, {Typography? typography}, {NoDefaultCupertinoThemeData? cupertinoOverrideTheme}, {SnackBarThemeData? snackBarTheme}, {BottomSheetThemeData? bottomSheetTheme}, {PopupMenuThemeData? popupMenuTheme}, {MaterialBannerThemeData? bannerTheme}, {DividerThemeData? dividerTheme}, {ButtonBarThemeData? buttonBarTheme}, {BottomNavigationBarThemeData? bottomNavigationBarTheme}, {TimePickerThemeData? timePickerTheme}, {TextButtonThemeData? textButtonTheme}, {ElevatedButtonThemeData? elevatedButtonTheme}, {OutlinedButtonThemeData? outlinedButtonTheme}, {TextSelectionThemeData? textSelectionTheme}, {DataTableThemeData? dataTableTheme}, {CheckboxThemeData? checkboxTheme}, {RadioThemeData? radioTheme}, {SwitchThemeData? switchTheme}, {bool? fixTextFieldOutlineLabel}, {bool? useTextSelectionTheme}]
[required this.visualDensity, required this.primaryColor, required this.primaryColorBrightness, required this.primaryColorLight, required this.primaryColorDark, required this.canvasColor, required this.shadowColor, required this.accentColor, required this.accentColorBrightness, required this.scaffoldBackgroundColor, required this.bottomAppBarColor, required this.cardColor, required this.dividerColor, required this.focusColor, required this.hoverColor, required this.highlightColor, required this.splashColor, required this.splashFactory, required this.selectedRowColor, required this.unselectedWidgetColor, required this.disabledColor, required this.buttonTheme, required this.buttonColor, required this.toggleButtonsTheme, required this.secondaryHeaderColor, required this.textSelectionColor, required this.cursorColor, required this.textSelectionHandleColor, required this.backgroundColor, required this.dialogBackgroundColor, required this.indicatorColor, required this.hintColor, required this.errorColor, required this.toggleableActiveColor, required this.textTheme, required this.primaryTextTheme, required this.accentTextTheme, required this.inputDecorationTheme, required this.iconTheme, required this.primaryIconTheme, required this.accentIconTheme, required this.sliderTheme, required this.tabBarTheme, required this.tooltipTheme, required this.cardTheme, required this.chipTheme, required this.platform, required this.materialTapTargetSize, required this.applyElevationOverlayColor, required this.pageTransitionsTheme, required this.appBarTheme, required this.scrollbarTheme, required this.bottomAppBarTheme, required this.colorScheme, required this.dialogTheme, required this.floatingActionButtonTheme, required this.navigationRailTheme, required this.typography, required this.cupertinoOverrideTheme, required this.snackBarTheme, required this.bottomSheetTheme, required this.popupMenuTheme, required this.bannerTheme, required this.dividerTheme, required this.buttonBarTheme, required this.bottomNavigationBarTheme, required this.timePickerTheme, required this.textButtonTheme, required this.elevatedButtonTheme, required this.outlinedButtonTheme, required this.textSelectionTheme, required this.dataTableTheme, required this.checkboxTheme, required this.radioTheme, required this.switchTheme, required this.fixTextFieldOutlineLabel, required this.useTextSelectionTheme]
[{required VisualDensity visualDensity}, {required Color primaryColor}, {required Brightness primaryColorBrightness}, {required Color primaryColorLight}, {required Color primaryColorDark}, {required Color canvasColor}, {required Color shadowColor}, {required Color accentColor}, {required Brightness accentColorBrightness}, {required Color scaffoldBackgroundColor}, {required Color bottomAppBarColor}, {required Color cardColor}, {required Color dividerColor}, {required Color focusColor}, {required Color hoverColor}, {required Color highlightColor}, {required Color splashColor}, {required InteractiveInkFeatureFactory splashFactory}, {required Color selectedRowColor}, {required Color unselectedWidgetColor}, {required Color disabledColor}, {required ButtonThemeData buttonTheme}, {required Color buttonColor}, {required ToggleButtonsThemeData toggleButtonsTheme}, {required Color secondaryHeaderColor}, {required Color textSelectionColor}, {required Color cursorColor}, {required Color textSelectionHandleColor}, {required Color backgroundColor}, {required Color dialogBackgroundColor}, {required Color indicatorColor}, {required Color hintColor}, {required Color errorColor}, {required Color toggleableActiveColor}, {required TextTheme textTheme}, {required TextTheme primaryTextTheme}, {required TextTheme accentTextTheme}, {required InputDecorationTheme inputDecorationTheme}, {required IconThemeData iconTheme}, {required IconThemeData primaryIconTheme}, {required IconThemeData accentIconTheme}, {required SliderThemeData sliderTheme}, {required TabBarTheme tabBarTheme}, {required TooltipThemeData tooltipTheme}, {required CardTheme cardTheme}, {required ChipThemeData chipTheme}, {required TargetPlatform platform}, {required MaterialTapTargetSize materialTapTargetSize}, {required bool applyElevationOverlayColor}, {required PageTransitionsTheme pageTransitionsTheme}, {required AppBarTheme appBarTheme}, {required ScrollbarThemeData scrollbarTheme}, {required BottomAppBarTheme bottomAppBarTheme}, {required ColorScheme colorScheme}, {required DialogTheme dialogTheme}, {required FloatingActionButtonThemeData floatingActionButtonTheme}, {required NavigationRailThemeData navigationRailTheme}, {required Typography typography}, {required NoDefaultCupertinoThemeData? cupertinoOverrideTheme}, {required SnackBarThemeData snackBarTheme}, {required BottomSheetThemeData bottomSheetTheme}, {required PopupMenuThemeData popupMenuTheme}, {required MaterialBannerThemeData bannerTheme}, {required DividerThemeData dividerTheme}, {required ButtonBarThemeData buttonBarTheme}, {required BottomNavigationBarThemeData bottomNavigationBarTheme}, {required TimePickerThemeData timePickerTheme}, {required TextButtonThemeData textButtonTheme}, {required ElevatedButtonThemeData elevatedButtonTheme}, {required OutlinedButtonThemeData outlinedButtonTheme}, {required TextSelectionThemeData textSelectionTheme}, {required DataTableThemeData dataTableTheme}, {required CheckboxThemeData checkboxTheme}, {required RadioThemeData radioTheme}, {required SwitchThemeData switchTheme}, {required bool fixTextFieldOutlineLabel}, {required bool useTextSelectionTheme}]
[required ColorScheme colorScheme, TextTheme? textTheme]
[{required ColorScheme colorScheme}, {TextTheme? textTheme}]
[]
[]
[]
[]
[]
[]
For class -> MaterialBasedCupertinoThemeData
[required ThemeData materialTheme]
[{required ThemeData materialTheme}]
[this._materialTheme, this._cupertinoOverrideTheme]
[ThemeData _materialTheme, NoDefaultCupertinoThemeData _cupertinoOverrideTheme]
For class -> _IdentityThemeDataCacheKey
[this.baseTheme, this.localTextGeometry]
[ThemeData baseTheme, TextTheme localTextGeometry]
For class -> _FifoCache
[this._maximumSize]
[int _maximumSize]
For class -> VisualDensity
[this.horizontal = 0.0, this.vertical = 0.0]
[{double horizontal = 0.0}, {double vertical = 0.0}]
For class -> TimeOfDay
[required this.hour, required this.minute]
[{required int hour}, {required int minute}]
[DateTime time]
[DateTime time]
[]
[]
For class -> _TimePickerFragmentContext
[required this.selectedTime, required this.mode, required this.onTimeChange, required this.onModeChange, required this.onHourDoubleTapped, required this.onMinuteDoubleTapped, required this.use24HourDials]
[{required TimeOfDay selectedTime}, {required _TimePickerMode mode}, {required void Function(TimeOfDay) onTimeChange}, {required void Function(_TimePickerMode) onModeChange}, {required void Function() onHourDoubleTapped}, {required void Function() onMinuteDoubleTapped}, {required bool use24HourDials}]
For class -> _TimePickerHeader
[required this.selectedTime, required this.mode, required this.orientation, required this.onModeChanged, required this.onChanged, required this.onHourDoubleTapped, required this.onMinuteDoubleTapped, required this.use24HourDials, required this.helpText]
[{required TimeOfDay selectedTime}, {required _TimePickerMode mode}, {required Orientation orientation}, {required void Function(_TimePickerMode) onModeChanged}, {required void Function(TimeOfDay) onChanged}, {required void Function() onHourDoubleTapped}, {required void Function() onMinuteDoubleTapped}, {required bool use24HourDials}, {required String? helpText}]
For class -> _HourMinuteControl
[required this.text, required this.onTap, required this.onDoubleTap, required this.isSelected]
[{required String text}, {required void Function() onTap}, {required void Function() onDoubleTap}, {required bool isSelected}]
For class -> _HourControl
[required this.fragmentContext]
[{required _TimePickerFragmentContext fragmentContext}]
For class -> _StringFragment
[required this.timeOfDayFormat]
[{required TimeOfDayFormat timeOfDayFormat}]
For class -> _MinuteControl
[required this.fragmentContext]
[{required _TimePickerFragmentContext fragmentContext}]
For class -> _DayPeriodControl
[required this.selectedTime, required this.onChanged, required this.orientation]
[{required TimeOfDay selectedTime}, {required void Function(TimeOfDay) onChanged}, {required Orientation orientation}]
For class -> _DayPeriodInputPadding
[Key? key, required Widget child, required this.minSize, required this.orientation]
[{Key? key}, {required Widget child}, {required Size minSize}, {required Orientation orientation}]
For class -> _RenderInputPadding
[this._minSize, this.orientation, RenderBox? child]
[Size _minSize, Orientation orientation, [RenderBox? child]]
For class -> _TappableLabel
[required this.value, required this.painter, required this.onTap]
[{required int value}, {required TextPainter painter}, {required void Function() onTap}]
For class -> _DialPainter
[required this.primaryLabels, required this.secondaryLabels, required this.backgroundColor, required this.accentColor, required this.dotColor, required this.theta, required this.textDirection, required this.selectedValue]
[{required List<_TappableLabel> primaryLabels}, {required List<_TappableLabel> secondaryLabels}, {required Color backgroundColor}, {required Color accentColor}, {required Color dotColor}, {required double theta}, {required TextDirection textDirection}, {required int selectedValue}]
For class -> _Dial
[required this.selectedTime, required this.mode, required this.use24HourDials, required this.onChanged, required this.onHourSelected]
[{required TimeOfDay selectedTime}, {required _TimePickerMode mode}, {required bool use24HourDials}, {required void Function(TimeOfDay)? onChanged}, {required void Function()? onHourSelected}]
For class -> _DialState
For class -> _TimePickerInput
[Key? key, required this.initialSelectedTime, required this.helpText, required this.autofocusHour, required this.autofocusMinute, required this.onChanged]
[{Key? key}, {required TimeOfDay initialSelectedTime}, {required String? helpText}, {required bool? autofocusHour}, {required bool? autofocusMinute}, {required void Function(TimeOfDay) onChanged}]
For class -> _TimePickerInputState
For class -> _HourTextField
[Key? key, required this.selectedTime, required this.style, required this.autofocus, required this.validator, required this.onSavedSubmitted, required this.onChanged]
[{Key? key}, {required TimeOfDay selectedTime}, {required TextStyle style}, {required bool? autofocus}, {required String? Function(String?) validator}, {required void Function(String?) onSavedSubmitted}, {required void Function(String) onChanged}]
For class -> _MinuteTextField
[Key? key, required this.selectedTime, required this.style, required this.autofocus, required this.validator, required this.onSavedSubmitted]
[{Key? key}, {required TimeOfDay selectedTime}, {required TextStyle style}, {required bool? autofocus}, {required String? Function(String?) validator}, {required void Function(String?) onSavedSubmitted}]
For class -> _HourMinuteTextField
[Key? key, required this.selectedTime, required this.isHour, required this.autofocus, required this.style, required this.semanticHintText, required this.validator, required this.onSavedSubmitted, this.onChanged]
[{Key? key}, {required TimeOfDay selectedTime}, {required bool isHour}, {required bool? autofocus}, {required TextStyle style}, {required String semanticHintText}, {required String? Function(String?) validator}, {required void Function(String?) onSavedSubmitted}, {void Function(String)? onChanged}]
For class -> _HourMinuteTextFieldState
For class -> _TimePickerDialog
[Key? key, required this.initialTime, required this.cancelText, required this.confirmText, required this.helpText, this.initialEntryMode = TimePickerEntryMode.dial]
[{Key? key}, {required TimeOfDay initialTime}, {required String? cancelText}, {required String? confirmText}, {required String? helpText}, {TimePickerEntryMode initialEntryMode = TimePickerEntryMode.dial}]
For class -> _TimePickerDialogState
For class -> TimePickerThemeData
[this.backgroundColor, this.hourMinuteTextColor, this.hourMinuteColor, this.dayPeriodTextColor, this.dayPeriodColor, this.dialHandColor, this.dialBackgroundColor, this.dialTextColor, this.entryModeIconColor, this.hourMinuteTextStyle, this.dayPeriodTextStyle, this.helpTextStyle, this.shape, this.hourMinuteShape, this.dayPeriodShape, this.dayPeriodBorderSide, this.inputDecorationTheme]
[{Color? backgroundColor}, {Color? hourMinuteTextColor}, {Color? hourMinuteColor}, {Color? dayPeriodTextColor}, {Color? dayPeriodColor}, {Color? dialHandColor}, {Color? dialBackgroundColor}, {Color? dialTextColor}, {Color? entryModeIconColor}, {TextStyle? hourMinuteTextStyle}, {TextStyle? dayPeriodTextStyle}, {TextStyle? helpTextStyle}, {ShapeBorder? shape}, {ShapeBorder? hourMinuteShape}, {OutlinedBorder? dayPeriodShape}, {BorderSide? dayPeriodBorderSide}, {InputDecorationTheme? inputDecorationTheme}]
For class -> TimePickerTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required TimePickerThemeData data}, {required Widget child}]
For class -> RenderToggleable
[required bool? value, bool tristate = false, required Color activeColor, required Color inactiveColor, Color? hoverColor, Color? focusColor, Color? reactionColor, Color? inactiveReactionColor, required double splashRadius, ValueChanged<bool?>? onChanged, required BoxConstraints additionalConstraints, required TickerProvider vsync, bool hasFocus = false, bool hovering = false]
[{required bool? value}, {bool tristate = false}, {required Color activeColor}, {required Color inactiveColor}, {Color? hoverColor}, {Color? focusColor}, {Color? reactionColor}, {Color? inactiveReactionColor}, {required double splashRadius}, {void Function(bool?)? onChanged}, {required BoxConstraints additionalConstraints}, {required TickerProvider vsync}, {bool hasFocus = false}, {bool hovering = false}]
For class -> ToggleButtons
[Key? key, required this.children, required this.isSelected, this.onPressed, this.mouseCursor, this.textStyle, this.constraints, this.color, this.selectedColor, this.disabledColor, this.fillColor, this.focusColor, this.highlightColor, this.hoverColor, this.splashColor, this.focusNodes, this.renderBorder = true, this.borderColor, this.selectedBorderColor, this.disabledBorderColor, this.borderRadius, this.borderWidth, this.direction = Axis.horizontal, this.verticalDirection = VerticalDirection.down]
[{Key? key}, {required List<Widget> children}, {required List<bool> isSelected}, {void Function(int)? onPressed}, {MouseCursor? mouseCursor}, {TextStyle? textStyle}, {BoxConstraints? constraints}, {Color? color}, {Color? selectedColor}, {Color? disabledColor}, {Color? fillColor}, {Color? focusColor}, {Color? highlightColor}, {Color? hoverColor}, {Color? splashColor}, {List<FocusNode>? focusNodes}, {bool renderBorder = true}, {Color? borderColor}, {Color? selectedBorderColor}, {Color? disabledBorderColor}, {BorderRadius? borderRadius}, {double? borderWidth}, {Axis direction = Axis.horizontal}, {VerticalDirection verticalDirection = VerticalDirection.down}]
For class -> _ToggleButton
[Key? key, this.selected = false, this.textStyle, this.constraints, this.color, this.selectedColor, this.disabledColor, required this.fillColor, required this.focusColor, required this.highlightColor, required this.hoverColor, required this.splashColor, this.focusNode, this.onPressed, this.mouseCursor, required this.leadingBorderSide, required this.borderSide, required this.trailingBorderSide, required this.borderRadius, required this.clipRadius, required this.isFirstButton, required this.isLastButton, required this.direction, required this.verticalDirection, required this.child]
[{Key? key}, {bool selected = false}, {TextStyle? textStyle}, {BoxConstraints? constraints}, {Color? color}, {Color? selectedColor}, {Color? disabledColor}, {required Color? fillColor}, {required Color? focusColor}, {required Color? highlightColor}, {required Color? hoverColor}, {required Color? splashColor}, {FocusNode? focusNode}, {void Function()? onPressed}, {MouseCursor? mouseCursor}, {required BorderSide leadingBorderSide}, {required BorderSide borderSide}, {required BorderSide trailingBorderSide}, {required BorderRadius borderRadius}, {required BorderRadius clipRadius}, {required bool isFirstButton}, {required bool isLastButton}, {required Axis direction}, {required VerticalDirection verticalDirection}, {required Widget child}]
For class -> _SelectToggleButton
[Key? key, required Widget child, required this.leadingBorderSide, required this.borderSide, required this.trailingBorderSide, required this.borderRadius, required this.isFirstButton, required this.isLastButton, required this.direction, required this.verticalDirection]
[{Key? key}, {required Widget child}, {required BorderSide leadingBorderSide}, {required BorderSide borderSide}, {required BorderSide trailingBorderSide}, {required BorderRadius borderRadius}, {required bool isFirstButton}, {required bool isLastButton}, {required Axis direction}, {required VerticalDirection verticalDirection}]
For class -> _SelectToggleButtonRenderObject
[this._leadingBorderSide, this._borderSide, this._trailingBorderSide, this._borderRadius, this._isFirstButton, this._isLastButton, this._direction, this._verticalDirection, this._textDirection, RenderBox? child]
[BorderSide _leadingBorderSide, BorderSide _borderSide, BorderSide _trailingBorderSide, BorderRadius _borderRadius, bool _isFirstButton, bool _isLastButton, Axis _direction, VerticalDirection _verticalDirection, TextDirection _textDirection, [RenderBox? child]]
For class -> ToggleButtonsThemeData
[this.textStyle, this.constraints, this.color, this.selectedColor, this.disabledColor, this.fillColor, this.focusColor, this.highlightColor, this.hoverColor, this.splashColor, this.borderColor, this.selectedBorderColor, this.disabledBorderColor, this.borderRadius, this.borderWidth]
[{TextStyle? textStyle}, {BoxConstraints? constraints}, {Color? color}, {Color? selectedColor}, {Color? disabledColor}, {Color? fillColor}, {Color? focusColor}, {Color? highlightColor}, {Color? hoverColor}, {Color? splashColor}, {Color? borderColor}, {Color? selectedBorderColor}, {Color? disabledBorderColor}, {BorderRadius? borderRadius}, {double? borderWidth}]
For class -> ToggleButtonsTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required ToggleButtonsThemeData data}, {required Widget child}]
For class -> Tooltip
[Key? key, required this.message, this.height, this.padding, this.margin, this.verticalOffset, this.preferBelow, this.excludeFromSemantics, this.decoration, this.textStyle, this.waitDuration, this.showDuration, this.child]
[{Key? key}, {required String message}, {double? height}, {EdgeInsetsGeometry? padding}, {EdgeInsetsGeometry? margin}, {double? verticalOffset}, {bool? preferBelow}, {bool? excludeFromSemantics}, {Decoration? decoration}, {TextStyle? textStyle}, {Duration? waitDuration}, {Duration? showDuration}, {Widget? child}]
For class -> _TooltipState
For class -> _TooltipPositionDelegate
[required this.target, required this.verticalOffset, required this.preferBelow]
[{required Offset target}, {required double verticalOffset}, {required bool preferBelow}]
For class -> _TooltipOverlay
[Key? key, required this.message, required this.height, this.padding, this.margin, this.decoration, this.textStyle, required this.animation, required this.target, required this.verticalOffset, required this.preferBelow]
[{Key? key}, {required String message}, {required double height}, {EdgeInsetsGeometry? padding}, {EdgeInsetsGeometry? margin}, {Decoration? decoration}, {TextStyle? textStyle}, {required Animation<double> animation}, {required Offset target}, {required double verticalOffset}, {required bool preferBelow}]
For class -> TooltipThemeData
[this.height, this.padding, this.margin, this.verticalOffset, this.preferBelow, this.excludeFromSemantics, this.decoration, this.textStyle, this.waitDuration, this.showDuration]
[{double? height}, {EdgeInsetsGeometry? padding}, {EdgeInsetsGeometry? margin}, {double? verticalOffset}, {bool? preferBelow}, {bool? excludeFromSemantics}, {Decoration? decoration}, {TextStyle? textStyle}, {Duration? waitDuration}, {Duration? showDuration}]
For class -> TooltipTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required TooltipThemeData data}, {required Widget child}]
For class -> Typography
[TargetPlatform? platform, TextTheme? black, TextTheme? white, TextTheme? englishLike, TextTheme? dense, TextTheme? tall]
[{TargetPlatform? platform}, {TextTheme? black}, {TextTheme? white}, {TextTheme? englishLike}, {TextTheme? dense}, {TextTheme? tall}]
[TargetPlatform? platform = TargetPlatform.android, TextTheme? black, TextTheme? white, TextTheme? englishLike, TextTheme? dense, TextTheme? tall]
[{TargetPlatform? platform = TargetPlatform.android}, {TextTheme? black}, {TextTheme? white}, {TextTheme? englishLike}, {TextTheme? dense}, {TextTheme? tall}]
[TargetPlatform? platform = TargetPlatform.android, TextTheme? black, TextTheme? white, TextTheme? englishLike, TextTheme? dense, TextTheme? tall]
[{TargetPlatform? platform = TargetPlatform.android}, {TextTheme? black}, {TextTheme? white}, {TextTheme? englishLike}, {TextTheme? dense}, {TextTheme? tall}]
[TargetPlatform? platform, TextTheme? black, TextTheme? white, TextTheme englishLike, TextTheme dense, TextTheme tall]
[TargetPlatform? platform, TextTheme? black, TextTheme? white, TextTheme englishLike, TextTheme dense, TextTheme tall]
[this.black, this.white, this.englishLike, this.dense, this.tall]
[TextTheme black, TextTheme white, TextTheme englishLike, TextTheme dense, TextTheme tall]
For class -> _AccountPictures
[Key? key, this.currentAccountPicture, this.otherAccountsPictures]
[{Key? key}, {Widget? currentAccountPicture}, {List<Widget>? otherAccountsPictures}]
For class -> _AccountDetails
[Key? key, required this.accountName, required this.accountEmail, this.onTap, required this.isOpen, this.arrowColor]
[{Key? key}, {required Widget? accountName}, {required Widget? accountEmail}, {void Function()? onTap}, {required bool isOpen}, {Color? arrowColor}]
For class -> _AccountDetailsState
For class -> _AccountDetailsLayout
[required this.textDirection]
[{required TextDirection textDirection}]
For class -> UserAccountsDrawerHeader
[Key? key, this.decoration, this.margin = const EdgeInsets.only(bottom: 8.0), this.currentAccountPicture, this.otherAccountsPictures, required this.accountName, required this.accountEmail, this.onDetailsPressed, this.arrowColor = Colors.white]
[{Key? key}, {Decoration? decoration}, {EdgeInsetsGeometry? margin = const EdgeInsets.only(bottom: 8.0)}, {Widget? currentAccountPicture}, {List<Widget>? otherAccountsPictures}, {required Widget? accountName}, {required Widget? accountEmail}, {void Function()? onDetailsPressed}, {Color arrowColor = Colors.white}]
For class -> _UserAccountsDrawerHeaderState
For class -> AlignmentGeometry
[]
[]
For class -> Alignment
[this.x, this.y]
[double x, double y]
For class -> AlignmentDirectional
[this.start, this.y]
[double start, double y]
For class -> _MixedAlignment
[this._x, this._start, this._y]
[double _x, double _start, double _y]
For class -> TextAlignVertical
[required this.y]
[{required double y}]
For class -> BeveledRectangleBorder
[BorderSide side = BorderSide.none, this.borderRadius = BorderRadius.zero]
[{BorderSide side = BorderSide.none}, {BorderRadiusGeometry borderRadius = BorderRadius.zero}]
For class -> _SystemFontsNotifier
For class -> BorderSide
[this.color = const Color(0xFF000000), this.width = 1.0, this.style = BorderStyle.solid]
[{Color color = const Color(0xFF000000)}, {double width = 1.0}, {BorderStyle style = BorderStyle.solid}]
For class -> ShapeBorder
[]
[]
For class -> OutlinedBorder
[this.side = BorderSide.none]
[{BorderSide side = BorderSide.none}]
For class -> _CompoundBorder
[this.borders]
[List<ShapeBorder> borders]
For class -> BorderRadiusGeometry
[]
[]
For class -> BorderRadius
[Radius radius]
[Radius radius]
[double radius]
[double radius]
[Radius top = Radius.zero, Radius bottom = Radius.zero]
[{Radius top = Radius.zero}, {Radius bottom = Radius.zero}]
[Radius left = Radius.zero, Radius right = Radius.zero]
[{Radius left = Radius.zero}, {Radius right = Radius.zero}]
[this.topLeft = Radius.zero, this.topRight = Radius.zero, this.bottomLeft = Radius.zero, this.bottomRight = Radius.zero]
[{Radius topLeft = Radius.zero}, {Radius topRight = Radius.zero}, {Radius bottomLeft = Radius.zero}, {Radius bottomRight = Radius.zero}]
For class -> BorderRadiusDirectional
[Radius radius]
[Radius radius]
[double radius]
[double radius]
[Radius top = Radius.zero, Radius bottom = Radius.zero]
[{Radius top = Radius.zero}, {Radius bottom = Radius.zero}]
[Radius start = Radius.zero, Radius end = Radius.zero]
[{Radius start = Radius.zero}, {Radius end = Radius.zero}]
[this.topStart = Radius.zero, this.topEnd = Radius.zero, this.bottomStart = Radius.zero, this.bottomEnd = Radius.zero]
[{Radius topStart = Radius.zero}, {Radius topEnd = Radius.zero}, {Radius bottomStart = Radius.zero}, {Radius bottomEnd = Radius.zero}]
For class -> _MixedBorderRadius
[this._topLeft, this._topRight, this._bottomLeft, this._bottomRight, this._topStart, this._topEnd, this._bottomStart, this._bottomEnd]
[Radius _topLeft, Radius _topRight, Radius _bottomLeft, Radius _bottomRight, Radius _topStart, Radius _topEnd, Radius _bottomStart, Radius _bottomEnd]
For class -> BoxBorder
[]
[]
For class -> Border
[this.top = BorderSide.none, this.right = BorderSide.none, this.bottom = BorderSide.none, this.left = BorderSide.none]
[{BorderSide top = BorderSide.none}, {BorderSide right = BorderSide.none}, {BorderSide bottom = BorderSide.none}, {BorderSide left = BorderSide.none}]
[BorderSide side]
[BorderSide side]
[BorderSide vertical = BorderSide.none, BorderSide horizontal = BorderSide.none]
[{BorderSide vertical = BorderSide.none}, {BorderSide horizontal = BorderSide.none}]
[Color color = const Color(0xFF000000), double width = 1.0, BorderStyle style = BorderStyle.solid]
[{Color color = const Color(0xFF000000)}, {double width = 1.0}, {BorderStyle style = BorderStyle.solid}]
For class -> BorderDirectional
[this.top = BorderSide.none, this.start = BorderSide.none, this.end = BorderSide.none, this.bottom = BorderSide.none]
[{BorderSide top = BorderSide.none}, {BorderSide start = BorderSide.none}, {BorderSide end = BorderSide.none}, {BorderSide bottom = BorderSide.none}]
For class -> BoxDecoration
[this.color, this.image, this.border, this.borderRadius, this.boxShadow, this.gradient, this.backgroundBlendMode, this.shape = BoxShape.rectangle]
[{Color? color}, {DecorationImage? image}, {BoxBorder? border}, {BorderRadiusGeometry? borderRadius}, {List<BoxShadow>? boxShadow}, {Gradient? gradient}, {BlendMode? backgroundBlendMode}, {BoxShape shape = BoxShape.rectangle}]
For class -> _BoxDecorationPainter
[this._decoration, VoidCallback? onChanged]
[BoxDecoration _decoration, void Function()? onChanged]
For class -> FittedSizes
[this.source, this.destination]
[Size source, Size destination]
For class -> BoxShadow
[Color color = const Color(0xFF000000), Offset offset = Offset.zero, double blurRadius = 0.0, this.spreadRadius = 0.0]
[{Color color = const Color(0xFF000000)}, {Offset offset = Offset.zero}, {double blurRadius = 0.0}, {double spreadRadius = 0.0}]
For class -> CircleBorder
[BorderSide side = BorderSide.none]
[{BorderSide side = BorderSide.none}]
For class -> ClipContext
For class -> HSVColor
[this.alpha, this.hue, this.saturation, this.value]
[double alpha, double hue, double saturation, double value]
[Color color]
[Color color]
For class -> HSLColor
[this.alpha, this.hue, this.saturation, this.lightness]
[double alpha, double hue, double saturation, double lightness]
[Color color]
[Color color]
For class -> ColorSwatch
[int primary, this._swatch]
[int primary, Map<T, Color> _swatch]
For class -> ColorProperty
[String name, Color? value, bool showName = true, Object? defaultValue = kNoDefaultValue, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, Color? value, {bool showName = true}, {Object? defaultValue = kNoDefaultValue}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> ContinuousRectangleBorder
[BorderSide side = BorderSide.none, this.borderRadius = BorderRadius.zero]
[{BorderSide side = BorderSide.none}, {BorderRadiusGeometry borderRadius = BorderRadius.zero}]
For class -> ImageSizeInfo
[this.source, this.displaySize, required this.imageSize]
[{String? source}, {Size? displaySize}, {required Size imageSize}]
For class -> Decoration
[]
[]
For class -> BoxPainter
[this.onChanged]
[[void Function()? onChanged]]
For class -> DecorationImage
[required this.image, this.onError, this.colorFilter, this.fit, this.alignment = Alignment.center, this.centerSlice, this.repeat = ImageRepeat.noRepeat, this.matchTextDirection = false, this.scale = 1.0]
[{required ImageProvider<Object> image}, {void Function(Object, StackTrace?)? onError}, {ColorFilter? colorFilter}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {Rect? centerSlice}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {bool matchTextDirection = false}, {double scale = 1.0}]
For class -> DecorationImagePainter
[this._details, this._onChanged]
[DecorationImage _details, void Function() _onChanged]
For class -> EdgeInsetsGeometry
[]
[]
For class -> EdgeInsets
[this.left, this.top, this.right, this.bottom]
[double left, double top, double right, double bottom]
[double value]
[double value]
[this.left = 0.0, this.top = 0.0, this.right = 0.0, this.bottom = 0.0]
[{double left = 0.0}, {double top = 0.0}, {double right = 0.0}, {double bottom = 0.0}]
[double vertical = 0.0, double horizontal = 0.0]
[{double vertical = 0.0}, {double horizontal = 0.0}]
[ui.WindowPadding padding, double devicePixelRatio]
[WindowPadding padding, double devicePixelRatio]
For class -> EdgeInsetsDirectional
[this.start, this.top, this.end, this.bottom]
[double start, double top, double end, double bottom]
[this.start = 0.0, this.top = 0.0, this.end = 0.0, this.bottom = 0.0]
[{double start = 0.0}, {double top = 0.0}, {double end = 0.0}, {double bottom = 0.0}]
For class -> _MixedEdgeInsets
[this._left, this._right, this._start, this._end, this._top, this._bottom]
[double _left, double _right, double _start, double _end, double _top, double _bottom]
For class -> FlutterLogoDecoration
[this.textColor = const Color(0xFF757575), this.style = FlutterLogoStyle.markOnly, this.margin = EdgeInsets.zero]
[{Color textColor = const Color(0xFF757575)}, {FlutterLogoStyle style = FlutterLogoStyle.markOnly}, {EdgeInsets margin = EdgeInsets.zero}]
[this.textColor, this.style, this.margin, this._position, this._opacity]
[Color textColor, FlutterLogoStyle style, EdgeInsets margin, double _position, double _opacity]
For class -> _FlutterLogoPainter
[this._config]
[FlutterLogoDecoration _config]
For class -> FractionalOffset
[double dx, double dy]
[double dx, double dy]
[Offset offset, Size size]
[Offset offset, Size size]
[Offset offset, Rect rect]
[Offset offset, Rect rect]
For class -> _ColorsAndStops
[this.colors, this.stops]
[List<Color> colors, List<double> stops]
For class -> GradientTransform
[]
[]
For class -> GradientRotation
[this.radians]
[double radians]
For class -> Gradient
[required this.colors, this.stops, this.transform]
[{required List<Color> colors}, {List<double>? stops}, {GradientTransform? transform}]
For class -> LinearGradient
[this.begin = Alignment.centerLeft, this.end = Alignment.centerRight, required List<Color> colors, List<double>? stops, this.tileMode = TileMode.clamp, GradientTransform? transform]
[{AlignmentGeometry begin = Alignment.centerLeft}, {AlignmentGeometry end = Alignment.centerRight}, {required List<Color> colors}, {List<double>? stops}, {TileMode tileMode = TileMode.clamp}, {GradientTransform? transform}]
For class -> RadialGradient
[this.center = Alignment.center, this.radius = 0.5, required List<Color> colors, List<double>? stops, this.tileMode = TileMode.clamp, this.focal, this.focalRadius = 0.0, GradientTransform? transform]
[{AlignmentGeometry center = Alignment.center}, {double radius = 0.5}, {required List<Color> colors}, {List<double>? stops}, {TileMode tileMode = TileMode.clamp}, {AlignmentGeometry? focal}, {double focalRadius = 0.0}, {GradientTransform? transform}]
For class -> SweepGradient
[this.center = Alignment.center, this.startAngle = 0.0, this.endAngle = math.pi * 2, required List<Color> colors, List<double>? stops, this.tileMode = TileMode.clamp, GradientTransform? transform]
[{AlignmentGeometry center = Alignment.center}, {double startAngle = 0.0}, {double endAngle = math.pi * 2}, {required List<Color> colors}, {List<double>? stops}, {TileMode tileMode = TileMode.clamp}, {GradientTransform? transform}]
For class -> ImageCache
For class -> ImageCacheStatus
[this.pending = false, this.keepAlive = false, this.live = false]
[{bool pending = false}, {bool keepAlive = false}, {bool live = false}]
For class -> _CachedImageBase
[this.completer, this.sizeBytes]
[ImageStreamCompleter completer, {int? sizeBytes}]
For class -> _CachedImage
[ImageStreamCompleter completer, int? sizeBytes]
[ImageStreamCompleter completer, {int? sizeBytes}]
For class -> _LiveImage
[ImageStreamCompleter completer, VoidCallback handleRemove, int? sizeBytes]
[ImageStreamCompleter completer, void Function() handleRemove, {int? sizeBytes}]
For class -> _PendingImage
[this.completer, this.listener]
[ImageStreamCompleter completer, ImageStreamListener listener]
For class -> ImageConfiguration
[this.bundle, this.devicePixelRatio, this.locale, this.textDirection, this.size, this.platform]
[{AssetBundle? bundle}, {double? devicePixelRatio}, {Locale? locale}, {TextDirection? textDirection}, {Size? size}, {TargetPlatform? platform}]
For class -> ImageProvider
[]
[]
For class -> AssetBundleImageKey
[required this.bundle, required this.name, required this.scale]
[{required AssetBundle bundle}, {required String name}, {required double scale}]
For class -> AssetBundleImageProvider
[]
[]
For class -> _SizeAwareCacheKey
[this.providerCacheKey, this.width, this.height]
[Object providerCacheKey, int? width, int? height]
For class -> ResizeImage
[this.imageProvider, this.width, this.height, this.allowUpscaling = false]
[ImageProvider<Object> imageProvider, {int? width}, {int? height}, {bool allowUpscaling = false}]
For class -> NetworkImage
[String url, double scale, Map<String, String>? headers]
[String url, {double scale}, {Map<String, String>? headers}]
For class -> FileImage
[this.file, this.scale = 1.0]
[File file, {double scale = 1.0}]
For class -> MemoryImage
[this.bytes, this.scale = 1.0]
[Uint8List bytes, {double scale = 1.0}]
For class -> ExactAssetImage
[this.assetName, this.scale = 1.0, this.bundle, this.package]
[String assetName, {double scale = 1.0}, {AssetBundle? bundle}, {String? package}]
For class -> _ErrorImageCompleter
[]
[]
For class -> NetworkImageLoadException
[required this.statusCode, required this.uri]
[{required int statusCode}, {required Uri uri}]
For class -> AssetImage
[this.assetName, this.bundle, this.package]
[String assetName, {AssetBundle? bundle}, {String? package}]
For class -> ImageInfo
[required this.image, this.scale = 1.0, this.debugLabel]
[{required Image image}, {double scale = 1.0}, {String? debugLabel}]
For class -> ImageStreamListener
[this.onImage, this.onChunk, this.onError]
[void Function(ImageInfo, bool) onImage, {void Function(ImageChunkEvent)? onChunk}, {void Function(Object, StackTrace?)? onError}]
For class -> ImageChunkEvent
[required this.cumulativeBytesLoaded, required this.expectedTotalBytes]
[{required int cumulativeBytesLoaded}, {required int? expectedTotalBytes}]
For class -> ImageStream
[]
[]
For class -> ImageStreamCompleterHandle
[ImageStreamCompleter this._completer]
[ImageStreamCompleter _completer]
For class -> ImageStreamCompleter
For class -> OneFrameImageStreamCompleter
[Future<ImageInfo> image, InformationCollector? informationCollector]
[Future<ImageInfo> image, {Iterable<DiagnosticsNode> Function()? informationCollector}]
For class -> MultiFrameImageStreamCompleter
[required Future<ui.Codec> codec, required double scale, String? debugLabel, Stream<ImageChunkEvent>? chunkEvents, InformationCollector? informationCollector]
[{required Future<Codec> codec}, {required double scale}, {String? debugLabel}, {Stream<ImageChunkEvent>? chunkEvents}, {Iterable<DiagnosticsNode> Function()? informationCollector}]
For class -> Accumulator
[this._value = 0]
[[int _value = 0]]
For class -> InlineSpanSemanticsInformation
[this.text, this.isPlaceholder = false, this.semanticsLabel, this.recognizer]
[String text, {bool isPlaceholder = false}, {String? semanticsLabel}, {GestureRecognizer? recognizer}]
For class -> InlineSpan
[this.style]
[{TextStyle? style}]
For class -> MatrixUtils
[]
[]
For class -> TransformProperty
[String name, Matrix4? value, bool showName = true, Object? defaultValue = kNoDefaultValue, DiagnosticLevel level = DiagnosticLevel.info]
[String name, Matrix4? value, {bool showName = true}, {Object? defaultValue = kNoDefaultValue}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> NotchedShape
[]
[]
For class -> CircularNotchedRectangle
[]
[]
For class -> AutomaticNotchedShape
[this.host, this.guest]
[ShapeBorder host, [ShapeBorder? guest]]
For class -> PlaceholderSpan
[this.alignment = ui.PlaceholderAlignment.bottom, this.baseline, TextStyle? style]
[{PlaceholderAlignment alignment = ui.PlaceholderAlignment.bottom}, {TextBaseline? baseline}, {TextStyle? style}]
For class -> RoundedRectangleBorder
[BorderSide side = BorderSide.none, this.borderRadius = BorderRadius.zero]
[{BorderSide side = BorderSide.none}, {BorderRadiusGeometry borderRadius = BorderRadius.zero}]
For class -> _RoundedRectangleToCircleBorder
[BorderSide side = BorderSide.none, this.borderRadius = BorderRadius.zero, required this.circleness]
[{BorderSide side = BorderSide.none}, {BorderRadiusGeometry borderRadius = BorderRadius.zero}, {required double circleness}]
For class -> ShaderWarmUp
[]
[]
For class -> DefaultShaderWarmUp
[this.drawCallSpacing = 0.0, this.canvasSize = const ui.Size(100.0, 100.0)]
[{double drawCallSpacing = 0.0}, {Size canvasSize = const ui.Size(100.0, 100.0)}]
For class -> ShapeDecoration
[this.color, this.image, this.gradient, this.shadows, required this.shape]
[{Color? color}, {DecorationImage? image}, {Gradient? gradient}, {List<BoxShadow>? shadows}, {required ShapeBorder shape}]
[BoxDecoration source]
[BoxDecoration source]
For class -> _ShapeDecorationPainter
[this._decoration, VoidCallback onChanged]
[ShapeDecoration _decoration, void Function() onChanged]
For class -> StadiumBorder
[BorderSide side = BorderSide.none]
[{BorderSide side = BorderSide.none}]
For class -> _StadiumToCircleBorder
[BorderSide side = BorderSide.none, this.circleness = 0.0]
[{BorderSide side = BorderSide.none}, {double circleness = 0.0}]
For class -> _StadiumToRoundedRectangleBorder
[BorderSide side = BorderSide.none, this.borderRadius = BorderRadius.zero, this.rectness = 0.0]
[{BorderSide side = BorderSide.none}, {BorderRadius borderRadius = BorderRadius.zero}, {double rectness = 0.0}]
For class -> StrutStyle
[String? fontFamily, List<String>? fontFamilyFallback, this.fontSize, this.height, this.leading, this.fontWeight, this.fontStyle, this.forceStrutHeight, this.debugLabel, String? package]
[{String? fontFamily}, {List<String>? fontFamilyFallback}, {double? fontSize}, {double? height}, {double? leading}, {FontWeight? fontWeight}, {FontStyle? fontStyle}, {bool? forceStrutHeight}, {String? debugLabel}, {String? package}]
[TextStyle textStyle, String? fontFamily, List<String>? fontFamilyFallback, double? fontSize, double? height, this.leading, FontWeight? fontWeight, FontStyle? fontStyle, this.forceStrutHeight, String? debugLabel, String? package]
[TextStyle textStyle, {String? fontFamily}, {List<String>? fontFamilyFallback}, {double? fontSize}, {double? height}, {double? leading}, {FontWeight? fontWeight}, {FontStyle? fontStyle}, {bool? forceStrutHeight}, {String? debugLabel}, {String? package}]
For class -> PlaceholderDimensions
[required this.size, required this.alignment, this.baseline, this.baselineOffset]
[{required Size size}, {required PlaceholderAlignment alignment}, {TextBaseline? baseline}, {double? baselineOffset}]
For class -> _CaretMetrics
[required this.offset, this.fullHeight]
[{required Offset offset}, {double? fullHeight}]
For class -> TextPainter
[InlineSpan? text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, double textScaleFactor = 1.0, int? maxLines, String? ellipsis, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, ui.TextHeightBehavior? textHeightBehavior]
[{InlineSpan? text}, {TextAlign textAlign = TextAlign.start}, {TextDirection? textDirection}, {double textScaleFactor = 1.0}, {int? maxLines}, {String? ellipsis}, {Locale? locale}, {StrutStyle? strutStyle}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {TextHeightBehavior? textHeightBehavior}]
For class -> TextSpan
[this.text, this.children, TextStyle? style, this.recognizer, this.semanticsLabel]
[{String? text}, {List<InlineSpan>? children}, {TextStyle? style}, {GestureRecognizer? recognizer}, {String? semanticsLabel}]
For class -> TextStyle
[this.inherit = true, this.color, this.backgroundColor, this.fontSize, this.fontWeight, this.fontStyle, this.letterSpacing, this.wordSpacing, this.textBaseline, this.height, this.locale, this.foreground, this.background, this.shadows, this.fontFeatures, this.decoration, this.decorationColor, this.decorationStyle, this.decorationThickness, this.debugLabel, String? fontFamily, List<String>? fontFamilyFallback, String? package]
[{bool inherit = true}, {Color? color}, {Color? backgroundColor}, {double? fontSize}, {FontWeight? fontWeight}, {FontStyle? fontStyle}, {double? letterSpacing}, {double? wordSpacing}, {TextBaseline? textBaseline}, {double? height}, {Locale? locale}, {Paint? foreground}, {Paint? background}, {List<Shadow>? shadows}, {List<FontFeature>? fontFeatures}, {TextDecoration? decoration}, {Color? decorationColor}, {TextDecorationStyle? decorationStyle}, {double? decorationThickness}, {String? debugLabel}, {String? fontFamily}, {List<String>? fontFamilyFallback}, {String? package}]
For class -> NetworkImage
[this.url, this.scale = 1.0, this.headers]
[String url, {double scale = 1.0}, {Map<String, String>? headers}]
For class -> NetworkImage
[this.url, this.scale = 1.0, this.headers]
[String url, {double scale = 1.0}, {Map<String, String>? headers}]
For class -> ClampedSimulation
[this.simulation, this.xMin = double.negativeInfinity, this.xMax = double.infinity, this.dxMin = double.negativeInfinity, this.dxMax = double.infinity]
[Simulation simulation, {double xMin = double.negativeInfinity}, {double xMax = double.infinity}, {double dxMin = double.negativeInfinity}, {double dxMax = double.infinity}]
For class -> FrictionSimulation
[double drag, double position, double velocity, Tolerance tolerance = Tolerance.defaultTolerance]
[double drag, double position, double velocity, {Tolerance tolerance = Tolerance.defaultTolerance}]
[double startPosition, double endPosition, double startVelocity, double endVelocity]
[double startPosition, double endPosition, double startVelocity, double endVelocity]
For class -> BoundedFrictionSimulation
[double drag, double position, double velocity, this._minX, this._maxX]
[double drag, double position, double velocity, double _minX, double _maxX]
For class -> GravitySimulation
[double acceleration, double distance, double endDistance, double velocity]
[double acceleration, double distance, double endDistance, double velocity]
For class -> Simulation
[this.tolerance = Tolerance.defaultTolerance]
[{Tolerance tolerance = Tolerance.defaultTolerance}]
For class -> SpringDescription
[required this.mass, required this.stiffness, required this.damping]
[{required double mass}, {required double stiffness}, {required double damping}]
[required this.mass, required this.stiffness, double ratio = 1.0]
[{required double mass}, {required double stiffness}, {double ratio = 1.0}]
For class -> SpringSimulation
[SpringDescription spring, double start, double end, double velocity, Tolerance tolerance = Tolerance.defaultTolerance]
[SpringDescription spring, double start, double end, double velocity, {Tolerance tolerance = Tolerance.defaultTolerance}]
For class -> ScrollSpringSimulation
[SpringDescription spring, double start, double end, double velocity, Tolerance tolerance = Tolerance.defaultTolerance]
[SpringDescription spring, double start, double end, double velocity, {Tolerance tolerance = Tolerance.defaultTolerance}]
For class -> _SpringSolution
[SpringDescription spring, double initialPosition, double initialVelocity]
[SpringDescription spring, double initialPosition, double initialVelocity]
For class -> _CriticalSolution
[SpringDescription spring, double distance, double velocity]
[SpringDescription spring, double distance, double velocity]
[double r, double c1, double c2]
[double r, double c1, double c2]
For class -> _OverdampedSolution
[SpringDescription spring, double distance, double velocity]
[SpringDescription spring, double distance, double velocity]
[double r1, double r2, double c1, double c2]
[double r1, double r2, double c1, double c2]
For class -> _UnderdampedSolution
[SpringDescription spring, double distance, double velocity]
[SpringDescription spring, double distance, double velocity]
[double w, double r, double c1, double c2]
[double w, double r, double c1, double c2]
For class -> Tolerance
[this.distance = _epsilonDefault, this.time = _epsilonDefault, this.velocity = _epsilonDefault]
[{double distance = _epsilonDefault}, {double time = _epsilonDefault}, {double velocity = _epsilonDefault}]
For class -> RenderAnimatedSize
[required TickerProvider vsync, required Duration duration, Duration? reverseDuration, Curve curve = Curves.linear, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection, RenderBox? child, Clip clipBehavior = Clip.hardEdge]
[{required TickerProvider vsync}, {required Duration duration}, {Duration? reverseDuration}, {Curve curve = Curves.linear}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}, {RenderBox? child}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderingFlutterBinding
[RenderBox? root]
[{RenderBox? root}]
For class -> _DebugSize
[Size source, this._owner, this._canBeUsedByParent]
[Size source, RenderBox _owner, bool _canBeUsedByParent]
For class -> BoxConstraints
[this.minWidth = 0.0, this.maxWidth = double.infinity, this.minHeight = 0.0, this.maxHeight = double.infinity]
[{double minWidth = 0.0}, {double maxWidth = double.infinity}, {double minHeight = 0.0}, {double maxHeight = double.infinity}]
[Size size]
[Size size]
[double? width, double? height]
[{double? width}, {double? height}]
[double width = double.infinity, double height = double.infinity]
[{double width = double.infinity}, {double height = double.infinity}]
[Size size]
[Size size]
[double? width, double? height]
[{double? width}, {double? height}]
For class -> BoxHitTestResult
[]
[]
[HitTestResult result]
[HitTestResult result]
For class -> BoxHitTestEntry
[RenderBox target, this.localPosition]
[RenderBox target, Offset localPosition]
For class -> BoxParentData
For class -> ContainerBoxParentData
For class -> _IntrinsicDimensionsCacheEntry
[this.dimension, this.argument]
[_IntrinsicDimension dimension, double argument]
For class -> RenderBox
For class -> MultiChildLayoutParentData
For class -> MultiChildLayoutDelegate
[Listenable? relayout]
[{Listenable? relayout}]
For class -> RenderCustomMultiChildLayoutBox
[List<RenderBox>? children, required MultiChildLayoutDelegate delegate]
[{List<RenderBox>? children}, {required MultiChildLayoutDelegate delegate}]
For class -> CustomPainter
[Listenable? repaint]
[{Listenable? repaint}]
For class -> CustomPainterSemantics
[this.key, required this.rect, required this.properties, this.transform, this.tags]
[{Key? key}, {required Rect rect}, {required SemanticsProperties properties}, {Matrix4? transform}, {Set<SemanticsTag>? tags}]
For class -> RenderCustomPaint
[CustomPainter? painter, CustomPainter? foregroundPainter, Size preferredSize = Size.zero, this.isComplex = false, this.willChange = false, RenderBox? child]
[{CustomPainter? painter}, {CustomPainter? foregroundPainter}, {Size preferredSize = Size.zero}, {bool isComplex = false}, {bool willChange = false}, {RenderBox? child}]
For class -> _OverflowRegionData
[required this.rect, this.label = '', this.labelOffset = Offset.zero, this.rotation = 0.0, required this.side]
[{required Rect rect}, {String label = ''}, {Offset labelOffset = Offset.zero}, {double rotation = 0.0}, {required _OverflowSide side}]
For class -> TextSelectionPoint
[this.point, this.direction]
[Offset point, TextDirection? direction]
For class -> RenderEditable
[TextSpan? text, required TextDirection textDirection, TextAlign textAlign = TextAlign.start, Color? cursorColor, Color? backgroundCursorColor, ValueNotifier<bool>? showCursor, bool? hasFocus, required LayerLink startHandleLayerLink, required LayerLink endHandleLayerLink, int? maxLines = 1, int? minLines, bool expands = false, StrutStyle? strutStyle, Color? selectionColor, double textScaleFactor = 1.0, TextSelection? selection, required ViewportOffset offset, this.onSelectionChanged, this.onCaretChanged, this.ignorePointer = false, bool readOnly = false, bool forceLine = true, TextHeightBehavior? textHeightBehavior, TextWidthBasis textWidthBasis = TextWidthBasis.parent, String obscuringCharacter = '•', bool obscureText = false, Locale? locale, double cursorWidth = 1.0, double? cursorHeight, Radius? cursorRadius, bool paintCursorAboveText = false, Offset? cursorOffset, double devicePixelRatio = 1.0, ui.BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight, ui.BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight, bool? enableInteractiveSelection, EdgeInsets floatingCursorAddedMargin = const EdgeInsets.fromLTRB(4, 4, 4, 5), TextRange? promptRectRange, Color? promptRectColor, Clip clipBehavior = Clip.hardEdge, required this.textSelectionDelegate]
[{TextSpan? text}, {required TextDirection textDirection}, {TextAlign textAlign = TextAlign.start}, {Color? cursorColor}, {Color? backgroundCursorColor}, {ValueNotifier<bool>? showCursor}, {bool? hasFocus}, {required LayerLink startHandleLayerLink}, {required LayerLink endHandleLayerLink}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {StrutStyle? strutStyle}, {Color? selectionColor}, {double textScaleFactor = 1.0}, {TextSelection? selection}, {required ViewportOffset offset}, {void Function(TextSelection, RenderEditable, SelectionChangedCause)? onSelectionChanged}, {void Function(Rect)? onCaretChanged}, {bool ignorePointer = false}, {bool readOnly = false}, {bool forceLine = true}, {TextHeightBehavior? textHeightBehavior}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {Locale? locale}, {double cursorWidth = 1.0}, {double? cursorHeight}, {Radius? cursorRadius}, {bool paintCursorAboveText = false}, {Offset? cursorOffset}, {double devicePixelRatio = 1.0}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {bool? enableInteractiveSelection}, {EdgeInsets floatingCursorAddedMargin = const EdgeInsets.fromLTRB(4, 4, 4, 5)}, {TextRange? promptRectRange}, {Color? promptRectColor}, {Clip clipBehavior = Clip.hardEdge}, {required TextSelectionDelegate textSelectionDelegate}]
For class -> RenderErrorBox
[this.message = '']
[[String message = '']]
For class -> FlexParentData
For class -> RenderFlex
[List<RenderBox>? children, Axis direction = Axis.horizontal, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none]
[{List<RenderBox>? children}, {Axis direction = Axis.horizontal}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {Clip clipBehavior = Clip.none}]
For class -> _LayoutSizes
[required this.mainSize, required this.crossSize, required this.allocatedSize]
[{required double mainSize}, {required double crossSize}, {required double allocatedSize}]
For class -> FlowPaintingContext
For class -> FlowDelegate
[Listenable? repaint]
[{Listenable? repaint}]
For class -> FlowParentData
For class -> RenderFlow
[List<RenderBox>? children, required FlowDelegate delegate, Clip clipBehavior = Clip.hardEdge]
[{List<RenderBox>? children}, {required FlowDelegate delegate}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderImage
[ui.Image? image, this.debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, TextDirection? textDirection, bool invertColors = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low]
[{Image? image}, {String? debugImageLabel}, {double? width}, {double? height}, {double scale = 1.0}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {TextDirection? textDirection}, {bool invertColors = false}, {bool isAntiAlias = false}, {FilterQuality filterQuality = FilterQuality.low}]
For class -> AnnotationEntry
[required this.annotation, required this.localPosition]
[{required T annotation}, {required Offset localPosition}]
For class -> AnnotationResult
For class -> Layer
For class -> PictureLayer
[this.canvasBounds]
[Rect canvasBounds]
For class -> TextureLayer
[required this.rect, required this.textureId, this.freeze = false, this.filterQuality = ui.FilterQuality.low]
[{required Rect rect}, {required int textureId}, {bool freeze = false}, {FilterQuality filterQuality = ui.FilterQuality.low}]
For class -> PlatformViewLayer
[required this.rect, required this.viewId]
[{required Rect rect}, {required int viewId}]
For class -> PerformanceOverlayLayer
[required Rect overlayRect, required this.optionsMask, required this.rasterizerThreshold, required this.checkerboardRasterCacheImages, required this.checkerboardOffscreenLayers]
[{required Rect overlayRect}, {required int optionsMask}, {required int rasterizerThreshold}, {required bool checkerboardRasterCacheImages}, {required bool checkerboardOffscreenLayers}]
For class -> ContainerLayer
For class -> OffsetLayer
[Offset offset = Offset.zero]
[{Offset offset = Offset.zero}]
For class -> ClipRectLayer
[Rect? clipRect, Clip clipBehavior = Clip.hardEdge]
[{Rect? clipRect}, {Clip clipBehavior = Clip.hardEdge}]
For class -> ClipRRectLayer
[RRect? clipRRect, Clip clipBehavior = Clip.antiAlias]
[{RRect? clipRRect}, {Clip clipBehavior = Clip.antiAlias}]
For class -> ClipPathLayer
[Path? clipPath, Clip clipBehavior = Clip.antiAlias]
[{Path? clipPath}, {Clip clipBehavior = Clip.antiAlias}]
For class -> ColorFilterLayer
[ColorFilter? colorFilter]
[{ColorFilter? colorFilter}]
For class -> ImageFilterLayer
[ui.ImageFilter? imageFilter]
[{ImageFilter? imageFilter}]
For class -> TransformLayer
[Matrix4? transform, Offset offset = Offset.zero]
[{Matrix4? transform}, {Offset offset = Offset.zero}]
For class -> OpacityLayer
[int? alpha, Offset offset = Offset.zero]
[{int? alpha}, {Offset offset = Offset.zero}]
For class -> ShaderMaskLayer
[Shader? shader, Rect? maskRect, BlendMode? blendMode]
[{Shader? shader}, {Rect? maskRect}, {BlendMode? blendMode}]
For class -> BackdropFilterLayer
[ui.ImageFilter? filter]
[{ImageFilter? filter}]
For class -> PhysicalModelLayer
[Path? clipPath, Clip clipBehavior = Clip.none, double? elevation, Color? color, Color? shadowColor]
[{Path? clipPath}, {Clip clipBehavior = Clip.none}, {double? elevation}, {Color? color}, {Color? shadowColor}]
For class -> LayerLink
For class -> LeaderLayer
[required LayerLink link, this.offset = Offset.zero]
[{required LayerLink link}, {Offset offset = Offset.zero}]
For class -> FollowerLayer
[required LayerLink link, this.showWhenUnlinked = true, this.unlinkedOffset = Offset.zero, this.linkedOffset = Offset.zero]
[{required LayerLink link}, {bool? showWhenUnlinked = true}, {Offset? unlinkedOffset = Offset.zero}, {Offset? linkedOffset = Offset.zero}]
For class -> AnnotatedRegionLayer
[this.value, this.size, Offset? offset, this.opaque = false]
[T value, {Size? size}, {Offset? offset}, {bool opaque = false}]
For class -> ChildLayoutHelper
[]
[]
For class -> ListBodyParentData
For class -> RenderListBody
[List<RenderBox>? children, AxisDirection axisDirection = AxisDirection.down]
[{List<RenderBox>? children}, {AxisDirection axisDirection = AxisDirection.down}]
For class -> ListWheelChildManager
For class -> ListWheelParentData
For class -> RenderListWheelViewport
[required this.childManager, required ViewportOffset offset, double diameterRatio = defaultDiameterRatio, double perspective = defaultPerspective, double offAxisFraction = 0, bool useMagnifier = false, double magnification = 1, double overAndUnderCenterOpacity = 1, required double itemExtent, double squeeze = 1, bool renderChildrenOutsideViewport = false, Clip clipBehavior = Clip.none, List<RenderBox>? children]
[{required ListWheelChildManager childManager}, {required ViewportOffset offset}, {double diameterRatio = defaultDiameterRatio}, {double perspective = defaultPerspective}, {double offAxisFraction = 0}, {bool useMagnifier = false}, {double magnification = 1}, {double overAndUnderCenterOpacity = 1}, {required double itemExtent}, {double squeeze = 1}, {bool renderChildrenOutsideViewport = false}, {Clip clipBehavior = Clip.none}, {List<RenderBox>? children}]
For class -> MouseCursorSession
[this.cursor, this.device]
[MouseCursor cursor, int device]
For class -> MouseCursor
[]
[]
For class -> _DeferringMouseCursor
[]
[]
For class -> _NoopMouseCursorSession
[_NoopMouseCursor cursor, int device]
[_NoopMouseCursor cursor, int device]
For class -> _NoopMouseCursor
[]
[]
For class -> _SystemMouseCursorSession
[SystemMouseCursor cursor, int device]
[SystemMouseCursor cursor, int device]
For class -> SystemMouseCursor
[required this.kind]
[{required String kind}]
For class -> SystemMouseCursors
[]
[]
For class -> MouseTrackerAnnotation
[this.onEnter, this.onExit, this.cursor = MouseCursor.defer, this.validForMouseTracker = true]
[{void Function(PointerEnterEvent)? onEnter}, {void Function(PointerExitEvent)? onExit}, {MouseCursor cursor = MouseCursor.defer}, {bool validForMouseTracker = true}]
For class -> _MouseState
[required PointerEvent initialEvent]
[{required PointerEvent initialEvent}]
For class -> MouseTrackerUpdateDetails
[required this.lastAnnotations, required this.nextAnnotations, required PointerEvent this.previousEvent]
[{required LinkedHashMap<MouseTrackerAnnotation, Matrix4> lastAnnotations}, {required LinkedHashMap<MouseTrackerAnnotation, Matrix4> nextAnnotations}, {required PointerEvent previousEvent}]
[required this.lastAnnotations, required this.nextAnnotations, this.previousEvent, required PointerEvent this.triggeringEvent]
[{required LinkedHashMap<MouseTrackerAnnotation, Matrix4> lastAnnotations}, {required LinkedHashMap<MouseTrackerAnnotation, Matrix4> nextAnnotations}, {PointerEvent? previousEvent}, {required PointerEvent triggeringEvent}]
For class -> BaseMouseTracker
For class -> MouseTracker
For class -> ParentData
For class -> PaintingContext
[this._containerLayer, this.estimatedBounds]
[ContainerLayer _containerLayer, Rect estimatedBounds]
For class -> Constraints
[]
[]
For class -> SemanticsHandle
[PipelineOwner owner, this.listener]
[PipelineOwner owner, void Function()? listener]
For class -> PipelineOwner
[this.onNeedVisualUpdate, this.onSemanticsOwnerCreated, this.onSemanticsOwnerDisposed]
[{void Function()? onNeedVisualUpdate}, {void Function()? onSemanticsOwnerCreated}, {void Function()? onSemanticsOwnerDisposed}]
For class -> RenderObject
[]
[]
For class -> _SemanticsFragment
[required this.dropsSemanticsOfPreviousSiblings]
[{required bool dropsSemanticsOfPreviousSiblings}]
For class -> _ContainerSemanticsFragment
[required bool dropsSemanticsOfPreviousSiblings]
[{required bool dropsSemanticsOfPreviousSiblings}]
For class -> _InterestingSemanticsFragment
[required RenderObject owner, required bool dropsSemanticsOfPreviousSiblings]
[{required RenderObject owner}, {required bool dropsSemanticsOfPreviousSiblings}]
For class -> _RootSemanticsFragment
[required RenderObject owner, required bool dropsSemanticsOfPreviousSiblings]
[{required RenderObject owner}, {required bool dropsSemanticsOfPreviousSiblings}]
For class -> _SwitchableSemanticsFragment
[required bool mergeIntoParent, required SemanticsConfiguration config, required RenderObject owner, required bool dropsSemanticsOfPreviousSiblings]
[{required bool mergeIntoParent}, {required SemanticsConfiguration config}, {required RenderObject owner}, {required bool dropsSemanticsOfPreviousSiblings}]
For class -> _AbortingSemanticsFragment
[required RenderObject owner]
[{required RenderObject owner}]
For class -> _SemanticsGeometry
[required Rect? parentSemanticsClipRect, required Rect? parentPaintClipRect, required List<RenderObject> ancestors]
[{required Rect? parentSemanticsClipRect}, {required Rect? parentPaintClipRect}, {required List<RenderObject> ancestors}]
For class -> DiagnosticsDebugCreator
[Object value]
[Object value]
For class -> TextParentData
For class -> PlaceholderSpanIndexSemanticsTag
[this.index]
[int index]
For class -> RenderParagraph
[InlineSpan text, TextAlign textAlign = TextAlign.start, required TextDirection textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, ui.TextHeightBehavior? textHeightBehavior, List<RenderBox>? children]
[InlineSpan text, {TextAlign textAlign = TextAlign.start}, {required TextDirection textDirection}, {bool softWrap = true}, {TextOverflow overflow = TextOverflow.clip}, {double textScaleFactor = 1.0}, {int? maxLines}, {Locale? locale}, {StrutStyle? strutStyle}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {TextHeightBehavior? textHeightBehavior}, {List<RenderBox>? children}]
For class -> RenderPerformanceOverlay
[int optionsMask = 0, int rasterizerThreshold = 0, bool checkerboardRasterCacheImages = false, bool checkerboardOffscreenLayers = false]
[{int optionsMask = 0}, {int rasterizerThreshold = 0}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}]
For class -> RenderAndroidView
[required AndroidViewController viewController, required PlatformViewHitTestBehavior hitTestBehavior, required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers, Clip clipBehavior = Clip.hardEdge]
[{required AndroidViewController viewController}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderUiKitView
[required UiKitViewController viewController, required this.hitTestBehavior, required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers]
[{required UiKitViewController viewController}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}]
For class -> _UiKitViewGestureRecognizer
[this.controller, this.gestureRecognizerFactories, PointerDeviceKind? kind]
[UiKitViewController controller, Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizerFactories, {PointerDeviceKind? kind}]
For class -> _PlatformViewGestureRecognizer
[_HandlePointerEvent handlePointerEvent, this.gestureRecognizerFactories, PointerDeviceKind? kind]
[Future<void> Function(PointerEvent) handlePointerEvent, Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizerFactories, {PointerDeviceKind? kind}]
For class -> PlatformViewRenderBox
[required PlatformViewController controller, required PlatformViewHitTestBehavior hitTestBehavior, required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers]
[{required PlatformViewController controller}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}]
For class -> RenderProxyBox
[RenderBox? child]
[[RenderBox? child]]
For class -> RenderProxyBoxWithHitTestBehavior
[this.behavior = HitTestBehavior.deferToChild, RenderBox? child]
[{HitTestBehavior behavior = HitTestBehavior.deferToChild}, {RenderBox? child}]
For class -> RenderConstrainedBox
[RenderBox? child, required BoxConstraints additionalConstraints]
[{RenderBox? child}, {required BoxConstraints additionalConstraints}]
For class -> RenderLimitedBox
[RenderBox? child, double maxWidth = double.infinity, double maxHeight = double.infinity]
[{RenderBox? child}, {double maxWidth = double.infinity}, {double maxHeight = double.infinity}]
For class -> RenderAspectRatio
[RenderBox? child, required double aspectRatio]
[{RenderBox? child}, {required double aspectRatio}]
For class -> RenderIntrinsicWidth
[double? stepWidth, double? stepHeight, RenderBox? child]
[{double? stepWidth}, {double? stepHeight}, {RenderBox? child}]
For class -> RenderIntrinsicHeight
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderOpacity
[double opacity = 1.0, bool alwaysIncludeSemantics = false, RenderBox? child]
[{double opacity = 1.0}, {bool alwaysIncludeSemantics = false}, {RenderBox? child}]
For class -> RenderAnimatedOpacity
[required Animation<double> opacity, bool alwaysIncludeSemantics = false, RenderBox? child]
[{required Animation<double> opacity}, {bool alwaysIncludeSemantics = false}, {RenderBox? child}]
For class -> RenderShaderMask
[RenderBox? child, required ShaderCallback shaderCallback, BlendMode blendMode = BlendMode.modulate]
[{RenderBox? child}, {required Shader Function(Rect) shaderCallback}, {BlendMode blendMode = BlendMode.modulate}]
For class -> RenderBackdropFilter
[RenderBox? child, required ui.ImageFilter filter]
[{RenderBox? child}, {required ImageFilter filter}]
For class -> CustomClipper
[Listenable? reclip]
[{Listenable? reclip}]
For class -> ShapeBorderClipper
[required this.shape, this.textDirection]
[{required ShapeBorder shape}, {TextDirection? textDirection}]
For class -> _RenderCustomClip
[RenderBox? child, CustomClipper<T>? clipper, Clip clipBehavior = Clip.antiAlias]
[{RenderBox? child}, {CustomClipper<T>? clipper}, {Clip clipBehavior = Clip.antiAlias}]
For class -> RenderClipRect
[RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias]
[{RenderBox? child}, {CustomClipper<Rect>? clipper}, {Clip clipBehavior = Clip.antiAlias}]
For class -> RenderClipRRect
[RenderBox? child, BorderRadius borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias]
[{RenderBox? child}, {BorderRadius borderRadius = BorderRadius.zero}, {CustomClipper<RRect>? clipper}, {Clip clipBehavior = Clip.antiAlias}]
For class -> RenderClipOval
[RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias]
[{RenderBox? child}, {CustomClipper<Rect>? clipper}, {Clip clipBehavior = Clip.antiAlias}]
For class -> RenderClipPath
[RenderBox? child, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias]
[{RenderBox? child}, {CustomClipper<Path>? clipper}, {Clip clipBehavior = Clip.antiAlias}]
For class -> _RenderPhysicalModelBase
[required RenderBox? child, required double elevation, required Color color, required Color shadowColor, Clip clipBehavior = Clip.none, CustomClipper<T>? clipper]
[{required RenderBox? child}, {required double elevation}, {required Color color}, {required Color shadowColor}, {Clip clipBehavior = Clip.none}, {CustomClipper<T>? clipper}]
For class -> RenderPhysicalModel
[RenderBox? child, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)]
[{RenderBox? child}, {BoxShape shape = BoxShape.rectangle}, {Clip clipBehavior = Clip.none}, {BorderRadius? borderRadius}, {double elevation = 0.0}, {required Color color}, {Color shadowColor = const Color(0xFF000000)}]
For class -> RenderPhysicalShape
[RenderBox? child, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)]
[{RenderBox? child}, {required CustomClipper<Path> clipper}, {Clip clipBehavior = Clip.none}, {double elevation = 0.0}, {required Color color}, {Color shadowColor = const Color(0xFF000000)}]
For class -> RenderDecoratedBox
[required Decoration decoration, DecorationPosition position = DecorationPosition.background, ImageConfiguration configuration = ImageConfiguration.empty, RenderBox? child]
[{required Decoration decoration}, {DecorationPosition position = DecorationPosition.background}, {ImageConfiguration configuration = ImageConfiguration.empty}, {RenderBox? child}]
For class -> RenderTransform
[required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, TextDirection? textDirection, this.transformHitTests = true, RenderBox? child]
[{required Matrix4 transform}, {Offset? origin}, {AlignmentGeometry? alignment}, {TextDirection? textDirection}, {bool transformHitTests = true}, {RenderBox? child}]
For class -> RenderFittedBox
[BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection, RenderBox? child, Clip clipBehavior = Clip.none]
[{BoxFit fit = BoxFit.contain}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}, {RenderBox? child}, {Clip clipBehavior = Clip.none}]
For class -> RenderFractionalTranslation
[required Offset translation, this.transformHitTests = true, RenderBox? child]
[{required Offset translation}, {bool transformHitTests = true}, {RenderBox? child}]
For class -> RenderPointerListener
[this.onPointerDown, this.onPointerMove, this.onPointerUp, this.onPointerHover, this.onPointerCancel, this.onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child]
[{void Function(PointerDownEvent)? onPointerDown}, {void Function(PointerMoveEvent)? onPointerMove}, {void Function(PointerUpEvent)? onPointerUp}, {void Function(PointerHoverEvent)? onPointerHover}, {void Function(PointerCancelEvent)? onPointerCancel}, {void Function(PointerSignalEvent)? onPointerSignal}, {HitTestBehavior behavior = HitTestBehavior.deferToChild}, {RenderBox? child}]
For class -> RenderMouseRegion
[this.onEnter, this.onHover, this.onExit, MouseCursor cursor = MouseCursor.defer, bool validForMouseTracker = true, bool opaque = true, RenderBox? child]
[{void Function(PointerEnterEvent)? onEnter}, {void Function(PointerHoverEvent)? onHover}, {void Function(PointerExitEvent)? onExit}, {MouseCursor cursor = MouseCursor.defer}, {bool validForMouseTracker = true}, {bool opaque = true}, {RenderBox? child}]
For class -> RenderRepaintBoundary
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderIgnorePointer
[RenderBox? child, bool ignoring = true, bool? ignoringSemantics]
[{RenderBox? child}, {bool ignoring = true}, {bool? ignoringSemantics}]
For class -> RenderOffstage
[bool offstage = true, RenderBox? child]
[{bool offstage = true}, {RenderBox? child}]
For class -> RenderAbsorbPointer
[RenderBox? child, bool absorbing = true, bool? ignoringSemantics]
[{RenderBox? child}, {bool absorbing = true}, {bool? ignoringSemantics}]
For class -> RenderMetaData
[this.metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child]
[{dynamic metaData}, {HitTestBehavior behavior = HitTestBehavior.deferToChild}, {RenderBox? child}]
For class -> RenderSemanticsGestureHandler
[RenderBox? child, GestureTapCallback? onTap, GestureLongPressCallback? onLongPress, GestureDragUpdateCallback? onHorizontalDragUpdate, GestureDragUpdateCallback? onVerticalDragUpdate, this.scrollFactor = 0.8]
[{RenderBox? child}, {void Function()? onTap}, {void Function()? onLongPress}, {void Function(DragUpdateDetails)? onHorizontalDragUpdate}, {void Function(DragUpdateDetails)? onVerticalDragUpdate}, {double scrollFactor = 0.8}]
For class -> RenderSemanticsAnnotations
[RenderBox? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? toggled, bool? selected, bool? button, bool? slider, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, String? value, String? increasedValue, String? decreasedValue, String? hint, SemanticsHintOverrides? hintOverrides, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, VoidCallback? onTap, VoidCallback? onDismiss, VoidCallback? onLongPress, VoidCallback? onScrollLeft, VoidCallback? onScrollRight, VoidCallback? onScrollUp, VoidCallback? onScrollDown, VoidCallback? onIncrease, VoidCallback? onDecrease, VoidCallback? onCopy, VoidCallback? onCut, VoidCallback? onPaste, MoveCursorHandler? onMoveCursorForwardByCharacter, MoveCursorHandler? onMoveCursorBackwardByCharacter, MoveCursorHandler? onMoveCursorForwardByWord, MoveCursorHandler? onMoveCursorBackwardByWord, SetSelectionHandler? onSetSelection, VoidCallback? onDidGainAccessibilityFocus, VoidCallback? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions]
[{RenderBox? child}, {bool container = false}, {bool explicitChildNodes = false}, {bool excludeSemantics = false}, {bool? enabled}, {bool? checked}, {bool? toggled}, {bool? selected}, {bool? button}, {bool? slider}, {bool? link}, {bool? header}, {bool? textField}, {bool? readOnly}, {bool? focusable}, {bool? focused}, {bool? inMutuallyExclusiveGroup}, {bool? obscured}, {bool? multiline}, {bool? scopesRoute}, {bool? namesRoute}, {bool? hidden}, {bool? image}, {bool? liveRegion}, {int? maxValueLength}, {int? currentValueLength}, {String? label}, {String? value}, {String? increasedValue}, {String? decreasedValue}, {String? hint}, {SemanticsHintOverrides? hintOverrides}, {TextDirection? textDirection}, {SemanticsSortKey? sortKey}, {SemanticsTag? tagForChildren}, {void Function()? onTap}, {void Function()? onDismiss}, {void Function()? onLongPress}, {void Function()? onScrollLeft}, {void Function()? onScrollRight}, {void Function()? onScrollUp}, {void Function()? onScrollDown}, {void Function()? onIncrease}, {void Function()? onDecrease}, {void Function()? onCopy}, {void Function()? onCut}, {void Function()? onPaste}, {void Function(bool)? onMoveCursorForwardByCharacter}, {void Function(bool)? onMoveCursorBackwardByCharacter}, {void Function(bool)? onMoveCursorForwardByWord}, {void Function(bool)? onMoveCursorBackwardByWord}, {void Function(TextSelection)? onSetSelection}, {void Function()? onDidGainAccessibilityFocus}, {void Function()? onDidLoseAccessibilityFocus}, {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}]
For class -> RenderBlockSemantics
[RenderBox? child, bool blocking = true]
[{RenderBox? child}, {bool blocking = true}]
For class -> RenderMergeSemantics
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderExcludeSemantics
[RenderBox? child, bool excluding = true]
[{RenderBox? child}, {bool excluding = true}]
For class -> RenderIndexedSemantics
[RenderBox? child, required int index]
[{RenderBox? child}, {required int index}]
For class -> RenderLeaderLayer
[required LayerLink link, RenderBox? child]
[{required LayerLink link}, {RenderBox? child}]
For class -> RenderFollowerLayer
[required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment leaderAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, RenderBox? child]
[{required LayerLink link}, {bool showWhenUnlinked = true}, {Offset offset = Offset.zero}, {Alignment leaderAnchor = Alignment.topLeft}, {Alignment followerAnchor = Alignment.topLeft}, {RenderBox? child}]
For class -> RenderAnnotatedRegion
[required T value, required bool sized, RenderBox? child]
[{required T value}, {required bool sized}, {RenderBox? child}]
For class -> RenderProxySliver
[RenderSliver? child]
[[RenderSliver? child]]
For class -> RenderSliverOpacity
[double opacity = 1.0, bool alwaysIncludeSemantics = false, RenderSliver? sliver]
[{double opacity = 1.0}, {bool alwaysIncludeSemantics = false}, {RenderSliver? sliver}]
For class -> RenderSliverIgnorePointer
[RenderSliver? sliver, bool ignoring = true, bool? ignoringSemantics]
[{RenderSliver? sliver}, {bool ignoring = true}, {bool? ignoringSemantics}]
For class -> RenderSliverOffstage
[bool offstage = true, RenderSliver? sliver]
[{bool offstage = true}, {RenderSliver? sliver}]
For class -> RenderSliverAnimatedOpacity
[required Animation<double> opacity, bool alwaysIncludeSemantics = false, RenderSliver? sliver]
[{required Animation<double> opacity}, {bool alwaysIncludeSemantics = false}, {RenderSliver? sliver}]
For class -> RenderRotatedBox
[required int quarterTurns, RenderBox? child]
[{required int quarterTurns}, {RenderBox? child}]
For class -> RenderShiftedBox
[RenderBox? child]
[RenderBox? child]
For class -> RenderPadding
[required EdgeInsetsGeometry padding, TextDirection? textDirection, RenderBox? child]
[{required EdgeInsetsGeometry padding}, {TextDirection? textDirection}, {RenderBox? child}]
For class -> RenderAligningShiftedBox
[AlignmentGeometry alignment = Alignment.center, required TextDirection? textDirection, RenderBox? child]
[{AlignmentGeometry alignment = Alignment.center}, {required TextDirection? textDirection}, {RenderBox? child}]
[AlignmentGeometry alignment, TextDirection? textDirection, RenderBox? child]
[AlignmentGeometry alignment, TextDirection? textDirection, RenderBox? child]
For class -> RenderPositionedBox
[RenderBox? child, double? widthFactor, double? heightFactor, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection]
[{RenderBox? child}, {double? widthFactor}, {double? heightFactor}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}]
For class -> RenderConstrainedOverflowBox
[RenderBox? child, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection]
[{RenderBox? child}, {double? minWidth}, {double? maxWidth}, {double? minHeight}, {double? maxHeight}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}]
For class -> RenderUnconstrainedBox
[required AlignmentGeometry alignment, required TextDirection? textDirection, Axis? constrainedAxis, RenderBox? child, Clip clipBehavior = Clip.none]
[{required AlignmentGeometry alignment}, {required TextDirection? textDirection}, {Axis? constrainedAxis}, {RenderBox? child}, {Clip clipBehavior = Clip.none}]
For class -> RenderSizedOverflowBox
[RenderBox? child, required Size requestedSize, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection]
[{RenderBox? child}, {required Size requestedSize}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}]
For class -> RenderFractionallySizedOverflowBox
[RenderBox? child, double? widthFactor, double? heightFactor, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection]
[{RenderBox? child}, {double? widthFactor}, {double? heightFactor}, {AlignmentGeometry alignment = Alignment.center}, {TextDirection? textDirection}]
For class -> SingleChildLayoutDelegate
[Listenable? relayout]
[{Listenable? relayout}]
For class -> RenderCustomSingleChildLayoutBox
[RenderBox? child, required SingleChildLayoutDelegate delegate]
[{RenderBox? child}, {required SingleChildLayoutDelegate delegate}]
For class -> RenderBaseline
[RenderBox? child, required double baseline, required TextBaseline baselineType]
[{RenderBox? child}, {required double baseline}, {required TextBaseline baselineType}]
For class -> SliverConstraints
[required this.axisDirection, required this.growthDirection, required this.userScrollDirection, required this.scrollOffset, required this.precedingScrollExtent, required this.overlap, required this.remainingPaintExtent, required this.crossAxisExtent, required this.crossAxisDirection, required this.viewportMainAxisExtent, required this.remainingCacheExtent, required this.cacheOrigin]
[{required AxisDirection axisDirection}, {required GrowthDirection growthDirection}, {required ScrollDirection userScrollDirection}, {required double scrollOffset}, {required double precedingScrollExtent}, {required double overlap}, {required double remainingPaintExtent}, {required double crossAxisExtent}, {required AxisDirection crossAxisDirection}, {required double viewportMainAxisExtent}, {required double remainingCacheExtent}, {required double cacheOrigin}]
For class -> SliverGeometry
[this.scrollExtent = 0.0, this.paintExtent = 0.0, this.paintOrigin = 0.0, double? layoutExtent, this.maxPaintExtent = 0.0, this.maxScrollObstructionExtent = 0.0, double? hitTestExtent, bool? visible, this.hasVisualOverflow = false, this.scrollOffsetCorrection, double? cacheExtent]
[{double scrollExtent = 0.0}, {double paintExtent = 0.0}, {double paintOrigin = 0.0}, {double? layoutExtent}, {double maxPaintExtent = 0.0}, {double maxScrollObstructionExtent = 0.0}, {double? hitTestExtent}, {bool? visible}, {bool hasVisualOverflow = false}, {double? scrollOffsetCorrection}, {double? cacheExtent}]
For class -> SliverHitTestResult
[]
[]
[HitTestResult result]
[HitTestResult result]
For class -> SliverHitTestEntry
[RenderSliver target, required this.mainAxisPosition, required this.crossAxisPosition]
[RenderSliver target, {required double mainAxisPosition}, {required double crossAxisPosition}]
For class -> SliverLogicalParentData
For class -> SliverLogicalContainerParentData
For class -> SliverPhysicalParentData
For class -> SliverPhysicalContainerParentData
For class -> RenderSliver
For class -> RenderSliverHelpers
For class -> RenderSliverSingleBoxAdapter
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderSliverToBoxAdapter
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderSliverFillViewport
[required RenderSliverBoxChildManager childManager, double viewportFraction = 1.0]
[{required RenderSliverBoxChildManager childManager}, {double viewportFraction = 1.0}]
For class -> RenderSliverFillRemainingWithScrollable
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderSliverFillRemaining
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderSliverFillRemainingAndOverscroll
[RenderBox? child]
[{RenderBox? child}]
For class -> RenderSliverFixedExtentBoxAdaptor
[required RenderSliverBoxChildManager childManager]
[{required RenderSliverBoxChildManager childManager}]
For class -> RenderSliverFixedExtentList
[required RenderSliverBoxChildManager childManager, required double itemExtent]
[{required RenderSliverBoxChildManager childManager}, {required double itemExtent}]
For class -> SliverGridGeometry
[required this.scrollOffset, required this.crossAxisOffset, required this.mainAxisExtent, required this.crossAxisExtent]
[{required double scrollOffset}, {required double crossAxisOffset}, {required double mainAxisExtent}, {required double crossAxisExtent}]
For class -> SliverGridLayout
[]
[]
For class -> SliverGridRegularTileLayout
[required this.crossAxisCount, required this.mainAxisStride, required this.crossAxisStride, required this.childMainAxisExtent, required this.childCrossAxisExtent, required this.reverseCrossAxis]
[{required int crossAxisCount}, {required double mainAxisStride}, {required double crossAxisStride}, {required double childMainAxisExtent}, {required double childCrossAxisExtent}, {required bool reverseCrossAxis}]
For class -> SliverGridDelegate
[]
[]
For class -> SliverGridDelegateWithFixedCrossAxisCount
[required this.crossAxisCount, this.mainAxisSpacing = 0.0, this.crossAxisSpacing = 0.0, this.childAspectRatio = 1.0, this.mainAxisExtent]
[{required int crossAxisCount}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {double? mainAxisExtent}]
For class -> SliverGridDelegateWithMaxCrossAxisExtent
[required this.maxCrossAxisExtent, this.mainAxisSpacing = 0.0, this.crossAxisSpacing = 0.0, this.childAspectRatio = 1.0, this.mainAxisExtent]
[{required double maxCrossAxisExtent}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {double? mainAxisExtent}]
For class -> SliverGridParentData
For class -> RenderSliverGrid
[required RenderSliverBoxChildManager childManager, required SliverGridDelegate gridDelegate]
[{required RenderSliverBoxChildManager childManager}, {required SliverGridDelegate gridDelegate}]
For class -> RenderSliverList
[required RenderSliverBoxChildManager childManager]
[{required RenderSliverBoxChildManager childManager}]
For class -> RenderSliverBoxChildManager
For class -> SliverMultiBoxAdaptorParentData
For class -> RenderSliverMultiBoxAdaptor
[required RenderSliverBoxChildManager childManager]
[{required RenderSliverBoxChildManager childManager}]
For class -> RenderSliverEdgeInsetsPadding
For class -> RenderSliverPadding
[required EdgeInsetsGeometry padding, TextDirection? textDirection, RenderSliver? child]
[{required EdgeInsetsGeometry padding}, {TextDirection? textDirection}, {RenderSliver? child}]
For class -> OverScrollHeaderStretchConfiguration
[this.stretchTriggerOffset = 100.0, this.onStretchTrigger]
[{double stretchTriggerOffset = 100.0}, {Future<void> Function()? onStretchTrigger}]
For class -> PersistentHeaderShowOnScreenConfiguration
[this.minShowOnScreenExtent = double.negativeInfinity, this.maxShowOnScreenExtent = double.infinity]
[{double minShowOnScreenExtent = double.negativeInfinity}, {double maxShowOnScreenExtent = double.infinity}]
For class -> RenderSliverPersistentHeader
[RenderBox? child, this.stretchConfiguration]
[{RenderBox? child}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}]
For class -> RenderSliverScrollingPersistentHeader
[RenderBox? child, OverScrollHeaderStretchConfiguration? stretchConfiguration]
[{RenderBox? child}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}]
For class -> RenderSliverPinnedPersistentHeader
[RenderBox? child, OverScrollHeaderStretchConfiguration? stretchConfiguration, this.showOnScreenConfiguration = const PersistentHeaderShowOnScreenConfiguration()]
[{RenderBox? child}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration = const PersistentHeaderShowOnScreenConfiguration()}]
For class -> FloatingHeaderSnapConfiguration
[@Deprecated('Specify SliverPersistentHeaderDelegate.vsync instead. ' 'This feature was deprecated after v1.19.0.') this.vsync, this.curve = Curves.ease, this.duration = const Duration(milliseconds: 300)]
[{TickerProvider? vsync}, {Curve curve = Curves.ease}, {Duration duration = const Duration(milliseconds: 300)}]
For class -> RenderSliverFloatingPersistentHeader
[RenderBox? child, TickerProvider? vsync, this.snapConfiguration, OverScrollHeaderStretchConfiguration? stretchConfiguration, required this.showOnScreenConfiguration]
[{RenderBox? child}, {TickerProvider? vsync}, {FloatingHeaderSnapConfiguration? snapConfiguration}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {required PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}]
For class -> RenderSliverFloatingPinnedPersistentHeader
[RenderBox? child, TickerProvider? vsync, FloatingHeaderSnapConfiguration? snapConfiguration, OverScrollHeaderStretchConfiguration? stretchConfiguration, PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration]
[{RenderBox? child}, {TickerProvider? vsync}, {FloatingHeaderSnapConfiguration? snapConfiguration}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}]
For class -> RelativeRect
[this.left, this.top, this.right, this.bottom]
[double left, double top, double right, double bottom]
[Rect rect, Size container]
[Rect rect, Size container]
[Rect rect, Rect container]
[Rect rect, Rect container]
For class -> StackParentData
For class -> RenderStack
[List<RenderBox>? children, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge]
[{List<RenderBox>? children}, {AlignmentGeometry alignment = AlignmentDirectional.topStart}, {TextDirection? textDirection}, {StackFit fit = StackFit.loose}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderIndexedStack
[List<RenderBox>? children, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, int? index = 0]
[{List<RenderBox>? children}, {AlignmentGeometry alignment = AlignmentDirectional.topStart}, {TextDirection? textDirection}, {int? index = 0}]
For class -> TableCellParentData
For class -> TableColumnWidth
[]
[]
For class -> IntrinsicColumnWidth
[double? flex]
[{double? flex}]
For class -> FixedColumnWidth
[this.value]
[double value]
For class -> FractionColumnWidth
[this.value]
[double value]
For class -> FlexColumnWidth
[this.value = 1.0]
[[double value = 1.0]]
For class -> MaxColumnWidth
[this.a, this.b]
[TableColumnWidth a, TableColumnWidth b]
For class -> MinColumnWidth
[this.a, this.b]
[TableColumnWidth a, TableColumnWidth b]
For class -> RenderTable
[int? columns, int? rows, Map<int, TableColumnWidth>? columnWidths, TableColumnWidth defaultColumnWidth = const FlexColumnWidth(1.0), required TextDirection textDirection, TableBorder? border, List<Decoration?>? rowDecorations, ImageConfiguration configuration = ImageConfiguration.empty, TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.top, TextBaseline? textBaseline, List<List<RenderBox>>? children]
[{int? columns}, {int? rows}, {Map<int, TableColumnWidth>? columnWidths}, {TableColumnWidth defaultColumnWidth = const FlexColumnWidth(1.0)}, {required TextDirection textDirection}, {TableBorder? border}, {List<Decoration?>? rowDecorations}, {ImageConfiguration configuration = ImageConfiguration.empty}, {TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.top}, {TextBaseline? textBaseline}, {List<List<RenderBox>>? children}]
For class -> TableBorder
[this.top = BorderSide.none, this.right = BorderSide.none, this.bottom = BorderSide.none, this.left = BorderSide.none, this.horizontalInside = BorderSide.none, this.verticalInside = BorderSide.none]
[{BorderSide top = BorderSide.none}, {BorderSide right = BorderSide.none}, {BorderSide bottom = BorderSide.none}, {BorderSide left = BorderSide.none}, {BorderSide horizontalInside = BorderSide.none}, {BorderSide verticalInside = BorderSide.none}]
[Color color = const Color(0xFF000000), double width = 1.0, BorderStyle style = BorderStyle.solid]
[{Color color = const Color(0xFF000000)}, {double width = 1.0}, {BorderStyle style = BorderStyle.solid}]
[BorderSide inside = BorderSide.none, BorderSide outside = BorderSide.none]
[{BorderSide inside = BorderSide.none}, {BorderSide outside = BorderSide.none}]
For class -> TextureBox
[required int textureId, FilterQuality filterQuality = FilterQuality.low]
[{required int textureId}, {FilterQuality filterQuality = FilterQuality.low}]
For class -> FractionalOffsetTween
[FractionalOffset? begin, FractionalOffset? end]
[{FractionalOffset? begin}, {FractionalOffset? end}]
For class -> AlignmentTween
[Alignment? begin, Alignment? end]
[{Alignment? begin}, {Alignment? end}]
For class -> AlignmentGeometryTween
[AlignmentGeometry? begin, AlignmentGeometry? end]
[{AlignmentGeometry? begin}, {AlignmentGeometry? end}]
For class -> ViewConfiguration
[this.size = Size.zero, this.devicePixelRatio = 1.0]
[{Size size = Size.zero}, {double devicePixelRatio = 1.0}]
For class -> RenderView
[RenderBox? child, required ViewConfiguration configuration, required ui.FlutterView window]
[{RenderBox? child}, {required ViewConfiguration configuration}, {required FlutterView window}]
For class -> RenderAbstractViewport
[]
[]
For class -> RevealedOffset
[required this.offset, required this.rect]
[{required double offset}, {required Rect rect}]
For class -> RenderViewportBase
[AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, double? cacheExtent, CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel, Clip clipBehavior = Clip.hardEdge]
[{AxisDirection axisDirection = AxisDirection.down}, {required AxisDirection crossAxisDirection}, {required ViewportOffset offset}, {double? cacheExtent}, {CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderViewport
[AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, double anchor = 0.0, List<RenderSliver>? children, RenderSliver? center, double? cacheExtent, CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel, Clip clipBehavior = Clip.hardEdge]
[{AxisDirection axisDirection = AxisDirection.down}, {required AxisDirection crossAxisDirection}, {required ViewportOffset offset}, {double anchor = 0.0}, {List<RenderSliver>? children}, {RenderSliver? center}, {double? cacheExtent}, {CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderShrinkWrappingViewport
[AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, Clip clipBehavior = Clip.hardEdge, List<RenderSliver>? children]
[{AxisDirection axisDirection = AxisDirection.down}, {required AxisDirection crossAxisDirection}, {required ViewportOffset offset}, {Clip clipBehavior = Clip.hardEdge}, {List<RenderSliver>? children}]
For class -> ViewportOffset
[]
[]
[double value]
[double value]
[]
[]
For class -> _FixedViewportOffset
[this._pixels]
[double _pixels]
[]
[]
For class -> _RunMetrics
[this.mainAxisExtent, this.crossAxisExtent, this.childCount]
[double mainAxisExtent, double crossAxisExtent, int childCount]
For class -> WrapParentData
For class -> RenderWrap
[List<RenderBox>? children, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none]
[{List<RenderBox>? children}, {Axis direction = Axis.horizontal}, {WrapAlignment alignment = WrapAlignment.start}, {double spacing = 0.0}, {WrapAlignment runAlignment = WrapAlignment.start}, {double runSpacing = 0.0}, {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {Clip clipBehavior = Clip.none}]
For class -> _TaskEntry
[this.task, this.priority, this.debugLabel, this.flow]
[T Function() task, int priority, String? debugLabel, Flow? flow]
For class -> _FrameCallbackEntry
[this.callback, bool rescheduling = false]
[void Function(Duration) callback, {bool rescheduling = false}]
For class -> Priority
[this._value]
[int _value]
For class -> TickerProvider
[]
[]
For class -> Ticker
[this._onTick, this.debugLabel]
[void Function(Duration) _onTick, {String? debugLabel}]
For class -> TickerFuture
[]
[]
[]
[]
For class -> TickerCanceled
[this.ticker]
[[Ticker? ticker]]
For class -> SemanticsTag
[this.name]
[String name]
For class -> CustomSemanticsAction
[required String this.label]
[{required String label}]
[required String this.hint, required SemanticsAction this.action]
[{required String hint}, {required SemanticsAction action}]
For class -> SemanticsData
[required this.flags, required this.actions, required this.label, required this.increasedValue, required this.value, required this.decreasedValue, required this.hint, required this.textDirection, required this.rect, required this.elevation, required this.thickness, required this.textSelection, required this.scrollIndex, required this.scrollChildCount, required this.scrollPosition, required this.scrollExtentMax, required this.scrollExtentMin, required this.platformViewId, required this.maxValueLength, required this.currentValueLength, this.tags, this.transform, this.customSemanticsActionIds]
[{required int flags}, {required int actions}, {required String label}, {required String increasedValue}, {required String value}, {required String decreasedValue}, {required String hint}, {required TextDirection? textDirection}, {required Rect rect}, {required double elevation}, {required double thickness}, {required TextSelection? textSelection}, {required int? scrollIndex}, {required int? scrollChildCount}, {required double? scrollPosition}, {required double? scrollExtentMax}, {required double? scrollExtentMin}, {required int? platformViewId}, {required int? maxValueLength}, {required int? currentValueLength}, {Set<SemanticsTag>? tags}, {Matrix4? transform}, {List<int>? customSemanticsActionIds}]
For class -> _SemanticsDiagnosticableNode
[String? name, required SemanticsNode value, required DiagnosticsTreeStyle? style, required this.childOrder]
[{String? name}, {required SemanticsNode value}, {required DiagnosticsTreeStyle? style}, {required DebugSemanticsDumpOrder childOrder}]
For class -> SemanticsHintOverrides
[this.onTapHint, this.onLongPressHint]
[{String? onTapHint}, {String? onLongPressHint}]
For class -> SemanticsProperties
[this.enabled, this.checked, this.selected, this.toggled, this.button, this.link, this.header, this.textField, this.slider, this.readOnly, this.focusable, this.focused, this.inMutuallyExclusiveGroup, this.hidden, this.obscured, this.multiline, this.scopesRoute, this.namesRoute, this.image, this.liveRegion, this.maxValueLength, this.currentValueLength, this.label, this.value, this.increasedValue, this.decreasedValue, this.hint, this.hintOverrides, this.textDirection, this.sortKey, this.tagForChildren, this.onTap, this.onLongPress, this.onScrollLeft, this.onScrollRight, this.onScrollUp, this.onScrollDown, this.onIncrease, this.onDecrease, this.onCopy, this.onCut, this.onPaste, this.onMoveCursorForwardByCharacter, this.onMoveCursorBackwardByCharacter, this.onMoveCursorForwardByWord, this.onMoveCursorBackwardByWord, this.onSetSelection, this.onDidGainAccessibilityFocus, this.onDidLoseAccessibilityFocus, this.onDismiss, this.customSemanticsActions]
[{bool? enabled}, {bool? checked}, {bool? selected}, {bool? toggled}, {bool? button}, {bool? link}, {bool? header}, {bool? textField}, {bool? slider}, {bool? readOnly}, {bool? focusable}, {bool? focused}, {bool? inMutuallyExclusiveGroup}, {bool? hidden}, {bool? obscured}, {bool? multiline}, {bool? scopesRoute}, {bool? namesRoute}, {bool? image}, {bool? liveRegion}, {int? maxValueLength}, {int? currentValueLength}, {String? label}, {String? value}, {String? increasedValue}, {String? decreasedValue}, {String? hint}, {SemanticsHintOverrides? hintOverrides}, {TextDirection? textDirection}, {SemanticsSortKey? sortKey}, {SemanticsTag? tagForChildren}, {void Function()? onTap}, {void Function()? onLongPress}, {void Function()? onScrollLeft}, {void Function()? onScrollRight}, {void Function()? onScrollUp}, {void Function()? onScrollDown}, {void Function()? onIncrease}, {void Function()? onDecrease}, {void Function()? onCopy}, {void Function()? onCut}, {void Function()? onPaste}, {void Function(bool)? onMoveCursorForwardByCharacter}, {void Function(bool)? onMoveCursorBackwardByCharacter}, {void Function(bool)? onMoveCursorForwardByWord}, {void Function(bool)? onMoveCursorBackwardByWord}, {void Function(TextSelection)? onSetSelection}, {void Function()? onDidGainAccessibilityFocus}, {void Function()? onDidLoseAccessibilityFocus}, {void Function()? onDismiss}, {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}]
For class -> SemanticsNode
[this.key, VoidCallback? showOnScreen]
[{Key? key}, {void Function()? showOnScreen}]
[this.key, VoidCallback? showOnScreen, required SemanticsOwner owner]
[{Key? key}, {void Function()? showOnScreen}, {required SemanticsOwner owner}]
For class -> _BoxEdge
[required this.isLeadingEdge, required this.offset, required this.node]
[{required bool isLeadingEdge}, {required double offset}, {required SemanticsNode node}]
For class -> _SemanticsSortGroup
[required this.startOffset, required this.textDirection]
[{required double startOffset}, {required TextDirection textDirection}]
For class -> _TraversalSortNode
[required this.node, this.sortKey, required this.position]
[{required SemanticsNode node}, {SemanticsSortKey? sortKey}, {required int position}]
For class -> SemanticsOwner
For class -> SemanticsConfiguration
For class -> SemanticsSortKey
[this.name]
[{String? name}]
For class -> OrdinalSortKey
[this.order, String? name]
[double order, {String? name}]
For class -> SemanticsEvent
[this.type]
[String type]
For class -> AnnounceSemanticsEvent
[this.message, this.textDirection]
[String message, TextDirection textDirection]
For class -> TooltipSemanticsEvent
[this.message]
[String message]
For class -> LongPressSemanticsEvent
[]
[]
For class -> TapSemanticEvent
[]
[]
For class -> UpdateLiveRegionEvent
[]
[]
For class -> SemanticsService
[]
[]
For class -> AssetBundle
For class -> NetworkAssetBundle
[Uri baseUrl]
[Uri baseUrl]
For class -> CachingAssetBundle
For class -> PlatformAssetBundle
For class -> AutofillHints
[]
[]
For class -> AutofillConfiguration
[required this.uniqueIdentifier, required this.autofillHints, required this.currentEditingValue]
[{required String uniqueIdentifier}, {required List<String> autofillHints}, {required TextEditingValue currentEditingValue}]
For class -> AutofillClient
For class -> AutofillScope
For class -> _AutofillScopeTextInputConfiguration
[required this.allConfigurations, required TextInputConfiguration currentClientConfiguration]
[{required Iterable<TextInputConfiguration> allConfigurations}, {required TextInputConfiguration currentClientConfiguration}]
For class -> BinaryMessenger
[]
[]
For class -> _DefaultBinaryMessenger
[]
[]
For class -> ClipboardData
[this.text]
[{String? text}]
For class -> Clipboard
[]
[]
For class -> DeferredComponent
[]
[]
For class -> FontLoader
[this.family]
[String family]
For class -> HapticFeedback
[]
[]
For class -> KeyboardKey
[]
[]
For class -> LogicalKeyboardKey
[this.keyId, this.debugName, this.keyLabel = '']
[int keyId, {String? debugName}, {String keyLabel = ''}]
For class -> PhysicalKeyboardKey
[this.usbHidUsage, this.debugName]
[int usbHidUsage, {String? debugName}]
For class -> MessageCodec
For class -> MethodCall
[this.method, this.arguments]
[String method, [dynamic arguments]]
For class -> MethodCodec
For class -> PlatformException
[required this.code, this.message, this.details, this.stacktrace]
[{required String code}, {String? message}, {dynamic details}, {String? stacktrace}]
For class -> MissingPluginException
[this.message]
[[String? message]]
For class -> BinaryCodec
[]
[]
For class -> StringCodec
[]
[]
For class -> JSONMessageCodec
[]
[]
For class -> JSONMethodCodec
[]
[]
For class -> StandardMessageCodec
[]
[]
For class -> StandardMethodCodec
[this.messageCodec = const StandardMessageCodec()]
[[StandardMessageCodec messageCodec = const StandardMessageCodec()]]
For class -> BasicMessageChannel
[this.name, this.codec, BinaryMessenger? binaryMessenger]
[String name, MessageCodec<T> codec, {BinaryMessenger? binaryMessenger}]
For class -> MethodChannel
[this.name, this.codec = const StandardMethodCodec(), BinaryMessenger? binaryMessenger]
[String name, [MethodCodec codec = const StandardMethodCodec()], [BinaryMessenger? binaryMessenger]]
For class -> OptionalMethodChannel
[String name, MethodCodec codec = const StandardMethodCodec()]
[String name, [MethodCodec codec = const StandardMethodCodec()]]
For class -> EventChannel
[this.name, this.codec = const StandardMethodCodec(), BinaryMessenger? binaryMessenger]
[String name, [MethodCodec codec = const StandardMethodCodec()], [BinaryMessenger? binaryMessenger]]
For class -> BinaryMessages
[]
[]
For class -> PlatformViewsRegistry
[]
[]
For class -> PlatformViewsService
[]
[]
For class -> AndroidPointerProperties
[required this.id, required this.toolType]
[{required int id}, {required int toolType}]
For class -> AndroidPointerCoords
[required this.orientation, required this.pressure, required this.size, required this.toolMajor, required this.toolMinor, required this.touchMajor, required this.touchMinor, required this.x, required this.y]
[{required double orientation}, {required double pressure}, {required double size}, {required double toolMajor}, {required double toolMinor}, {required double touchMajor}, {required double touchMinor}, {required double x}, {required double y}]
For class -> AndroidMotionEvent
[required this.downTime, required this.eventTime, required this.action, required this.pointerCount, required this.pointerProperties, required this.pointerCoords, required this.metaState, required this.buttonState, required this.xPrecision, required this.yPrecision, required this.deviceId, required this.edgeFlags, required this.source, required this.flags, required this.motionEventId]
[{required int downTime}, {required int eventTime}, {required int action}, {required int pointerCount}, {required List<AndroidPointerProperties> pointerProperties}, {required List<AndroidPointerCoords> pointerCoords}, {required int metaState}, {required int buttonState}, {required double xPrecision}, {required double yPrecision}, {required int deviceId}, {required int edgeFlags}, {required int source}, {required int flags}, {required int motionEventId}]
For class -> _AndroidMotionEventConverter
[]
[]
For class -> AndroidViewController
[required this.viewId, required String viewType, required TextDirection layoutDirection, dynamic creationParams, MessageCodec<dynamic>? creationParamsCodec, bool waitingForSize = false]
[{required int viewId}, {required String viewType}, {required TextDirection layoutDirection}, {dynamic creationParams}, {MessageCodec<dynamic>? creationParamsCodec}, {bool waitingForSize = false}]
For class -> SurfaceAndroidViewController
[required int viewId, required String viewType, required TextDirection layoutDirection, dynamic creationParams, MessageCodec<dynamic>? creationParamsCodec]
[{required int viewId}, {required String viewType}, {required TextDirection layoutDirection}, {dynamic creationParams}, {MessageCodec<dynamic>? creationParamsCodec}]
For class -> TextureAndroidViewController
[required int viewId, required String viewType, required TextDirection layoutDirection, dynamic creationParams, MessageCodec<dynamic>? creationParamsCodec]
[{required int viewId}, {required String viewType}, {required TextDirection layoutDirection}, {dynamic creationParams}, {MessageCodec<dynamic>? creationParamsCodec}]
For class -> UiKitViewController
[this.id, TextDirection layoutDirection]
[int id, TextDirection layoutDirection]
For class -> PlatformViewController
For class -> RawKeyEventData
[]
[]
For class -> RawKeyEvent
[required this.data, this.character]
[{required RawKeyEventData data}, {String? character}]
[Map<String, dynamic> message]
[Map<String, dynamic> message]
For class -> RawKeyDownEvent
[required RawKeyEventData data, String? character]
[{required RawKeyEventData data}, {String? character}]
For class -> RawKeyUpEvent
[required RawKeyEventData data, String? character]
[{required RawKeyEventData data}, {String? character}]
For class -> RawKeyboard
[]
[]
For class -> _ModifierSidePair
[this.modifier, this.side]
[ModifierKey modifier, KeyboardSide? side]
For class -> RawKeyEventDataAndroid
[this.flags = 0, this.codePoint = 0, this.plainCodePoint = 0, this.keyCode = 0, this.scanCode = 0, this.metaState = 0, this.eventSource = 0, this.vendorId = 0, this.productId = 0, this.deviceId = 0, this.repeatCount = 0]
[{int flags = 0}, {int codePoint = 0}, {int plainCodePoint = 0}, {int keyCode = 0}, {int scanCode = 0}, {int metaState = 0}, {int eventSource = 0}, {int vendorId = 0}, {int productId = 0}, {int deviceId = 0}, {int repeatCount = 0}]
For class -> RawKeyEventDataFuchsia
[this.hidUsage = 0, this.codePoint = 0, this.modifiers = 0]
[{int hidUsage = 0}, {int codePoint = 0}, {int modifiers = 0}]
For class -> RawKeyEventDataIos
[this.characters = '', this.charactersIgnoringModifiers = '', this.keyCode = 0, this.modifiers = 0]
[{String characters = ''}, {String charactersIgnoringModifiers = ''}, {int keyCode = 0}, {int modifiers = 0}]
For class -> RawKeyEventDataLinux
[required this.keyHelper, this.unicodeScalarValues = 0, this.scanCode = 0, this.keyCode = 0, this.modifiers = 0, required this.isDown]
[{required KeyHelper keyHelper}, {int unicodeScalarValues = 0}, {int scanCode = 0}, {int keyCode = 0}, {int modifiers = 0}, {required bool isDown}]
For class -> KeyHelper
[String toolkit]
[String toolkit]
For class -> GLFWKeyHelper
For class -> GtkKeyHelper
For class -> RawKeyEventDataMacOs
[this.characters = '', this.charactersIgnoringModifiers = '', this.keyCode = 0, this.modifiers = 0]
[{String characters = ''}, {String charactersIgnoringModifiers = ''}, {int keyCode = 0}, {int modifiers = 0}]
For class -> RawKeyEventDataWeb
[required this.code, required this.key, this.metaState = modifierNone]
[{required String code}, {required String key}, {int metaState = modifierNone}]
For class -> RawKeyEventDataWindows
[this.keyCode = 0, this.scanCode = 0, this.characterCodePoint = 0, this.modifiers = 0]
[{int keyCode = 0}, {int scanCode = 0}, {int characterCodePoint = 0}, {int modifiers = 0}]
For class -> RestorationManager
[]
[]
For class -> RestorationBucket
[required String restorationId, required Object? debugOwner]
[{required String restorationId}, {required Object? debugOwner}]
[required RestorationManager manager, required Map<dynamic, dynamic>? rawData]
[{required RestorationManager manager}, {required Map<dynamic, dynamic>? rawData}]
[required String restorationId, required RestorationBucket parent, required Object? debugOwner]
[{required String restorationId}, {required RestorationBucket parent}, {required Object? debugOwner}]
For class -> SystemChannels
[]
[]
For class -> ApplicationSwitcherDescription
[this.label, this.primaryColor]
[{String? label}, {int? primaryColor}]
For class -> SystemUiOverlayStyle
[this.systemNavigationBarColor, this.systemNavigationBarDividerColor, this.systemNavigationBarIconBrightness, this.statusBarColor, this.statusBarBrightness, this.statusBarIconBrightness]
[{Color? systemNavigationBarColor}, {Color? systemNavigationBarDividerColor}, {Brightness? systemNavigationBarIconBrightness}, {Color? statusBarColor}, {Brightness? statusBarBrightness}, {Brightness? statusBarIconBrightness}]
For class -> SystemChrome
[]
[]
For class -> SystemNavigator
[]
[]
For class -> SystemSound
[]
[]
For class -> TextSelection
[required this.baseOffset, required this.extentOffset, this.affinity = TextAffinity.downstream, this.isDirectional = false]
[{required int baseOffset}, {required int extentOffset}, {TextAffinity affinity = TextAffinity.downstream}, {bool isDirectional = false}]
[required int offset, this.affinity = TextAffinity.downstream]
[{required int offset}, {TextAffinity affinity = TextAffinity.downstream}]
[TextPosition position]
[TextPosition position]
For class -> TextInputFormatter
For class -> _SimpleTextInputFormatter
[this.formatFunction]
[TextEditingValue Function(TextEditingValue, TextEditingValue) formatFunction]
For class -> FilteringTextInputFormatter
[this.filterPattern, required this.allow, this.replacementString = '']
[Pattern filterPattern, {required bool allow}, {String replacementString = ''}]
[this.filterPattern, this.replacementString = '']
[Pattern filterPattern, {String replacementString = ''}]
[this.filterPattern, this.replacementString = '']
[Pattern filterPattern, {String replacementString = ''}]
For class -> BlacklistingTextInputFormatter
[Pattern blacklistedPattern, String replacementString = '']
[Pattern blacklistedPattern, {String replacementString = ''}]
For class -> WhitelistingTextInputFormatter
[Pattern whitelistedPattern]
[Pattern whitelistedPattern]
For class -> LengthLimitingTextInputFormatter
[this.maxLength, this.maxLengthEnforcement]
[int? maxLength, {MaxLengthEnforcement? maxLengthEnforcement}]
For class -> TextInputType
[this.index]
[int index]
[this.signed = false, this.decimal = false]
[{bool? signed = false}, {bool? decimal = false}]
For class -> TextInputConfiguration
[this.inputType = TextInputType.text, this.readOnly = false, this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, this.enableSuggestions = true, this.actionLabel, this.inputAction = TextInputAction.done, this.keyboardAppearance = Brightness.light, this.textCapitalization = TextCapitalization.none, this.autofillConfiguration]
[{TextInputType inputType = TextInputType.text}, {bool readOnly = false}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {String? actionLabel}, {TextInputAction inputAction = TextInputAction.done}, {Brightness keyboardAppearance = Brightness.light}, {TextCapitalization textCapitalization = TextCapitalization.none}, {AutofillConfiguration? autofillConfiguration}]
For class -> RawFloatingCursorPoint
[this.offset, required this.state]
[{Offset? offset}, {required FloatingCursorDragState state}]
For class -> TextEditingValue
[this.text = '', this.selection = const TextSelection.collapsed(offset: -1), this.composing = TextRange.empty]
[{String text = ''}, {TextSelection selection = const TextSelection.collapsed(offset: -1)}, {TextRange composing = TextRange.empty}]
[Map<String, dynamic> encoded]
[Map<String, dynamic> encoded]
For class -> TextSelectionDelegate
For class -> TextInputClient
[]
[]
For class -> TextInputConnection
[this._client]
[TextInputClient _client]
For class -> TextInput
[]
[]
For class -> Intent
[]
[]
For class -> Action
For class -> ActionListener
[Key? key, required this.listener, required this.action, required this.child]
[{Key? key}, {required void Function(Action<Intent>) listener}, {required Action<Intent> action}, {required Widget child}]
For class -> _ActionListenerState
For class -> ContextAction
For class -> CallbackAction
[required this.onInvoke]
[{required Object? Function(T) onInvoke}]
For class -> ActionDispatcher
[]
[]
For class -> Actions
[Key? key, this.dispatcher, required this.actions, required this.child]
[{Key? key}, {ActionDispatcher? dispatcher}, {required Map<Type, Action<Intent>> actions}, {required Widget child}]
For class -> _ActionsState
For class -> _ActionsMarker
[required this.dispatcher, required this.actions, required this.rebuildKey, Key? key, required Widget child]
[{required ActionDispatcher? dispatcher}, {required Map<Type, Action<Intent>> actions}, {required Object rebuildKey}, {Key? key}, {required Widget child}]
For class -> FocusableActionDetector
[Key? key, this.enabled = true, this.focusNode, this.autofocus = false, this.shortcuts, this.actions, this.onShowFocusHighlight, this.onShowHoverHighlight, this.onFocusChange, this.mouseCursor = MouseCursor.defer, required this.child]
[{Key? key}, {bool enabled = true}, {FocusNode? focusNode}, {bool autofocus = false}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {void Function(bool)? onShowFocusHighlight}, {void Function(bool)? onShowHoverHighlight}, {void Function(bool)? onFocusChange}, {MouseCursor mouseCursor = MouseCursor.defer}, {required Widget child}]
For class -> _FocusableActionDetectorState
For class -> DoNothingIntent
[]
[]
[]
[]
For class -> DoNothingAndStopPropagationIntent
[]
[]
[]
[]
For class -> DoNothingAction
[bool consumesKey = true]
[{bool consumesKey = true}]
For class -> ActivateIntent
[]
[]
For class -> ButtonActivateIntent
[]
[]
For class -> ActivateAction
For class -> SelectIntent
For class -> SelectAction
For class -> DismissIntent
[]
[]
For class -> DismissAction
For class -> PrioritizedIntents
[required this.orderedIntents]
[{required List<Intent> orderedIntents}]
For class -> PrioritizedAction
For class -> AnimatedCrossFade
[Key? key, required this.firstChild, required this.secondChild, this.firstCurve = Curves.linear, this.secondCurve = Curves.linear, this.sizeCurve = Curves.linear, this.alignment = Alignment.topCenter, required this.crossFadeState, required this.duration, this.reverseDuration, this.layoutBuilder = defaultLayoutBuilder]
[{Key? key}, {required Widget firstChild}, {required Widget secondChild}, {Curve firstCurve = Curves.linear}, {Curve secondCurve = Curves.linear}, {Curve sizeCurve = Curves.linear}, {AlignmentGeometry alignment = Alignment.topCenter}, {required CrossFadeState crossFadeState}, {required Duration duration}, {Duration? reverseDuration}, {Widget Function(Widget, Key, Widget, Key) layoutBuilder = defaultLayoutBuilder}]
For class -> _AnimatedCrossFadeState
For class -> _ActiveItem
[this.controller, this.itemIndex]
[AnimationController? controller, int itemIndex]
[this.controller, this.itemIndex, this.removedItemBuilder]
[AnimationController? controller, int itemIndex, Widget Function(BuildContext, Animation<double>)? removedItemBuilder]
[this.itemIndex]
[int itemIndex]
For class -> AnimatedList
[Key? key, required this.itemBuilder, this.initialItemCount = 0, this.scrollDirection = Axis.vertical, this.reverse = false, this.controller, this.primary, this.physics, this.shrinkWrap = false, this.padding]
[{Key? key}, {required Widget Function(BuildContext, int, Animation<double>) itemBuilder}, {int initialItemCount = 0}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}]
For class -> AnimatedListState
For class -> SliverAnimatedList
[Key? key, required this.itemBuilder, this.initialItemCount = 0]
[{Key? key}, {required Widget Function(BuildContext, int, Animation<double>) itemBuilder}, {int initialItemCount = 0}]
For class -> SliverAnimatedListState
For class -> AnimatedSize
[Key? key, Widget? child, this.alignment = Alignment.center, this.curve = Curves.linear, required this.duration, this.reverseDuration, required this.vsync, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {Widget? child}, {AlignmentGeometry alignment = Alignment.center}, {Curve curve = Curves.linear}, {required Duration duration}, {Duration? reverseDuration}, {required TickerProvider vsync}, {Clip clipBehavior = Clip.hardEdge}]
For class -> _ChildEntry
[required this.controller, required this.animation, required this.transition, required this.widgetChild]
[{required AnimationController controller}, {required Animation<double> animation}, {required Widget transition}, {required Widget widgetChild}]
For class -> AnimatedSwitcher
[Key? key, this.child, required this.duration, this.reverseDuration, this.switchInCurve = Curves.linear, this.switchOutCurve = Curves.linear, this.transitionBuilder = AnimatedSwitcher.defaultTransitionBuilder, this.layoutBuilder = AnimatedSwitcher.defaultLayoutBuilder]
[{Key? key}, {Widget? child}, {required Duration duration}, {Duration? reverseDuration}, {Curve switchInCurve = Curves.linear}, {Curve switchOutCurve = Curves.linear}, {Widget Function(Widget, Animation<double>) transitionBuilder = AnimatedSwitcher.defaultTransitionBuilder}, {Widget Function(Widget?, List<Widget>) layoutBuilder = AnimatedSwitcher.defaultLayoutBuilder}]
For class -> _AnimatedSwitcherState
For class -> AnnotatedRegion
[Key? key, required Widget child, required this.value, this.sized = true]
[{Key? key}, {required Widget child}, {required T value}, {bool sized = true}]
For class -> WidgetsApp
[Key? key, this.navigatorKey, this.onGenerateRoute, this.onGenerateInitialRoutes, this.onUnknownRoute, List<NavigatorObserver> this.navigatorObservers = const <NavigatorObserver>[], this.initialRoute, this.pageRouteBuilder, this.home, Map<String, WidgetBuilder> this.routes = const <String, WidgetBuilder>{}, this.builder, this.title = '', this.onGenerateTitle, this.textStyle, required this.color, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowWidgetInspector = false, this.debugShowCheckedModeBanner = true, this.inspectorSelectButtonBuilder, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {GlobalKey<NavigatorState>? navigatorKey}, {Route<dynamic>? Function(RouteSettings)? onGenerateRoute}, {List<Route<dynamic>> Function(String)? onGenerateInitialRoutes}, {Route<dynamic>? Function(RouteSettings)? onUnknownRoute}, {List<NavigatorObserver> navigatorObservers = const <NavigatorObserver>[]}, {String? initialRoute}, {PageRoute<T> Function<T>(RouteSettings, Widget Function(BuildContext))? pageRouteBuilder}, {Widget? home}, {Map<String, Widget Function(BuildContext)> routes = const <String, WidgetBuilder>{}}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {TextStyle? textStyle}, {required Color color}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowWidgetInspector = false}, {bool debugShowCheckedModeBanner = true}, {Widget Function(BuildContext, void Function())? inspectorSelectButtonBuilder}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
[Key? key, this.routeInformationProvider, required RouteInformationParser<Object> this.routeInformationParser, required RouterDelegate<Object> this.routerDelegate, BackButtonDispatcher? backButtonDispatcher, this.builder, this.title = '', this.onGenerateTitle, this.textStyle, required this.color, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const <Locale>[Locale('en', 'US')], this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowWidgetInspector = false, this.debugShowCheckedModeBanner = true, this.inspectorSelectButtonBuilder, this.shortcuts, this.actions, this.restorationScopeId]
[{Key? key}, {RouteInformationProvider? routeInformationProvider}, {required RouteInformationParser<Object> routeInformationParser}, {required RouterDelegate<Object> routerDelegate}, {BackButtonDispatcher? backButtonDispatcher}, {Widget Function(BuildContext, Widget?)? builder}, {String title = ''}, {String Function(BuildContext)? onGenerateTitle}, {TextStyle? textStyle}, {required Color color}, {Locale? locale}, {Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates}, {Locale? Function(List<Locale>?, Iterable<Locale>)? localeListResolutionCallback}, {Locale? Function(Locale?, Iterable<Locale>)? localeResolutionCallback}, {Iterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')]}, {bool showPerformanceOverlay = false}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}, {bool showSemanticsDebugger = false}, {bool debugShowWidgetInspector = false}, {bool debugShowCheckedModeBanner = true}, {Widget Function(BuildContext, void Function())? inspectorSelectButtonBuilder}, {Map<LogicalKeySet, Intent>? shortcuts}, {Map<Type, Action<Intent>>? actions}, {String? restorationScopeId}]
For class -> _WidgetsAppState
For class -> _MediaQueryFromWindow
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> _MediaQueryFromWindowsState
For class -> StreamBuilderBase
[Key? key, this.stream]
[{Key? key}, {Stream<T>? stream}]
For class -> _StreamBuilderBaseState
For class -> AsyncSnapshot
[this.connectionState, this.data, this.error, this.stackTrace]
[ConnectionState connectionState, T? data, Object? error, StackTrace? stackTrace]
[]
[]
[]
[]
[ConnectionState state, T data]
[ConnectionState state, T data]
[ConnectionState state, Object error, StackTrace stackTrace = StackTrace.empty]
[ConnectionState state, Object error, [StackTrace stackTrace = StackTrace.empty]]
For class -> StreamBuilder
[Key? key, this.initialData, Stream<T>? stream, required this.builder]
[{Key? key}, {T? initialData}, {Stream<T>? stream}, {required Widget Function(BuildContext, AsyncSnapshot<T>) builder}]
For class -> FutureBuilder
[Key? key, this.future, this.initialData, required this.builder]
[{Key? key}, {Future<T>? future}, {T? initialData}, {required Widget Function(BuildContext, AsyncSnapshot<T>) builder}]
For class -> _FutureBuilderState
For class -> RawAutocomplete
[Key? key, required this.optionsViewBuilder, required this.optionsBuilder, this.displayStringForOption = defaultStringForOption, this.fieldViewBuilder, this.focusNode, this.onSelected, this.textEditingController]
[{Key? key}, {required Widget Function(BuildContext, void Function(T), Iterable<T>) optionsViewBuilder}, {required Iterable<T> Function(TextEditingValue) optionsBuilder}, {String Function(T) displayStringForOption = defaultStringForOption}, {Widget Function(BuildContext, TextEditingController, FocusNode, void Function())? fieldViewBuilder}, {FocusNode? focusNode}, {void Function(T)? onSelected}, {TextEditingController? textEditingController}]
For class -> _RawAutocompleteState
For class -> AutofillGroup
[Key? key, required this.child, this.onDisposeAction = AutofillContextAction.commit]
[{Key? key}, {required Widget child}, {AutofillContextAction onDisposeAction = AutofillContextAction.commit}]
For class -> AutofillGroupState
For class -> _AutofillScope
[Key? key, required Widget child, AutofillGroupState? autofillScopeState]
[{Key? key}, {required Widget child}, {AutofillGroupState? autofillScopeState}]
For class -> AutomaticKeepAlive
[Key? key, this.child]
[{Key? key}, {Widget? child}]
For class -> _AutomaticKeepAliveState
For class -> KeepAliveNotification
[this.handle]
[Listenable handle]
For class -> KeepAliveHandle
For class -> _NullWidget
[]
[]
For class -> BannerPainter
[required this.message, required this.textDirection, required this.location, required this.layoutDirection, this.color = _kColor, this.textStyle = _kTextStyle]
[{required String message}, {required TextDirection textDirection}, {required BannerLocation location}, {required TextDirection layoutDirection}, {Color color = _kColor}, {TextStyle textStyle = _kTextStyle}]
For class -> Banner
[Key? key, this.child, required this.message, this.textDirection, required this.location, this.layoutDirection, this.color = _kColor, this.textStyle = _kTextStyle]
[{Key? key}, {Widget? child}, {required String message}, {TextDirection? textDirection}, {required BannerLocation location}, {TextDirection? layoutDirection}, {Color color = _kColor}, {TextStyle textStyle = _kTextStyle}]
For class -> CheckedModeBanner
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> Directionality
[Key? key, required this.textDirection, required Widget child]
[{Key? key}, {required TextDirection textDirection}, {required Widget child}]
For class -> Opacity
[Key? key, required this.opacity, this.alwaysIncludeSemantics = false, Widget? child]
[{Key? key}, {required double opacity}, {bool alwaysIncludeSemantics = false}, {Widget? child}]
For class -> ShaderMask
[Key? key, required this.shaderCallback, this.blendMode = BlendMode.modulate, Widget? child]
[{Key? key}, {required Shader Function(Rect) shaderCallback}, {BlendMode blendMode = BlendMode.modulate}, {Widget? child}]
For class -> BackdropFilter
[Key? key, required this.filter, Widget? child]
[{Key? key}, {required ImageFilter filter}, {Widget? child}]
For class -> CustomPaint
[Key? key, this.painter, this.foregroundPainter, this.size = Size.zero, this.isComplex = false, this.willChange = false, Widget? child]
[{Key? key}, {CustomPainter? painter}, {CustomPainter? foregroundPainter}, {Size size = Size.zero}, {bool isComplex = false}, {bool willChange = false}, {Widget? child}]
For class -> ClipRect
[Key? key, this.clipper, this.clipBehavior = Clip.hardEdge, Widget? child]
[{Key? key}, {CustomClipper<Rect>? clipper}, {Clip clipBehavior = Clip.hardEdge}, {Widget? child}]
For class -> ClipRRect
[Key? key, this.borderRadius = BorderRadius.zero, this.clipper, this.clipBehavior = Clip.antiAlias, Widget? child]
[{Key? key}, {BorderRadius? borderRadius = BorderRadius.zero}, {CustomClipper<RRect>? clipper}, {Clip clipBehavior = Clip.antiAlias}, {Widget? child}]
For class -> ClipOval
[Key? key, this.clipper, this.clipBehavior = Clip.antiAlias, Widget? child]
[{Key? key}, {CustomClipper<Rect>? clipper}, {Clip clipBehavior = Clip.antiAlias}, {Widget? child}]
For class -> ClipPath
[Key? key, this.clipper, this.clipBehavior = Clip.antiAlias, Widget? child]
[{Key? key}, {CustomClipper<Path>? clipper}, {Clip clipBehavior = Clip.antiAlias}, {Widget? child}]
For class -> PhysicalModel
[Key? key, this.shape = BoxShape.rectangle, this.clipBehavior = Clip.none, this.borderRadius, this.elevation = 0.0, required this.color, this.shadowColor = const Color(0xFF000000), Widget? child]
[{Key? key}, {BoxShape shape = BoxShape.rectangle}, {Clip clipBehavior = Clip.none}, {BorderRadius? borderRadius}, {double elevation = 0.0}, {required Color color}, {Color shadowColor = const Color(0xFF000000)}, {Widget? child}]
For class -> PhysicalShape
[Key? key, required this.clipper, this.clipBehavior = Clip.none, this.elevation = 0.0, required this.color, this.shadowColor = const Color(0xFF000000), Widget? child]
[{Key? key}, {required CustomClipper<Path> clipper}, {Clip clipBehavior = Clip.none}, {double elevation = 0.0}, {required Color color}, {Color shadowColor = const Color(0xFF000000)}, {Widget? child}]
For class -> Transform
[Key? key, required this.transform, this.origin, this.alignment, this.transformHitTests = true, Widget? child]
[{Key? key}, {required Matrix4 transform}, {Offset? origin}, {AlignmentGeometry? alignment}, {bool transformHitTests = true}, {Widget? child}]
[Key? key, required double angle, this.origin, this.alignment = Alignment.center, this.transformHitTests = true, Widget? child]
[{Key? key}, {required double angle}, {Offset? origin}, {AlignmentGeometry? alignment = Alignment.center}, {bool transformHitTests = true}, {Widget? child}]
[Key? key, required Offset offset, this.transformHitTests = true, Widget? child]
[{Key? key}, {required Offset offset}, {bool transformHitTests = true}, {Widget? child}]
[Key? key, required double scale, this.origin, this.alignment = Alignment.center, this.transformHitTests = true, Widget? child]
[{Key? key}, {required double scale}, {Offset? origin}, {AlignmentGeometry? alignment = Alignment.center}, {bool transformHitTests = true}, {Widget? child}]
For class -> CompositedTransformTarget
[Key? key, required this.link, Widget? child]
[{Key? key}, {required LayerLink link}, {Widget? child}]
For class -> CompositedTransformFollower
[Key? key, required this.link, this.showWhenUnlinked = true, this.offset = Offset.zero, this.targetAnchor = Alignment.topLeft, this.followerAnchor = Alignment.topLeft, Widget? child]
[{Key? key}, {required LayerLink link}, {bool showWhenUnlinked = true}, {Offset offset = Offset.zero}, {Alignment targetAnchor = Alignment.topLeft}, {Alignment followerAnchor = Alignment.topLeft}, {Widget? child}]
For class -> FittedBox
[Key? key, this.fit = BoxFit.contain, this.alignment = Alignment.center, this.clipBehavior = Clip.none, Widget? child]
[{Key? key}, {BoxFit fit = BoxFit.contain}, {AlignmentGeometry alignment = Alignment.center}, {Clip clipBehavior = Clip.none}, {Widget? child}]
For class -> FractionalTranslation
[Key? key, required this.translation, this.transformHitTests = true, Widget? child]
[{Key? key}, {required Offset translation}, {bool transformHitTests = true}, {Widget? child}]
For class -> RotatedBox
[Key? key, required this.quarterTurns, Widget? child]
[{Key? key}, {required int quarterTurns}, {Widget? child}]
For class -> Padding
[Key? key, required this.padding, Widget? child]
[{Key? key}, {required EdgeInsetsGeometry padding}, {Widget? child}]
For class -> Align
[Key? key, this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget? child]
[{Key? key}, {AlignmentGeometry alignment = Alignment.center}, {double? widthFactor}, {double? heightFactor}, {Widget? child}]
For class -> Center
[Key? key, double? widthFactor, double? heightFactor, Widget? child]
[{Key? key}, {double? widthFactor}, {double? heightFactor}, {Widget? child}]
For class -> CustomSingleChildLayout
[Key? key, required this.delegate, Widget? child]
[{Key? key}, {required SingleChildLayoutDelegate delegate}, {Widget? child}]
For class -> LayoutId
[Key? key, required this.id, required Widget child]
[{Key? key}, {required Object id}, {required Widget child}]
For class -> CustomMultiChildLayout
[Key? key, required this.delegate, List<Widget> children = const <Widget>[]]
[{Key? key}, {required MultiChildLayoutDelegate delegate}, {List<Widget> children = const <Widget>[]}]
For class -> SizedBox
[Key? key, this.width, this.height, Widget? child]
[{Key? key}, {double? width}, {double? height}, {Widget? child}]
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
[Key? key, Widget? child, Size? size]
[{Key? key}, {Widget? child}, {Size? size}]
For class -> ConstrainedBox
[Key? key, required this.constraints, Widget? child]
[{Key? key}, {required BoxConstraints constraints}, {Widget? child}]
For class -> UnconstrainedBox
[Key? key, Widget? child, this.textDirection, this.alignment = Alignment.center, this.constrainedAxis, this.clipBehavior = Clip.none]
[{Key? key}, {Widget? child}, {TextDirection? textDirection}, {AlignmentGeometry alignment = Alignment.center}, {Axis? constrainedAxis}, {Clip clipBehavior = Clip.none}]
For class -> FractionallySizedBox
[Key? key, this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget? child]
[{Key? key}, {AlignmentGeometry alignment = Alignment.center}, {double? widthFactor}, {double? heightFactor}, {Widget? child}]
For class -> LimitedBox
[Key? key, this.maxWidth = double.infinity, this.maxHeight = double.infinity, Widget? child]
[{Key? key}, {double maxWidth = double.infinity}, {double maxHeight = double.infinity}, {Widget? child}]
For class -> OverflowBox
[Key? key, this.alignment = Alignment.center, this.minWidth, this.maxWidth, this.minHeight, this.maxHeight, Widget? child]
[{Key? key}, {AlignmentGeometry alignment = Alignment.center}, {double? minWidth}, {double? maxWidth}, {double? minHeight}, {double? maxHeight}, {Widget? child}]
For class -> SizedOverflowBox
[Key? key, required this.size, this.alignment = Alignment.center, Widget? child]
[{Key? key}, {required Size size}, {AlignmentGeometry alignment = Alignment.center}, {Widget? child}]
For class -> Offstage
[Key? key, this.offstage = true, Widget? child]
[{Key? key}, {bool offstage = true}, {Widget? child}]
For class -> _OffstageElement
[Offstage widget]
[Offstage widget]
For class -> AspectRatio
[Key? key, required this.aspectRatio, Widget? child]
[{Key? key}, {required double aspectRatio}, {Widget? child}]
For class -> IntrinsicWidth
[Key? key, this.stepWidth, this.stepHeight, Widget? child]
[{Key? key}, {double? stepWidth}, {double? stepHeight}, {Widget? child}]
For class -> IntrinsicHeight
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> Baseline
[Key? key, required this.baseline, required this.baselineType, Widget? child]
[{Key? key}, {required double baseline}, {required TextBaseline baselineType}, {Widget? child}]
For class -> SliverToBoxAdapter
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> SliverPadding
[Key? key, required this.padding, Widget? sliver]
[{Key? key}, {required EdgeInsetsGeometry padding}, {Widget? sliver}]
For class -> ListBody
[Key? key, this.mainAxis = Axis.vertical, this.reverse = false, List<Widget> children = const <Widget>[]]
[{Key? key}, {Axis mainAxis = Axis.vertical}, {bool reverse = false}, {List<Widget> children = const <Widget>[]}]
For class -> Stack
[Key? key, this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, @Deprecated('Use clipBehavior instead. See the migration guide in flutter.dev/go/clip-behavior. ' 'This feature was deprecated after v1.22.0-12.0.pre.') this.overflow = Overflow.clip, this.clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]]
[{Key? key}, {AlignmentGeometry alignment = AlignmentDirectional.topStart}, {TextDirection? textDirection}, {StackFit fit = StackFit.loose}, {Overflow overflow = Overflow.clip}, {Clip clipBehavior = Clip.hardEdge}, {List<Widget> children = const <Widget>[]}]
For class -> IndexedStack
[Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit sizing = StackFit.loose, this.index = 0, List<Widget> children = const <Widget>[]]
[{Key? key}, {AlignmentGeometry alignment = AlignmentDirectional.topStart}, {TextDirection? textDirection}, {StackFit sizing = StackFit.loose}, {int? index = 0}, {List<Widget> children = const <Widget>[]}]
For class -> Positioned
[Key? key, this.left, this.top, this.right, this.bottom, this.width, this.height, required Widget child]
[{Key? key}, {double? left}, {double? top}, {double? right}, {double? bottom}, {double? width}, {double? height}, {required Widget child}]
[Key? key, required Rect rect, required Widget child]
[{Key? key}, {required Rect rect}, {required Widget child}]
[Key? key, required RelativeRect rect, required Widget child]
[{Key? key}, {required RelativeRect rect}, {required Widget child}]
[Key? key, this.left = 0.0, this.top = 0.0, this.right = 0.0, this.bottom = 0.0, required Widget child]
[{Key? key}, {double? left = 0.0}, {double? top = 0.0}, {double? right = 0.0}, {double? bottom = 0.0}, {required Widget child}]
[Key? key, required TextDirection textDirection, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child]
[{Key? key}, {required TextDirection textDirection}, {double? start}, {double? top}, {double? end}, {double? bottom}, {double? width}, {double? height}, {required Widget child}]
For class -> PositionedDirectional
[Key? key, this.start, this.top, this.end, this.bottom, this.width, this.height, required this.child]
[{Key? key}, {double? start}, {double? top}, {double? end}, {double? bottom}, {double? width}, {double? height}, {required Widget child}]
For class -> Flex
[Key? key, required this.direction, this.mainAxisAlignment = MainAxisAlignment.start, this.mainAxisSize = MainAxisSize.max, this.crossAxisAlignment = CrossAxisAlignment.center, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline, this.clipBehavior = Clip.none, List<Widget> children = const <Widget>[]]
[{Key? key}, {required Axis direction}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {Clip clipBehavior = Clip.none}, {List<Widget> children = const <Widget>[]}]
For class -> Row
[Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]]
[{Key? key}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {List<Widget> children = const <Widget>[]}]
For class -> Column
[Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]]
[{Key? key}, {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start}, {MainAxisSize mainAxisSize = MainAxisSize.max}, {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {TextBaseline? textBaseline}, {List<Widget> children = const <Widget>[]}]
For class -> Flexible
[Key? key, this.flex = 1, this.fit = FlexFit.loose, required Widget child]
[{Key? key}, {int flex = 1}, {FlexFit fit = FlexFit.loose}, {required Widget child}]
For class -> Expanded
[Key? key, int flex = 1, required Widget child]
[{Key? key}, {int flex = 1}, {required Widget child}]
For class -> Wrap
[Key? key, this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, this.clipBehavior = Clip.none, List<Widget> children = const <Widget>[]]
[{Key? key}, {Axis direction = Axis.horizontal}, {WrapAlignment alignment = WrapAlignment.start}, {double spacing = 0.0}, {WrapAlignment runAlignment = WrapAlignment.start}, {double runSpacing = 0.0}, {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start}, {TextDirection? textDirection}, {VerticalDirection verticalDirection = VerticalDirection.down}, {Clip clipBehavior = Clip.none}, {List<Widget> children = const <Widget>[]}]
For class -> Flow
[Key? key, required this.delegate, List<Widget> children = const <Widget>[], this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required FlowDelegate delegate}, {List<Widget> children = const <Widget>[]}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, required this.delegate, List<Widget> children = const <Widget>[], this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required FlowDelegate delegate}, {List<Widget> children = const <Widget>[]}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RichText
[Key? key, required this.text, this.textAlign = TextAlign.start, this.textDirection, this.softWrap = true, this.overflow = TextOverflow.clip, this.textScaleFactor = 1.0, this.maxLines, this.locale, this.strutStyle, this.textWidthBasis = TextWidthBasis.parent, this.textHeightBehavior]
[{Key? key}, {required InlineSpan text}, {TextAlign textAlign = TextAlign.start}, {TextDirection? textDirection}, {bool softWrap = true}, {TextOverflow overflow = TextOverflow.clip}, {double textScaleFactor = 1.0}, {int? maxLines}, {Locale? locale}, {StrutStyle? strutStyle}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {TextHeightBehavior? textHeightBehavior}]
For class -> RawImage
[Key? key, this.image, this.debugImageLabel, this.width, this.height, this.scale = 1.0, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.invertColors = false, this.filterQuality = FilterQuality.low, this.isAntiAlias = false]
[{Key? key}, {Image? image}, {String? debugImageLabel}, {double? width}, {double? height}, {double scale = 1.0}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool invertColors = false}, {FilterQuality filterQuality = FilterQuality.low}, {bool isAntiAlias = false}]
For class -> DefaultAssetBundle
[Key? key, required this.bundle, required Widget child]
[{Key? key}, {required AssetBundle bundle}, {required Widget child}]
For class -> WidgetToRenderBoxAdapter
[required this.renderBox, this.onBuild]
[{required RenderBox renderBox}, {void Function()? onBuild}]
For class -> Listener
[Key? key, this.onPointerDown, this.onPointerMove, this.onPointerUp, this.onPointerHover, this.onPointerCancel, this.onPointerSignal, this.behavior = HitTestBehavior.deferToChild, Widget? child]
[{Key? key}, {void Function(PointerDownEvent)? onPointerDown}, {void Function(PointerMoveEvent)? onPointerMove}, {void Function(PointerUpEvent)? onPointerUp}, {void Function(PointerHoverEvent)? onPointerHover}, {void Function(PointerCancelEvent)? onPointerCancel}, {void Function(PointerSignalEvent)? onPointerSignal}, {HitTestBehavior behavior = HitTestBehavior.deferToChild}, {Widget? child}]
For class -> MouseRegion
[Key? key, this.onEnter, this.onExit, this.onHover, this.cursor = MouseCursor.defer, this.opaque = true, this.child]
[{Key? key}, {void Function(PointerEnterEvent)? onEnter}, {void Function(PointerExitEvent)? onExit}, {void Function(PointerHoverEvent)? onHover}, {MouseCursor cursor = MouseCursor.defer}, {bool opaque = true}, {Widget? child}]
For class -> _MouseRegionState
For class -> _RawMouseRegion
[this.owner]
[_MouseRegionState owner]
For class -> RepaintBoundary
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
[Widget child, int childIndex]
[Widget child, int childIndex]
For class -> IgnorePointer
[Key? key, this.ignoring = true, this.ignoringSemantics, Widget? child]
[{Key? key}, {bool ignoring = true}, {bool? ignoringSemantics}, {Widget? child}]
For class -> AbsorbPointer
[Key? key, this.absorbing = true, Widget? child, this.ignoringSemantics]
[{Key? key}, {bool absorbing = true}, {Widget? child}, {bool? ignoringSemantics}]
For class -> MetaData
[Key? key, this.metaData, this.behavior = HitTestBehavior.deferToChild, Widget? child]
[{Key? key}, {dynamic metaData}, {HitTestBehavior behavior = HitTestBehavior.deferToChild}, {Widget? child}]
For class -> Semantics
[Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? selected, bool? toggled, bool? button, bool? slider, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, String? value, String? increasedValue, String? decreasedValue, String? hint, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, VoidCallback? onTap, VoidCallback? onLongPress, VoidCallback? onScrollLeft, VoidCallback? onScrollRight, VoidCallback? onScrollUp, VoidCallback? onScrollDown, VoidCallback? onIncrease, VoidCallback? onDecrease, VoidCallback? onCopy, VoidCallback? onCut, VoidCallback? onPaste, VoidCallback? onDismiss, MoveCursorHandler? onMoveCursorForwardByCharacter, MoveCursorHandler? onMoveCursorBackwardByCharacter, SetSelectionHandler? onSetSelection, VoidCallback? onDidGainAccessibilityFocus, VoidCallback? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions]
[{Key? key}, {Widget? child}, {bool container = false}, {bool explicitChildNodes = false}, {bool excludeSemantics = false}, {bool? enabled}, {bool? checked}, {bool? selected}, {bool? toggled}, {bool? button}, {bool? slider}, {bool? link}, {bool? header}, {bool? textField}, {bool? readOnly}, {bool? focusable}, {bool? focused}, {bool? inMutuallyExclusiveGroup}, {bool? obscured}, {bool? multiline}, {bool? scopesRoute}, {bool? namesRoute}, {bool? hidden}, {bool? image}, {bool? liveRegion}, {int? maxValueLength}, {int? currentValueLength}, {String? label}, {String? value}, {String? increasedValue}, {String? decreasedValue}, {String? hint}, {String? onTapHint}, {String? onLongPressHint}, {TextDirection? textDirection}, {SemanticsSortKey? sortKey}, {SemanticsTag? tagForChildren}, {void Function()? onTap}, {void Function()? onLongPress}, {void Function()? onScrollLeft}, {void Function()? onScrollRight}, {void Function()? onScrollUp}, {void Function()? onScrollDown}, {void Function()? onIncrease}, {void Function()? onDecrease}, {void Function()? onCopy}, {void Function()? onCut}, {void Function()? onPaste}, {void Function()? onDismiss}, {void Function(bool)? onMoveCursorForwardByCharacter}, {void Function(bool)? onMoveCursorBackwardByCharacter}, {void Function(TextSelection)? onSetSelection}, {void Function()? onDidGainAccessibilityFocus}, {void Function()? onDidLoseAccessibilityFocus}, {Map<CustomSemanticsAction, void Function()>? customSemanticsActions}]
[Key? key, Widget? child, this.container = false, this.explicitChildNodes = false, this.excludeSemantics = false, required this.properties]
[{Key? key}, {Widget? child}, {bool container = false}, {bool explicitChildNodes = false}, {bool excludeSemantics = false}, {required SemanticsProperties properties}]
For class -> MergeSemantics
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> BlockSemantics
[Key? key, this.blocking = true, Widget? child]
[{Key? key}, {bool blocking = true}, {Widget? child}]
For class -> ExcludeSemantics
[Key? key, this.excluding = true, Widget? child]
[{Key? key}, {bool excluding = true}, {Widget? child}]
For class -> IndexedSemantics
[Key? key, required this.index, Widget? child]
[{Key? key}, {required int index}, {Widget? child}]
For class -> KeyedSubtree
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
[Widget child, int childIndex]
[Widget child, int childIndex]
For class -> Builder
[Key? key, required this.builder]
[{Key? key}, {required Widget Function(BuildContext) builder}]
For class -> StatefulBuilder
[Key? key, required this.builder]
[{Key? key}, {required Widget Function(BuildContext, void Function(void Function())) builder}]
For class -> _StatefulBuilderState
For class -> ColoredBox
[required this.color, Widget? child, Key? key]
[{required Color color}, {Widget? child}, {Key? key}]
For class -> _RenderColoredBox
[required Color color]
[{required Color color}]
For class -> WidgetsBindingObserver
For class -> RenderObjectToWidgetAdapter
[this.child, required this.container, this.debugShortDescription]
[{Widget? child}, {required RenderObjectWithChildMixin<T> container}, {String? debugShortDescription}]
For class -> RenderObjectToWidgetElement
[RenderObjectToWidgetAdapter<T> widget]
[RenderObjectToWidgetAdapter<T> widget]
For class -> WidgetsFlutterBinding
For class -> BottomNavigationBarItem
[required this.icon, @Deprecated('Use "label" instead, as it allows for an improved text-scaling experience. ' 'This feature was deprecated after v1.19.0.') this.title, this.label, Widget? activeIcon, this.backgroundColor, this.tooltip]
[{required Widget icon}, {Widget? title}, {String? label}, {Widget? activeIcon}, {Color? backgroundColor}, {String? tooltip}]
For class -> ColorFiltered
[required this.colorFilter, Widget? child, Key? key]
[{required ColorFilter colorFilter}, {Widget? child}, {Key? key}]
For class -> _ColorFilterRenderObject
[this._colorFilter]
[ColorFilter _colorFilter]
For class -> DecoratedBox
[Key? key, required this.decoration, this.position = DecorationPosition.background, Widget? child]
[{Key? key}, {required Decoration decoration}, {DecorationPosition position = DecorationPosition.background}, {Widget? child}]
For class -> Container
[Key? key, this.alignment, this.padding, this.color, this.decoration, this.foregroundDecoration, double? width, double? height, BoxConstraints? constraints, this.margin, this.transform, this.transformAlignment, this.child, this.clipBehavior = Clip.none]
[{Key? key}, {AlignmentGeometry? alignment}, {EdgeInsetsGeometry? padding}, {Color? color}, {Decoration? decoration}, {Decoration? foregroundDecoration}, {double? width}, {double? height}, {BoxConstraints? constraints}, {EdgeInsetsGeometry? margin}, {Matrix4? transform}, {AlignmentGeometry? transformAlignment}, {Widget? child}, {Clip clipBehavior = Clip.none}]
For class -> _DecorationClipper
[TextDirection? textDirection, required this.decoration]
[{TextDirection? textDirection}, {required Decoration decoration}]
For class -> DesktopTextSelectionToolbarLayoutDelegate
[required this.anchor]
[{required Offset anchor}]
For class -> Dismissible
[required Key key, required this.child, this.background, this.secondaryBackground, this.confirmDismiss, this.onResize, this.onDismissed, this.direction = DismissDirection.horizontal, this.resizeDuration = const Duration(milliseconds: 300), this.dismissThresholds = const <DismissDirection, double>{}, this.movementDuration = const Duration(milliseconds: 200), this.crossAxisEndOffset = 0.0, this.dragStartBehavior = DragStartBehavior.start, this.behavior = HitTestBehavior.opaque]
[{required Key key}, {required Widget child}, {Widget? background}, {Widget? secondaryBackground}, {Future<bool?> Function(DismissDirection)? confirmDismiss}, {void Function()? onResize}, {void Function(DismissDirection)? onDismissed}, {DismissDirection direction = DismissDirection.horizontal}, {Duration? resizeDuration = const Duration(milliseconds: 300)}, {Map<DismissDirection, double> dismissThresholds = const <DismissDirection, double>{}}, {Duration movementDuration = const Duration(milliseconds: 200)}, {double crossAxisEndOffset = 0.0}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {HitTestBehavior behavior = HitTestBehavior.opaque}]
For class -> _DismissibleClipper
[required this.axis, required this.moveAnimation]
[{required Axis axis}, {required Animation<Offset> moveAnimation}]
For class -> _DismissibleState
For class -> DisposableBuildContext
[T this._state]
[T _state]
For class -> DraggableScrollableSheet
[Key? key, this.initialChildSize = 0.5, this.minChildSize = 0.25, this.maxChildSize = 1.0, this.expand = true, required this.builder]
[{Key? key}, {double initialChildSize = 0.5}, {double minChildSize = 0.25}, {double maxChildSize = 1.0}, {bool expand = true}, {required Widget Function(BuildContext, ScrollController) builder}]
For class -> DraggableScrollableNotification
[required this.extent, required this.minExtent, required this.maxExtent, required this.initialExtent, required this.context]
[{required double extent}, {required double minExtent}, {required double maxExtent}, {required double initialExtent}, {required BuildContext context}]
For class -> _DraggableSheetExtent
[required this.minExtent, required this.maxExtent, required this.initialExtent, required VoidCallback listener]
[{required double minExtent}, {required double maxExtent}, {required double initialExtent}, {required void Function() listener}]
For class -> _DraggableScrollableSheetState
For class -> _DraggableScrollableSheetScrollController
[double initialScrollOffset = 0.0, String? debugLabel, required this.extent]
[{double initialScrollOffset = 0.0}, {String? debugLabel}, {required _DraggableSheetExtent extent}]
For class -> _DraggableScrollableSheetScrollPosition
[required ScrollPhysics physics, required ScrollContext context, double initialPixels = 0.0, bool keepScrollOffset = true, ScrollPosition? oldPosition, String? debugLabel, required this.extent]
[{required ScrollPhysics physics}, {required ScrollContext context}, {double initialPixels = 0.0}, {bool keepScrollOffset = true}, {ScrollPosition? oldPosition}, {String? debugLabel}, {required _DraggableSheetExtent extent}]
For class -> DraggableScrollableActuator
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> _ResetNotifier
For class -> _InheritedResetNotifier
[Key? key, required Widget child, required _ResetNotifier notifier]
[{Key? key}, {required Widget child}, {required _ResetNotifier notifier}]
For class -> Draggable
[Key? key, required this.child, required this.feedback, this.data, this.axis, this.childWhenDragging, this.feedbackOffset = Offset.zero, this.dragAnchor = DragAnchor.child, this.affinity, this.maxSimultaneousDrags, this.onDragStarted, this.onDragUpdate, this.onDraggableCanceled, this.onDragEnd, this.onDragCompleted, this.ignoringFeedbackSemantics = true, this.rootOverlay = false]
[{Key? key}, {required Widget child}, {required Widget feedback}, {T? data}, {Axis? axis}, {Widget? childWhenDragging}, {Offset feedbackOffset = Offset.zero}, {DragAnchor dragAnchor = DragAnchor.child}, {Axis? affinity}, {int? maxSimultaneousDrags}, {void Function()? onDragStarted}, {void Function(DragUpdateDetails)? onDragUpdate}, {void Function(Velocity, Offset)? onDraggableCanceled}, {void Function(DraggableDetails)? onDragEnd}, {void Function()? onDragCompleted}, {bool ignoringFeedbackSemantics = true}, {bool rootOverlay = false}]
For class -> LongPressDraggable
[Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, DragAnchor dragAnchor = DragAnchor.child, int? maxSimultaneousDrags, VoidCallback? onDragStarted, DragUpdateCallback? onDragUpdate, DraggableCanceledCallback? onDraggableCanceled, DragEndCallback? onDragEnd, VoidCallback? onDragCompleted, this.hapticFeedbackOnStart = true, bool ignoringFeedbackSemantics = true]
[{Key? key}, {required Widget child}, {required Widget feedback}, {T? data}, {Axis? axis}, {Widget? childWhenDragging}, {Offset feedbackOffset = Offset.zero}, {DragAnchor dragAnchor = DragAnchor.child}, {int? maxSimultaneousDrags}, {void Function()? onDragStarted}, {void Function(DragUpdateDetails)? onDragUpdate}, {void Function(Velocity, Offset)? onDraggableCanceled}, {void Function(DraggableDetails)? onDragEnd}, {void Function()? onDragCompleted}, {bool hapticFeedbackOnStart = true}, {bool ignoringFeedbackSemantics = true}]
For class -> _DraggableState
For class -> DraggableDetails
[this.wasAccepted = false, required this.velocity, required this.offset]
[{bool wasAccepted = false}, {required Velocity velocity}, {required Offset offset}]
For class -> DragTargetDetails
[required this.data, required this.offset]
[{required T data}, {required Offset offset}]
For class -> DragTarget
[Key? key, required this.builder, this.onWillAccept, this.onAccept, this.onAcceptWithDetails, this.onLeave, this.onMove]
[{Key? key}, {required Widget Function(BuildContext, List<T?>, List<dynamic>) builder}, {bool Function(T?)? onWillAccept}, {void Function(T)? onAccept}, {void Function(DragTargetDetails<T>)? onAcceptWithDetails}, {void Function(Object?)? onLeave}, {void Function(DragTargetDetails<dynamic>)? onMove}]
For class -> _DragTargetState
For class -> _DragAvatar
[required this.overlayState, this.data, this.axis, required Offset initialPosition, this.dragStartPoint = Offset.zero, this.feedback, this.feedbackOffset = Offset.zero, this.onDragUpdate, this.onDragEnd, required this.ignoringFeedbackSemantics]
[{required OverlayState overlayState}, {T? data}, {Axis? axis}, {required Offset initialPosition}, {Offset dragStartPoint = Offset.zero}, {Widget? feedback}, {Offset feedbackOffset = Offset.zero}, {void Function(DragUpdateDetails)? onDragUpdate}, {void Function(Velocity, Offset, bool)? onDragEnd}, {required bool ignoringFeedbackSemantics}]
For class -> DualTransitionBuilder
[Key? key, required this.animation, required this.forwardBuilder, required this.reverseBuilder, this.child]
[{Key? key}, {required Animation<double> animation}, {required Widget Function(BuildContext, Animation<double>, Widget?) forwardBuilder}, {required Widget Function(BuildContext, Animation<double>, Widget?) reverseBuilder}, {Widget? child}]
For class -> _DualTransitionBuilderState
For class -> TextEditingController
[String? text]
[{String? text}]
[TextEditingValue? value]
[TextEditingValue? value]
For class -> ToolbarOptions
[this.copy = false, this.cut = false, this.paste = false, this.selectAll = false]
[{bool copy = false}, {bool cut = false}, {bool paste = false}, {bool selectAll = false}]
For class -> EditableText
[Key? key, required this.controller, required this.focusNode, this.readOnly = false, this.obscuringCharacter = '•', this.obscureText = false, this.autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, this.enableSuggestions = true, required this.style, StrutStyle? strutStyle, required this.cursorColor, required this.backgroundCursorColor, this.textAlign = TextAlign.start, this.textDirection, this.locale, this.textScaleFactor, this.maxLines = 1, this.minLines, this.expands = false, this.forceLine = true, this.textHeightBehavior, this.textWidthBasis = TextWidthBasis.parent, this.autofocus = false, bool? showCursor, this.showSelectionHandles = false, this.selectionColor, this.selectionControls, TextInputType? keyboardType, this.textInputAction, this.textCapitalization = TextCapitalization.none, this.onChanged, this.onEditingComplete, this.onSubmitted, this.onAppPrivateCommand, this.onSelectionChanged, this.onSelectionHandleTapped, List<TextInputFormatter>? inputFormatters, this.mouseCursor, this.rendererIgnoresPointer = false, this.cursorWidth = 2.0, this.cursorHeight, this.cursorRadius, this.cursorOpacityAnimates = false, this.cursorOffset, this.paintCursorAboveText = false, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.scrollPadding = const EdgeInsets.all(20.0), this.keyboardAppearance = Brightness.light, this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection = true, this.scrollController, this.scrollPhysics, this.autocorrectionTextRectColor, this.toolbarOptions = const ToolbarOptions(copy: true, cut: true, paste: true, selectAll: true), this.autofillHints, this.clipBehavior = Clip.hardEdge, this.restorationId]
[{Key? key}, {required TextEditingController controller}, {required FocusNode focusNode}, {bool readOnly = false}, {String obscuringCharacter = '•'}, {bool obscureText = false}, {bool autocorrect = true}, {SmartDashesType? smartDashesType}, {SmartQuotesType? smartQuotesType}, {bool enableSuggestions = true}, {required TextStyle style}, {StrutStyle? strutStyle}, {required Color cursorColor}, {required Color backgroundCursorColor}, {TextAlign textAlign = TextAlign.start}, {TextDirection? textDirection}, {Locale? locale}, {double? textScaleFactor}, {int? maxLines = 1}, {int? minLines}, {bool expands = false}, {bool forceLine = true}, {TextHeightBehavior? textHeightBehavior}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {bool autofocus = false}, {bool? showCursor}, {bool showSelectionHandles = false}, {Color? selectionColor}, {TextSelectionControls? selectionControls}, {TextInputType? keyboardType}, {TextInputAction? textInputAction}, {TextCapitalization textCapitalization = TextCapitalization.none}, {void Function(String)? onChanged}, {void Function()? onEditingComplete}, {void Function(String)? onSubmitted}, {void Function(String, Map<String, dynamic>)? onAppPrivateCommand}, {void Function(TextSelection, SelectionChangedCause?)? onSelectionChanged}, {void Function()? onSelectionHandleTapped}, {List<TextInputFormatter>? inputFormatters}, {MouseCursor? mouseCursor}, {bool rendererIgnoresPointer = false}, {double cursorWidth = 2.0}, {double? cursorHeight}, {Radius? cursorRadius}, {bool cursorOpacityAnimates = false}, {Offset? cursorOffset}, {bool paintCursorAboveText = false}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {EdgeInsets scrollPadding = const EdgeInsets.all(20.0)}, {Brightness keyboardAppearance = Brightness.light}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool enableInteractiveSelection = true}, {ScrollController? scrollController}, {ScrollPhysics? scrollPhysics}, {Color? autocorrectionTextRectColor}, {ToolbarOptions toolbarOptions = const ToolbarOptions(copy: true, cut: true, paste: true, selectAll: true)}, {Iterable<String>? autofillHints}, {Clip clipBehavior = Clip.hardEdge}, {String? restorationId}]
For class -> EditableTextState
For class -> _Editable
[Key? key, required this.textSpan, required this.value, required this.startHandleLayerLink, required this.endHandleLayerLink, this.cursorColor, this.backgroundCursorColor, required this.showCursor, required this.forceLine, required this.readOnly, this.textHeightBehavior, required this.textWidthBasis, required this.hasFocus, required this.maxLines, this.minLines, required this.expands, this.strutStyle, this.selectionColor, required this.textScaleFactor, required this.textAlign, required this.textDirection, this.locale, required this.obscuringCharacter, required this.obscureText, required this.autocorrect, required this.smartDashesType, required this.smartQuotesType, required this.enableSuggestions, required this.offset, this.onSelectionChanged, this.onCaretChanged, this.rendererIgnoresPointer = false, required this.cursorWidth, this.cursorHeight, this.cursorRadius, this.cursorOffset, required this.paintCursorAboveText, this.selectionHeightStyle = ui.BoxHeightStyle.tight, this.selectionWidthStyle = ui.BoxWidthStyle.tight, this.enableInteractiveSelection = true, required this.textSelectionDelegate, required this.devicePixelRatio, this.promptRectRange, this.promptRectColor, required this.clipBehavior]
[{Key? key}, {required TextSpan textSpan}, {required TextEditingValue value}, {required LayerLink startHandleLayerLink}, {required LayerLink endHandleLayerLink}, {Color? cursorColor}, {Color? backgroundCursorColor}, {required ValueNotifier<bool> showCursor}, {required bool forceLine}, {required bool readOnly}, {TextHeightBehavior? textHeightBehavior}, {required TextWidthBasis textWidthBasis}, {required bool hasFocus}, {required int? maxLines}, {int? minLines}, {required bool expands}, {StrutStyle? strutStyle}, {Color? selectionColor}, {required double textScaleFactor}, {required TextAlign textAlign}, {required TextDirection textDirection}, {Locale? locale}, {required String obscuringCharacter}, {required bool obscureText}, {required bool autocorrect}, {required SmartDashesType smartDashesType}, {required SmartQuotesType smartQuotesType}, {required bool enableSuggestions}, {required ViewportOffset offset}, {void Function(TextSelection, RenderEditable, SelectionChangedCause)? onSelectionChanged}, {void Function(Rect)? onCaretChanged}, {bool rendererIgnoresPointer = false}, {required double cursorWidth}, {double? cursorHeight}, {Radius? cursorRadius}, {Offset? cursorOffset}, {required bool paintCursorAboveText}, {BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight}, {BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight}, {bool enableInteractiveSelection = true}, {required TextSelectionDelegate textSelectionDelegate}, {required double devicePixelRatio}, {TextRange? promptRectRange}, {Color? promptRectColor}, {required Clip clipBehavior}]
For class -> _WhitespaceDirectionalityFormatter
[TextDirection? textDirection]
[{TextDirection? textDirection}]
For class -> FadeInImage
[Key? key, required this.placeholder, this.placeholderErrorBuilder, required this.image, this.imageErrorBuilder, this.excludeFromSemantics = false, this.imageSemanticLabel, this.fadeOutDuration = const Duration(milliseconds: 300), this.fadeOutCurve = Curves.easeOut, this.fadeInDuration = const Duration(milliseconds: 700), this.fadeInCurve = Curves.easeIn, this.width, this.height, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.matchTextDirection = false]
[{Key? key}, {required ImageProvider<Object> placeholder}, {Widget Function(BuildContext, Object, StackTrace?)? placeholderErrorBuilder}, {required ImageProvider<Object> image}, {Widget Function(BuildContext, Object, StackTrace?)? imageErrorBuilder}, {bool excludeFromSemantics = false}, {String? imageSemanticLabel}, {Duration fadeOutDuration = const Duration(milliseconds: 300)}, {Curve fadeOutCurve = Curves.easeOut}, {Duration fadeInDuration = const Duration(milliseconds: 700)}, {Curve fadeInCurve = Curves.easeIn}, {double? width}, {double? height}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {bool matchTextDirection = false}]
[Key? key, required Uint8List placeholder, this.placeholderErrorBuilder, required String image, this.imageErrorBuilder, double placeholderScale = 1.0, double imageScale = 1.0, this.excludeFromSemantics = false, this.imageSemanticLabel, this.fadeOutDuration = const Duration(milliseconds: 300), this.fadeOutCurve = Curves.easeOut, this.fadeInDuration = const Duration(milliseconds: 700), this.fadeInCurve = Curves.easeIn, this.width, this.height, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.matchTextDirection = false, int? placeholderCacheWidth, int? placeholderCacheHeight, int? imageCacheWidth, int? imageCacheHeight]
[{Key? key}, {required Uint8List placeholder}, {Widget Function(BuildContext, Object, StackTrace?)? placeholderErrorBuilder}, {required String image}, {Widget Function(BuildContext, Object, StackTrace?)? imageErrorBuilder}, {double placeholderScale = 1.0}, {double imageScale = 1.0}, {bool excludeFromSemantics = false}, {String? imageSemanticLabel}, {Duration fadeOutDuration = const Duration(milliseconds: 300)}, {Curve fadeOutCurve = Curves.easeOut}, {Duration fadeInDuration = const Duration(milliseconds: 700)}, {Curve fadeInCurve = Curves.easeIn}, {double? width}, {double? height}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {bool matchTextDirection = false}, {int? placeholderCacheWidth}, {int? placeholderCacheHeight}, {int? imageCacheWidth}, {int? imageCacheHeight}]
[Key? key, required String placeholder, this.placeholderErrorBuilder, required String image, this.imageErrorBuilder, AssetBundle? bundle, double? placeholderScale, double imageScale = 1.0, this.excludeFromSemantics = false, this.imageSemanticLabel, this.fadeOutDuration = const Duration(milliseconds: 300), this.fadeOutCurve = Curves.easeOut, this.fadeInDuration = const Duration(milliseconds: 700), this.fadeInCurve = Curves.easeIn, this.width, this.height, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.matchTextDirection = false, int? placeholderCacheWidth, int? placeholderCacheHeight, int? imageCacheWidth, int? imageCacheHeight]
[{Key? key}, {required String placeholder}, {Widget Function(BuildContext, Object, StackTrace?)? placeholderErrorBuilder}, {required String image}, {Widget Function(BuildContext, Object, StackTrace?)? imageErrorBuilder}, {AssetBundle? bundle}, {double? placeholderScale}, {double imageScale = 1.0}, {bool excludeFromSemantics = false}, {String? imageSemanticLabel}, {Duration fadeOutDuration = const Duration(milliseconds: 300)}, {Curve fadeOutCurve = Curves.easeOut}, {Duration fadeInDuration = const Duration(milliseconds: 700)}, {Curve fadeInCurve = Curves.easeIn}, {double? width}, {double? height}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {bool matchTextDirection = false}, {int? placeholderCacheWidth}, {int? placeholderCacheHeight}, {int? imageCacheWidth}, {int? imageCacheHeight}]
For class -> _AnimatedFadeOutFadeIn
[Key? key, required this.target, required this.placeholder, required this.isTargetLoaded, required this.fadeOutDuration, required this.fadeOutCurve, required this.fadeInDuration, required this.fadeInCurve]
[{Key? key}, {required Widget target}, {required Widget placeholder}, {required bool isTargetLoaded}, {required Duration fadeOutDuration}, {required Curve fadeOutCurve}, {required Duration fadeInDuration}, {required Curve fadeInCurve}]
For class -> _AnimatedFadeOutFadeInState
For class -> FocusAttachment
[this._node]
[FocusNode _node]
For class -> FocusNode
[String? debugLabel, FocusOnKeyCallback? onKey, bool skipTraversal = false, bool canRequestFocus = true, bool descendantsAreFocusable = true]
[{String? debugLabel}, {dynamic Function(FocusNode, RawKeyEvent)? onKey}, {bool skipTraversal = false}, {bool canRequestFocus = true}, {bool descendantsAreFocusable = true}]
For class -> FocusScopeNode
[String? debugLabel, FocusOnKeyCallback? onKey, bool skipTraversal = false, bool canRequestFocus = true]
[{String? debugLabel}, {dynamic Function(FocusNode, RawKeyEvent)? onKey}, {bool skipTraversal = false}, {bool canRequestFocus = true}]
For class -> FocusManager
[]
[]
For class -> Focus
[Key? key, required this.child, this.focusNode, this.autofocus = false, this.onFocusChange, this.onKey, this.debugLabel, this.canRequestFocus, this.descendantsAreFocusable = true, this.skipTraversal, this.includeSemantics = true]
[{Key? key}, {required Widget child}, {FocusNode? focusNode}, {bool autofocus = false}, {void Function(bool)? onFocusChange}, {dynamic Function(FocusNode, RawKeyEvent)? onKey}, {String? debugLabel}, {bool? canRequestFocus}, {bool descendantsAreFocusable = true}, {bool? skipTraversal}, {bool includeSemantics = true}]
For class -> _FocusState
For class -> FocusScope
[Key? key, FocusScopeNode? node, required Widget child, bool autofocus = false, ValueChanged<bool>? onFocusChange, bool? canRequestFocus, bool? skipTraversal, FocusOnKeyCallback? onKey, String? debugLabel]
[{Key? key}, {FocusScopeNode? node}, {required Widget child}, {bool autofocus = false}, {void Function(bool)? onFocusChange}, {bool? canRequestFocus}, {bool? skipTraversal}, {dynamic Function(FocusNode, RawKeyEvent)? onKey}, {String? debugLabel}]
For class -> _FocusScopeState
For class -> _FocusMarker
[Key? key, required FocusNode node, required Widget child]
[{Key? key}, {required FocusNode node}, {required Widget child}]
For class -> ExcludeFocus
[Key? key, this.excluding = true, required this.child]
[{Key? key}, {bool excluding = true}, {required Widget child}]
For class -> _FocusTraversalGroupInfo
[_FocusTraversalGroupMarker? marker, FocusTraversalPolicy? defaultPolicy, List<FocusNode>? members]
[_FocusTraversalGroupMarker? marker, {FocusTraversalPolicy? defaultPolicy}, {List<FocusNode>? members}]
For class -> FocusTraversalPolicy
[]
[]
For class -> _DirectionalPolicyDataEntry
[required this.direction, required this.node]
[{required TraversalDirection direction}, {required FocusNode node}]
For class -> _DirectionalPolicyData
[required this.history]
[{required List<_DirectionalPolicyDataEntry> history}]
For class -> WidgetOrderTraversalPolicy
For class -> _ReadingOrderSortData
[this.node]
[FocusNode node]
For class -> _ReadingOrderDirectionalGroupData
[this.members]
[List<_ReadingOrderSortData> members]
For class -> ReadingOrderTraversalPolicy
For class -> FocusOrder
[]
[]
For class -> NumericFocusOrder
[this.order]
[double order]
For class -> LexicalFocusOrder
[this.order]
[String order]
For class -> _OrderedFocusInfo
[required this.node, required this.order]
[{required FocusNode node}, {required FocusOrder order}]
For class -> OrderedTraversalPolicy
[this.secondary]
[{FocusTraversalPolicy? secondary}]
For class -> FocusTraversalOrder
[Key? key, required this.order, required Widget child]
[{Key? key}, {required FocusOrder order}, {required Widget child}]
For class -> FocusTraversalGroup
[Key? key, FocusTraversalPolicy? policy, this.descendantsAreFocusable = true, required this.child]
[{Key? key}, {FocusTraversalPolicy? policy}, {bool descendantsAreFocusable = true}, {required Widget child}]
For class -> _FocusTraversalGroupState
For class -> _FocusTraversalGroupMarker
[required this.policy, required this.focusNode, required Widget child]
[{required FocusTraversalPolicy policy}, {required FocusNode focusNode}, {required Widget child}]
For class -> RequestFocusIntent
[this.focusNode]
[FocusNode focusNode]
For class -> RequestFocusAction
For class -> NextFocusIntent
[]
[]
For class -> NextFocusAction
For class -> PreviousFocusIntent
[]
[]
For class -> PreviousFocusAction
For class -> DirectionalFocusIntent
[this.direction, this.ignoreTextFields = true]
[TraversalDirection direction, {bool ignoreTextFields = true}]
For class -> DirectionalFocusAction
For class -> Form
[Key? key, required this.child, @Deprecated('Use autovalidateMode parameter which provides more specific ' 'behavior related to auto validation. ' 'This feature was deprecated after v1.19.0.') this.autovalidate = false, this.onWillPop, this.onChanged, AutovalidateMode? autovalidateMode]
[{Key? key}, {required Widget child}, {bool autovalidate = false}, {Future<bool> Function()? onWillPop}, {void Function()? onChanged}, {AutovalidateMode? autovalidateMode}]
For class -> FormState
For class -> _FormScope
[Key? key, required Widget child, required FormState formState, required int generation]
[{Key? key}, {required Widget child}, {required FormState formState}, {required int generation}]
For class -> FormField
[Key? key, required this.builder, this.onSaved, this.validator, this.initialValue, @Deprecated('Use autovalidateMode parameter which provides more specific ' 'behavior related to auto validation. ' 'This feature was deprecated after v1.19.0.') this.autovalidate = false, this.enabled = true, AutovalidateMode? autovalidateMode]
[{Key? key}, {required Widget Function(FormFieldState<T>) builder}, {void Function(T?)? onSaved}, {String? Function(T?)? validator}, {T? initialValue}, {bool autovalidate = false}, {bool enabled = true}, {AutovalidateMode? autovalidateMode}]
For class -> FormFieldState
For class -> UniqueKey
[]
[]
For class -> ObjectKey
[this.value]
[Object? value]
For class -> GlobalKey
[String? debugLabel]
[{String? debugLabel}]
[]
[]
For class -> LabeledGlobalKey
[this._debugLabel]
[String? _debugLabel]
For class -> GlobalObjectKey
[this.value]
[Object value]
For class -> TypeMatcher
[]
[]
For class -> Widget
[this.key]
[{Key? key}]
For class -> StatelessWidget
[Key? key]
[{Key? key}]
For class -> StatefulWidget
[Key? key]
[{Key? key}]
For class -> State
For class -> ProxyWidget
[Key? key, required this.child]
[{Key? key}, {required Widget child}]
For class -> ParentDataWidget
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> InheritedWidget
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> RenderObjectWidget
[Key? key]
[{Key? key}]
For class -> LeafRenderObjectWidget
[Key? key]
[{Key? key}]
For class -> SingleChildRenderObjectWidget
[Key? key, this.child]
[{Key? key}, {Widget? child}]
For class -> MultiChildRenderObjectWidget
[Key? key, this.children = const <Widget>[]]
[{Key? key}, {List<Widget> children = const <Widget>[]}]
For class -> _InactiveElements
For class -> BuildContext
For class -> BuildOwner
[this.onBuildScheduled, FocusManager? focusManager]
[{void Function()? onBuildScheduled}, {FocusManager? focusManager}]
For class -> Element
[Widget widget]
[Widget widget]
For class -> _ElementDiagnosticableTreeNode
[String? name, required Element value, required DiagnosticsTreeStyle? style, this.stateful = false]
[{String? name}, {required Element value}, {required DiagnosticsTreeStyle? style}, {bool stateful = false}]
For class -> ErrorWidget
[Object exception]
[Object exception]
[this.message = '', FlutterError? error]
[{String message = ''}, {FlutterError? error}]
For class -> ComponentElement
[Widget widget]
[Widget widget]
For class -> StatelessElement
[StatelessWidget widget]
[StatelessWidget widget]
For class -> StatefulElement
[StatefulWidget widget]
[StatefulWidget widget]
For class -> ProxyElement
[ProxyWidget widget]
[ProxyWidget widget]
For class -> ParentDataElement
[ParentDataWidget<T> widget]
[ParentDataWidget<T> widget]
For class -> InheritedElement
[InheritedWidget widget]
[InheritedWidget widget]
For class -> RenderObjectElement
[RenderObjectWidget widget]
[RenderObjectWidget widget]
For class -> RootRenderObjectElement
[RenderObjectWidget widget]
[RenderObjectWidget widget]
For class -> LeafRenderObjectElement
[LeafRenderObjectWidget widget]
[LeafRenderObjectWidget widget]
For class -> SingleChildRenderObjectElement
[SingleChildRenderObjectWidget widget]
[SingleChildRenderObjectWidget widget]
For class -> MultiChildRenderObjectElement
[MultiChildRenderObjectWidget widget]
[MultiChildRenderObjectWidget widget]
For class -> DebugCreator
[this.element]
[Element element]
For class -> IndexedSlot
[this.index, this.value]
[int index, T value]
For class -> _NullElement
[]
[]
For class -> _NullWidget
For class -> GestureRecognizerFactory
[]
[]
For class -> GestureRecognizerFactoryWithHandlers
[this._constructor, this._initializer]
[T Function() _constructor, void Function(T) _initializer]
For class -> GestureDetector
[Key? key, this.child, this.onTapDown, this.onTapUp, this.onTap, this.onTapCancel, this.onSecondaryTap, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onDoubleTapDown, this.onDoubleTap, this.onDoubleTapCancel, this.onLongPress, this.onLongPressStart, this.onLongPressMoveUpdate, this.onLongPressUp, this.onLongPressEnd, this.onSecondaryLongPress, this.onSecondaryLongPressStart, this.onSecondaryLongPressMoveUpdate, this.onSecondaryLongPressUp, this.onSecondaryLongPressEnd, this.onVerticalDragDown, this.onVerticalDragStart, this.onVerticalDragUpdate, this.onVerticalDragEnd, this.onVerticalDragCancel, this.onHorizontalDragDown, this.onHorizontalDragStart, this.onHorizontalDragUpdate, this.onHorizontalDragEnd, this.onHorizontalDragCancel, this.onForcePressStart, this.onForcePressPeak, this.onForcePressUpdate, this.onForcePressEnd, this.onPanDown, this.onPanStart, this.onPanUpdate, this.onPanEnd, this.onPanCancel, this.onScaleStart, this.onScaleUpdate, this.onScaleEnd, this.behavior, this.excludeFromSemantics = false, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {Widget? child}, {void Function(TapDownDetails)? onTapDown}, {void Function(TapUpDetails)? onTapUp}, {void Function()? onTap}, {void Function()? onTapCancel}, {void Function()? onSecondaryTap}, {void Function(TapDownDetails)? onSecondaryTapDown}, {void Function(TapUpDetails)? onSecondaryTapUp}, {void Function()? onSecondaryTapCancel}, {void Function(TapDownDetails)? onTertiaryTapDown}, {void Function(TapUpDetails)? onTertiaryTapUp}, {void Function()? onTertiaryTapCancel}, {void Function(TapDownDetails)? onDoubleTapDown}, {void Function()? onDoubleTap}, {void Function()? onDoubleTapCancel}, {void Function()? onLongPress}, {void Function(LongPressStartDetails)? onLongPressStart}, {void Function(LongPressMoveUpdateDetails)? onLongPressMoveUpdate}, {void Function()? onLongPressUp}, {void Function(LongPressEndDetails)? onLongPressEnd}, {void Function()? onSecondaryLongPress}, {void Function(LongPressStartDetails)? onSecondaryLongPressStart}, {void Function(LongPressMoveUpdateDetails)? onSecondaryLongPressMoveUpdate}, {void Function()? onSecondaryLongPressUp}, {void Function(LongPressEndDetails)? onSecondaryLongPressEnd}, {void Function(DragDownDetails)? onVerticalDragDown}, {void Function(DragStartDetails)? onVerticalDragStart}, {void Function(DragUpdateDetails)? onVerticalDragUpdate}, {void Function(DragEndDetails)? onVerticalDragEnd}, {void Function()? onVerticalDragCancel}, {void Function(DragDownDetails)? onHorizontalDragDown}, {void Function(DragStartDetails)? onHorizontalDragStart}, {void Function(DragUpdateDetails)? onHorizontalDragUpdate}, {void Function(DragEndDetails)? onHorizontalDragEnd}, {void Function()? onHorizontalDragCancel}, {void Function(ForcePressDetails)? onForcePressStart}, {void Function(ForcePressDetails)? onForcePressPeak}, {void Function(ForcePressDetails)? onForcePressUpdate}, {void Function(ForcePressDetails)? onForcePressEnd}, {void Function(DragDownDetails)? onPanDown}, {void Function(DragStartDetails)? onPanStart}, {void Function(DragUpdateDetails)? onPanUpdate}, {void Function(DragEndDetails)? onPanEnd}, {void Function()? onPanCancel}, {void Function(ScaleStartDetails)? onScaleStart}, {void Function(ScaleUpdateDetails)? onScaleUpdate}, {void Function(ScaleEndDetails)? onScaleEnd}, {HitTestBehavior? behavior}, {bool excludeFromSemantics = false}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> RawGestureDetector
[Key? key, this.child, this.gestures = const <Type, GestureRecognizerFactory>{}, this.behavior, this.excludeFromSemantics = false, this.semantics]
[{Key? key}, {Widget? child}, {Map<Type, GestureRecognizerFactory<GestureRecognizer>> gestures = const <Type, GestureRecognizerFactory>{}}, {HitTestBehavior? behavior}, {bool excludeFromSemantics = false}, {SemanticsGestureDelegate? semantics}]
For class -> RawGestureDetectorState
For class -> _GestureSemantics
[Key? key, Widget? child, required this.assignSemantics]
[{Key? key}, {Widget? child}, {required void Function(RenderSemanticsGestureHandler) assignSemantics}]
For class -> SemanticsGestureDelegate
[]
[]
For class -> _DefaultSemanticsGestureDelegate
[this.detectorState]
[RawGestureDetectorState detectorState]
For class -> _GridPaperPainter
[required this.color, required this.interval, required this.divisions, required this.subdivisions]
[{required Color color}, {required double interval}, {required int divisions}, {required int subdivisions}]
For class -> GridPaper
[Key? key, this.color = const Color(0x7FC3E8F3), this.interval = 100.0, this.divisions = 2, this.subdivisions = 5, this.child]
[{Key? key}, {Color color = const Color(0x7FC3E8F3)}, {double interval = 100.0}, {int divisions = 2}, {int subdivisions = 5}, {Widget? child}]
For class -> Hero
[Key? key, required this.tag, this.createRectTween, this.flightShuttleBuilder, this.placeholderBuilder, this.transitionOnUserGestures = false, required this.child]
[{Key? key}, {required Object tag}, {Tween<Rect?> Function(Rect?, Rect?)? createRectTween}, {Widget Function(BuildContext, Animation<double>, HeroFlightDirection, BuildContext, BuildContext)? flightShuttleBuilder}, {Widget Function(BuildContext, Size, Widget)? placeholderBuilder}, {bool transitionOnUserGestures = false}, {required Widget child}]
For class -> _HeroState
For class -> _HeroFlightManifest
[required this.type, required this.overlay, required this.navigatorSize, required this.fromRoute, required this.toRoute, required this.fromHero, required this.toHero, required this.createRectTween, required this.shuttleBuilder, required this.isUserGestureTransition, required this.isDiverted]
[{required HeroFlightDirection type}, {required OverlayState overlay}, {required Size navigatorSize}, {required PageRoute<dynamic> fromRoute}, {required PageRoute<dynamic> toRoute}, {required _HeroState fromHero}, {required _HeroState toHero}, {required Tween<Rect?> Function(Rect?, Rect?)? createRectTween}, {required Widget Function(BuildContext, Animation<double>, HeroFlightDirection, BuildContext, BuildContext) shuttleBuilder}, {required bool isUserGestureTransition}, {required bool isDiverted}]
For class -> _HeroFlight
[this.onFlightEnded]
[void Function(_HeroFlight) onFlightEnded]
For class -> HeroController
[this.createRectTween]
[{Tween<Rect?> Function(Rect?, Rect?)? createRectTween}]
For class -> HeroMode
[Key? key, required this.child, this.enabled = true]
[{Key? key}, {required Widget child}, {bool enabled = true}]
For class -> Icon
[this.icon, Key? key, this.size, this.color, this.semanticLabel, this.textDirection]
[IconData? icon, {Key? key}, {double? size}, {Color? color}, {String? semanticLabel}, {TextDirection? textDirection}]
For class -> IconData
[this.codePoint, this.fontFamily, this.fontPackage, this.matchTextDirection = false]
[int codePoint, {String? fontFamily}, {String? fontPackage}, {bool matchTextDirection = false}]
For class -> IconDataProperty
[String name, IconData? value, String? ifNull, bool showName = true, DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine, DiagnosticLevel level = DiagnosticLevel.info]
[String name, IconData? value, {String? ifNull}, {bool showName = true}, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.singleLine}, {DiagnosticLevel level = DiagnosticLevel.info}]
For class -> IconTheme
[Key? key, required this.data, required Widget child]
[{Key? key}, {required IconThemeData data}, {required Widget child}]
For class -> IconThemeData
[this.color, double? opacity, this.size]
[{Color? color}, {double? opacity}, {double? size}]
[]
[]
For class -> Image
[Key? key, required this.image, this.frameBuilder, this.loadingBuilder, this.errorBuilder, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.isAntiAlias = false, this.filterQuality = FilterQuality.low]
[{Key? key}, {required ImageProvider<Object> image}, {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder}, {Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder}, {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder}, {String? semanticLabel}, {bool excludeFromSemantics = false}, {double? width}, {double? height}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool gaplessPlayback = false}, {bool isAntiAlias = false}, {FilterQuality filterQuality = FilterQuality.low}]
[String src, Key? key, double scale = 1.0, this.frameBuilder, this.loadingBuilder, this.errorBuilder, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, this.isAntiAlias = false, Map<String, String>? headers, int? cacheWidth, int? cacheHeight]
[String src, {Key? key}, {double scale = 1.0}, {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder}, {Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder}, {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder}, {String? semanticLabel}, {bool excludeFromSemantics = false}, {double? width}, {double? height}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool gaplessPlayback = false}, {FilterQuality filterQuality = FilterQuality.low}, {bool isAntiAlias = false}, {Map<String, String>? headers}, {int? cacheWidth}, {int? cacheHeight}]
[File file, Key? key, double scale = 1.0, this.frameBuilder, this.errorBuilder, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.isAntiAlias = false, this.filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight]
[File file, {Key? key}, {double scale = 1.0}, {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder}, {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder}, {String? semanticLabel}, {bool excludeFromSemantics = false}, {double? width}, {double? height}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool gaplessPlayback = false}, {bool isAntiAlias = false}, {FilterQuality filterQuality = FilterQuality.low}, {int? cacheWidth}, {int? cacheHeight}]
[String name, Key? key, AssetBundle? bundle, this.frameBuilder, this.errorBuilder, this.semanticLabel, this.excludeFromSemantics = false, double? scale, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.isAntiAlias = false, String? package, this.filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight]
[String name, {Key? key}, {AssetBundle? bundle}, {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder}, {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder}, {String? semanticLabel}, {bool excludeFromSemantics = false}, {double? scale}, {double? width}, {double? height}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool gaplessPlayback = false}, {bool isAntiAlias = false}, {String? package}, {FilterQuality filterQuality = FilterQuality.low}, {int? cacheWidth}, {int? cacheHeight}]
[Uint8List bytes, Key? key, double scale = 1.0, this.frameBuilder, this.errorBuilder, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.isAntiAlias = false, this.filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight]
[Uint8List bytes, {Key? key}, {double scale = 1.0}, {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder}, {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder}, {String? semanticLabel}, {bool excludeFromSemantics = false}, {double? width}, {double? height}, {Color? color}, {BlendMode? colorBlendMode}, {BoxFit? fit}, {AlignmentGeometry alignment = Alignment.center}, {ImageRepeat repeat = ImageRepeat.noRepeat}, {Rect? centerSlice}, {bool matchTextDirection = false}, {bool gaplessPlayback = false}, {bool isAntiAlias = false}, {FilterQuality filterQuality = FilterQuality.low}, {int? cacheWidth}, {int? cacheHeight}]
For class -> _ImageState
For class -> ImageFiltered
[Key? key, required this.imageFilter, Widget? child]
[{Key? key}, {required ImageFilter imageFilter}, {Widget? child}]
For class -> _ImageFilterRenderObject
[this._imageFilter]
[ImageFilter _imageFilter]
For class -> ImageIcon
[this.image, Key? key, this.size, this.color, this.semanticLabel]
[ImageProvider<Object>? image, {Key? key}, {double? size}, {Color? color}, {String? semanticLabel}]
For class -> BoxConstraintsTween
[BoxConstraints? begin, BoxConstraints? end]
[{BoxConstraints? begin}, {BoxConstraints? end}]
For class -> DecorationTween
[Decoration? begin, Decoration? end]
[{Decoration? begin}, {Decoration? end}]
For class -> EdgeInsetsTween
[EdgeInsets? begin, EdgeInsets? end]
[{EdgeInsets? begin}, {EdgeInsets? end}]
For class -> EdgeInsetsGeometryTween
[EdgeInsetsGeometry? begin, EdgeInsetsGeometry? end]
[{EdgeInsetsGeometry? begin}, {EdgeInsetsGeometry? end}]
For class -> BorderRadiusTween
[BorderRadius? begin, BorderRadius? end]
[{BorderRadius? begin}, {BorderRadius? end}]
For class -> BorderTween
[Border? begin, Border? end]
[{Border? begin}, {Border? end}]
For class -> Matrix4Tween
[Matrix4? begin, Matrix4? end]
[{Matrix4? begin}, {Matrix4? end}]
For class -> TextStyleTween
[TextStyle? begin, TextStyle? end]
[{TextStyle? begin}, {TextStyle? end}]
For class -> ImplicitlyAnimatedWidget
[Key? key, this.curve = Curves.linear, required this.duration, this.onEnd]
[{Key? key}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> ImplicitlyAnimatedWidgetState
For class -> AnimatedWidgetBaseState
For class -> AnimatedContainer
[Key? key, this.alignment, this.padding, Color? color, Decoration? decoration, this.foregroundDecoration, double? width, double? height, BoxConstraints? constraints, this.margin, this.transform, this.transformAlignment, this.child, this.clipBehavior = Clip.none, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {AlignmentGeometry? alignment}, {EdgeInsetsGeometry? padding}, {Color? color}, {Decoration? decoration}, {Decoration? foregroundDecoration}, {double? width}, {double? height}, {BoxConstraints? constraints}, {EdgeInsetsGeometry? margin}, {Matrix4? transform}, {AlignmentGeometry? transformAlignment}, {Widget? child}, {Clip clipBehavior = Clip.none}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedContainerState
For class -> AnimatedPadding
[Key? key, required this.padding, this.child, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required EdgeInsetsGeometry padding}, {Widget? child}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedPaddingState
For class -> AnimatedAlign
[Key? key, required this.alignment, this.child, this.heightFactor, this.widthFactor, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required AlignmentGeometry alignment}, {Widget? child}, {double? heightFactor}, {double? widthFactor}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedAlignState
For class -> AnimatedPositioned
[Key? key, required this.child, this.left, this.top, this.right, this.bottom, this.width, this.height, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required Widget child}, {double? left}, {double? top}, {double? right}, {double? bottom}, {double? width}, {double? height}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
[Key? key, required this.child, required Rect rect, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required Widget child}, {required Rect rect}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedPositionedState
For class -> AnimatedPositionedDirectional
[Key? key, required this.child, this.start, this.top, this.end, this.bottom, this.width, this.height, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required Widget child}, {double? start}, {double? top}, {double? end}, {double? bottom}, {double? width}, {double? height}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedPositionedDirectionalState
For class -> AnimatedOpacity
[Key? key, this.child, required this.opacity, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd, this.alwaysIncludeSemantics = false]
[{Key? key}, {Widget? child}, {required double opacity}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}, {bool alwaysIncludeSemantics = false}]
For class -> _AnimatedOpacityState
For class -> SliverAnimatedOpacity
[Key? key, this.sliver, required this.opacity, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd, this.alwaysIncludeSemantics = false]
[{Key? key}, {Widget? sliver}, {required double opacity}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}, {bool alwaysIncludeSemantics = false}]
For class -> _SliverAnimatedOpacityState
For class -> AnimatedDefaultTextStyle
[Key? key, required this.child, required this.style, this.textAlign, this.softWrap = true, this.overflow = TextOverflow.clip, this.maxLines, this.textWidthBasis = TextWidthBasis.parent, this.textHeightBehavior, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required Widget child}, {required TextStyle style}, {TextAlign? textAlign}, {bool softWrap = true}, {TextOverflow overflow = TextOverflow.clip}, {int? maxLines}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {TextHeightBehavior? textHeightBehavior}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedDefaultTextStyleState
For class -> AnimatedPhysicalModel
[Key? key, required this.child, required this.shape, this.clipBehavior = Clip.none, this.borderRadius = BorderRadius.zero, required this.elevation, required this.color, this.animateColor = true, required this.shadowColor, this.animateShadowColor = true, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd]
[{Key? key}, {required Widget child}, {required BoxShape shape}, {Clip clipBehavior = Clip.none}, {BorderRadius borderRadius = BorderRadius.zero}, {required double elevation}, {required Color color}, {bool animateColor = true}, {required Color shadowColor}, {bool animateShadowColor = true}, {Curve curve = Curves.linear}, {required Duration duration}, {void Function()? onEnd}]
For class -> _AnimatedPhysicalModelState
For class -> InheritedModel
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> InheritedModelElement
[InheritedModel<T> widget]
[InheritedModel<T> widget]
For class -> InheritedNotifier
[Key? key, this.notifier, required Widget child]
[{Key? key}, {T? notifier}, {required Widget child}]
For class -> _InheritedNotifierElement
[InheritedNotifier<T> widget]
[InheritedNotifier<T> widget]
For class -> InheritedTheme
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> CapturedThemes
[this._themes]
[List<InheritedTheme> _themes]
For class -> _CaptureAll
[Key? key, required this.themes, required this.child]
[{Key? key}, {required List<InheritedTheme> themes}, {required Widget child}]
For class -> InteractiveViewer
[Key? key, this.clipBehavior = Clip.hardEdge, this.alignPanAxis = false, this.boundaryMargin = EdgeInsets.zero, this.constrained = true, this.maxScale = 2.5, this.minScale = 0.8, this.onInteractionEnd, this.onInteractionStart, this.onInteractionUpdate, this.panEnabled = true, this.scaleEnabled = true, this.transformationController, required this.child]
[{Key? key}, {Clip clipBehavior = Clip.hardEdge}, {bool alignPanAxis = false}, {EdgeInsets boundaryMargin = EdgeInsets.zero}, {bool constrained = true}, {double maxScale = 2.5}, {double minScale = 0.8}, {void Function(ScaleEndDetails)? onInteractionEnd}, {void Function(ScaleStartDetails)? onInteractionStart}, {void Function(ScaleUpdateDetails)? onInteractionUpdate}, {bool panEnabled = true}, {bool scaleEnabled = true}, {TransformationController? transformationController}, {required Widget child}]
For class -> _InteractiveViewerState
For class -> TransformationController
[Matrix4? value]
[[Matrix4? value]]
For class -> ConstrainedLayoutBuilder
[Key? key, required this.builder]
[{Key? key}, {required Widget Function(BuildContext, ConstraintType) builder}]
For class -> _LayoutBuilderElement
[ConstrainedLayoutBuilder<ConstraintType> widget]
[ConstrainedLayoutBuilder<ConstraintType> widget]
For class -> LayoutBuilder
[Key? key, required LayoutWidgetBuilder builder]
[{Key? key}, {required Widget Function(BuildContext, BoxConstraints) builder}]
For class -> _RenderLayoutBuilder
For class -> ListWheelChildDelegate
For class -> ListWheelChildListDelegate
[required this.children]
[{required List<Widget> children}]
For class -> ListWheelChildLoopingListDelegate
[required this.children]
[{required List<Widget> children}]
For class -> ListWheelChildBuilderDelegate
[required this.builder, this.childCount]
[{required Widget? Function(BuildContext, int) builder}, {int? childCount}]
For class -> FixedExtentScrollController
[this.initialItem = 0]
[{int initialItem = 0}]
For class -> FixedExtentMetrics
[required double? minScrollExtent, required double? maxScrollExtent, required double? pixels, required double? viewportDimension, required AxisDirection axisDirection, required this.itemIndex]
[{required double? minScrollExtent}, {required double? maxScrollExtent}, {required double? pixels}, {required double? viewportDimension}, {required AxisDirection axisDirection}, {required int itemIndex}]
For class -> _FixedExtentScrollPosition
[required ScrollPhysics physics, required ScrollContext context, required int initialItem, bool keepScrollOffset = true, ScrollPosition? oldPosition, String? debugLabel]
[{required ScrollPhysics physics}, {required ScrollContext context}, {required int initialItem}, {bool keepScrollOffset = true}, {ScrollPosition? oldPosition}, {String? debugLabel}]
For class -> _FixedExtentScrollable
[Key? key, AxisDirection axisDirection = AxisDirection.down, ScrollController? controller, ScrollPhysics? physics, required this.itemExtent, required ViewportBuilder viewportBuilder, String? restorationId]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {ScrollController? controller}, {ScrollPhysics? physics}, {required double itemExtent}, {required Widget Function(BuildContext, ViewportOffset) viewportBuilder}, {String? restorationId}]
For class -> _FixedExtentScrollableState
For class -> FixedExtentScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> ListWheelScrollView
[Key? key, this.controller, this.physics, this.diameterRatio = RenderListWheelViewport.defaultDiameterRatio, this.perspective = RenderListWheelViewport.defaultPerspective, this.offAxisFraction = 0.0, this.useMagnifier = false, this.magnification = 1.0, this.overAndUnderCenterOpacity = 1.0, required this.itemExtent, this.squeeze = 1.0, this.onSelectedItemChanged, this.renderChildrenOutsideViewport = false, this.clipBehavior = Clip.hardEdge, this.restorationId, required List<Widget> children]
[{Key? key}, {ScrollController? controller}, {ScrollPhysics? physics}, {double diameterRatio = RenderListWheelViewport.defaultDiameterRatio}, {double perspective = RenderListWheelViewport.defaultPerspective}, {double offAxisFraction = 0.0}, {bool useMagnifier = false}, {double magnification = 1.0}, {double overAndUnderCenterOpacity = 1.0}, {required double itemExtent}, {double squeeze = 1.0}, {void Function(int)? onSelectedItemChanged}, {bool renderChildrenOutsideViewport = false}, {Clip clipBehavior = Clip.hardEdge}, {String? restorationId}, {required List<Widget> children}]
[Key? key, this.controller, this.physics, this.diameterRatio = RenderListWheelViewport.defaultDiameterRatio, this.perspective = RenderListWheelViewport.defaultPerspective, this.offAxisFraction = 0.0, this.useMagnifier = false, this.magnification = 1.0, this.overAndUnderCenterOpacity = 1.0, required this.itemExtent, this.squeeze = 1.0, this.onSelectedItemChanged, this.renderChildrenOutsideViewport = false, this.clipBehavior = Clip.hardEdge, this.restorationId, required this.childDelegate]
[{Key? key}, {ScrollController? controller}, {ScrollPhysics? physics}, {double diameterRatio = RenderListWheelViewport.defaultDiameterRatio}, {double perspective = RenderListWheelViewport.defaultPerspective}, {double offAxisFraction = 0.0}, {bool useMagnifier = false}, {double magnification = 1.0}, {double overAndUnderCenterOpacity = 1.0}, {required double itemExtent}, {double squeeze = 1.0}, {void Function(int)? onSelectedItemChanged}, {bool renderChildrenOutsideViewport = false}, {Clip clipBehavior = Clip.hardEdge}, {String? restorationId}, {required ListWheelChildDelegate childDelegate}]
For class -> _ListWheelScrollViewState
For class -> ListWheelElement
[ListWheelViewport widget]
[ListWheelViewport widget]
For class -> ListWheelViewport
[Key? key, this.diameterRatio = RenderListWheelViewport.defaultDiameterRatio, this.perspective = RenderListWheelViewport.defaultPerspective, this.offAxisFraction = 0.0, this.useMagnifier = false, this.magnification = 1.0, this.overAndUnderCenterOpacity = 1.0, required this.itemExtent, this.squeeze = 1.0, this.renderChildrenOutsideViewport = false, required this.offset, required this.childDelegate, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {double diameterRatio = RenderListWheelViewport.defaultDiameterRatio}, {double perspective = RenderListWheelViewport.defaultPerspective}, {double offAxisFraction = 0.0}, {bool useMagnifier = false}, {double magnification = 1.0}, {double overAndUnderCenterOpacity = 1.0}, {required double itemExtent}, {double squeeze = 1.0}, {bool renderChildrenOutsideViewport = false}, {required ViewportOffset offset}, {required ListWheelChildDelegate childDelegate}, {Clip clipBehavior = Clip.hardEdge}]
For class -> _Pending
[this.delegate, this.futureValue]
[LocalizationsDelegate<dynamic> delegate, Future<dynamic> futureValue]
For class -> LocalizationsDelegate
[]
[]
For class -> WidgetsLocalizations
For class -> _WidgetsLocalizationsDelegate
[]
[]
For class -> DefaultWidgetsLocalizations
[]
[]
For class -> _LocalizationsScope
[Key? key, required this.locale, required this.localizationsState, required this.typeToResources, required Widget child]
[{Key? key}, {required Locale locale}, {required _LocalizationsState localizationsState}, {required Map<Type, dynamic> typeToResources}, {required Widget child}]
For class -> Localizations
[Key? key, required this.locale, required this.delegates, this.child]
[{Key? key}, {required Locale locale}, {required List<LocalizationsDelegate<dynamic>> delegates}, {Widget? child}]
[Key? key, required BuildContext context, Locale? locale, List<LocalizationsDelegate<dynamic>>? delegates, Widget? child]
[{Key? key}, {required BuildContext context}, {Locale? locale}, {List<LocalizationsDelegate<dynamic>>? delegates}, {Widget? child}]
For class -> _LocalizationsState
For class -> MediaQueryData
[this.size = Size.zero, this.devicePixelRatio = 1.0, this.textScaleFactor = 1.0, this.platformBrightness = Brightness.light, this.padding = EdgeInsets.zero, this.viewInsets = EdgeInsets.zero, this.systemGestureInsets = EdgeInsets.zero, this.viewPadding = EdgeInsets.zero, this.alwaysUse24HourFormat = false, this.accessibleNavigation = false, this.invertColors = false, this.highContrast = false, this.disableAnimations = false, this.boldText = false, this.navigationMode = NavigationMode.traditional]
[{Size size = Size.zero}, {double devicePixelRatio = 1.0}, {double textScaleFactor = 1.0}, {Brightness platformBrightness = Brightness.light}, {EdgeInsets padding = EdgeInsets.zero}, {EdgeInsets viewInsets = EdgeInsets.zero}, {EdgeInsets systemGestureInsets = EdgeInsets.zero}, {EdgeInsets viewPadding = EdgeInsets.zero}, {bool alwaysUse24HourFormat = false}, {bool accessibleNavigation = false}, {bool invertColors = false}, {bool highContrast = false}, {bool disableAnimations = false}, {bool boldText = false}, {NavigationMode navigationMode = NavigationMode.traditional}]
[ui.SingletonFlutterWindow window]
[SingletonFlutterWindow window]
For class -> MediaQuery
[Key? key, required this.data, required Widget child]
[{Key? key}, {required MediaQueryData data}, {required Widget child}]
[Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false, required Widget child]
[{Key? key}, {required BuildContext context}, {bool removeLeft = false}, {bool removeTop = false}, {bool removeRight = false}, {bool removeBottom = false}, {required Widget child}]
[Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false, required Widget child]
[{Key? key}, {required BuildContext context}, {bool removeLeft = false}, {bool removeTop = false}, {bool removeRight = false}, {bool removeBottom = false}, {required Widget child}]
[Key? key, required BuildContext context, bool removeLeft = false, bool removeTop = false, bool removeRight = false, bool removeBottom = false, required Widget child]
[{Key? key}, {required BuildContext context}, {bool removeLeft = false}, {bool removeTop = false}, {bool removeRight = false}, {bool removeBottom = false}, {required Widget child}]
For class -> ModalBarrier
[Key? key, this.color, this.dismissible = true, this.semanticsLabel, this.barrierSemanticsDismissible = true]
[{Key? key}, {Color? color}, {bool dismissible = true}, {String? semanticsLabel}, {bool? barrierSemanticsDismissible = true}]
For class -> AnimatedModalBarrier
[Key? key, required Animation<Color?> color, this.dismissible = true, this.semanticsLabel, this.barrierSemanticsDismissible]
[{Key? key}, {required Animation<Color?> color}, {bool dismissible = true}, {String? semanticsLabel}, {bool? barrierSemanticsDismissible}]
For class -> _AnyTapGestureRecognizer
[Object? debugOwner]
[{Object? debugOwner}]
For class -> _ModalBarrierSemanticsDelegate
[this.onDismiss]
[{void Function()? onDismiss}]
For class -> _AnyTapGestureRecognizerFactory
[this.onAnyTapUp]
[{void Function()? onAnyTapUp}]
For class -> _ModalBarrierGestureDetector
[Key? key, required this.child, required this.onDismiss]
[{Key? key}, {required Widget child}, {required void Function() onDismiss}]
For class -> NavigationToolbar
[Key? key, this.leading, this.middle, this.trailing, this.centerMiddle = true, this.middleSpacing = kMiddleSpacing]
[{Key? key}, {Widget? leading}, {Widget? middle}, {Widget? trailing}, {bool centerMiddle = true}, {double middleSpacing = kMiddleSpacing}]
For class -> _ToolbarLayout
[required this.centerMiddle, required this.middleSpacing, required this.textDirection]
[{required bool centerMiddle}, {required double middleSpacing}, {required TextDirection textDirection}]
For class -> Route
[RouteSettings? settings]
[{RouteSettings? settings}]
For class -> RouteSettings
[this.name, this.arguments]
[{String? name}, {Object? arguments}]
For class -> Page
[this.key, String? name, Object? arguments, this.restorationId]
[{LocalKey? key}, {String? name}, {Object? arguments}, {String? restorationId}]
For class -> NavigatorObserver
For class -> HeroControllerScope
[Key? key, required HeroController this.controller, required Widget child]
[{Key? key}, {required HeroController controller}, {required Widget child}]
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> RouteTransitionRecord
For class -> TransitionDelegate
[]
[]
For class -> DefaultTransitionDelegate
[]
[]
For class -> Navigator
[Key? key, this.pages = const <Page<dynamic>>[], this.onPopPage, this.initialRoute, this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes, this.onGenerateRoute, this.onUnknownRoute, this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(), this.reportsRouteUpdateToEngine = false, this.observers = const <NavigatorObserver>[], this.restorationScopeId]
[{Key? key}, {List<Page<dynamic>> pages = const <Page<dynamic>>[]}, {bool Function(Route<dynamic>, dynamic)? onPopPage}, {String? initialRoute}, {List<Route<dynamic>> Function(NavigatorState, String) onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes}, {Route<dynamic>? Function(RouteSettings)? onGenerateRoute}, {Route<dynamic>? Function(RouteSettings)? onUnknownRoute}, {TransitionDelegate<dynamic> transitionDelegate = const DefaultTransitionDelegate<dynamic>()}, {bool reportsRouteUpdateToEngine = false}, {List<NavigatorObserver> observers = const <NavigatorObserver>[]}, {String? restorationScopeId}]
For class -> _NotAnnounced
For class -> _RouteEntry
[this.route, required _RouteLifecycle initialState, this.restorationInformation]
[Route<dynamic> route, {required _RouteLifecycle initialState}, {_RestorationInformation? restorationInformation}]
For class -> _NavigatorObservation
[this.primaryRoute, this.secondaryRoute]
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
For class -> _NavigatorPushObservation
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
For class -> _NavigatorPopObservation
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
For class -> _NavigatorRemoveObservation
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
For class -> _NavigatorReplaceObservation
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
[Route<dynamic> primaryRoute, Route<dynamic>? secondaryRoute]
For class -> NavigatorState
For class -> _RestorationInformation
[this.type]
[_RouteRestorationType type]
[required String name, required Object? arguments, required int restorationScopeId]
[{required String name}, {required Object? arguments}, {required int restorationScopeId}]
[required RestorableRouteBuilder routeBuilder, required Object? arguments, required int restorationScopeId]
[{required Route<dynamic> Function(BuildContext, Object?) routeBuilder}, {required Object? arguments}, {required int restorationScopeId}]
[Object data]
[Object data]
For class -> _NamedRestorationInformation
[required this.name, required this.arguments, required this.restorationScopeId]
[{required String name}, {required Object? arguments}, {required int restorationScopeId}]
[List<Object?> data]
[List<Object?> data]
For class -> _AnonymousRestorationInformation
[required this.routeBuilder, required this.arguments, required this.restorationScopeId]
[{required Route<dynamic> Function(BuildContext, Object?) routeBuilder}, {required Object? arguments}, {required int restorationScopeId}]
[List<Object?> data]
[List<Object?> data]
For class -> _HistoryProperty
For class -> RestorableRouteFuture
[this.navigatorFinder = _defaultNavigatorFinder, required this.onPresent, this.onComplete]
[{NavigatorState Function(BuildContext) navigatorFinder = _defaultNavigatorFinder}, {required String Function(NavigatorState, Object?) onPresent}, {void Function(T)? onComplete}]
For class -> NestedScrollView
[Key? key, this.controller, this.scrollDirection = Axis.vertical, this.reverse = false, this.physics, required this.headerSliverBuilder, required this.body, this.dragStartBehavior = DragStartBehavior.start, this.floatHeaderSlivers = false, this.clipBehavior = Clip.hardEdge, this.restorationId]
[{Key? key}, {ScrollController? controller}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollPhysics? physics}, {required List<Widget> Function(BuildContext, bool) headerSliverBuilder}, {required Widget body}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool floatHeaderSlivers = false}, {Clip clipBehavior = Clip.hardEdge}, {String? restorationId}]
For class -> NestedScrollViewState
For class -> _NestedScrollViewCustomScrollView
[required Axis scrollDirection, required bool reverse, required ScrollPhysics physics, required ScrollController controller, required List<Widget> slivers, required this.handle, required Clip clipBehavior, DragStartBehavior dragStartBehavior = DragStartBehavior.start, String? restorationId]
[{required Axis scrollDirection}, {required bool reverse}, {required ScrollPhysics physics}, {required ScrollController controller}, {required List<Widget> slivers}, {required SliverOverlapAbsorberHandle handle}, {required Clip clipBehavior}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {String? restorationId}]
For class -> _InheritedNestedScrollView
[Key? key, required this.state, required Widget child]
[{Key? key}, {required NestedScrollViewState state}, {required Widget child}]
For class -> _NestedScrollMetrics
[required double? minScrollExtent, required double? maxScrollExtent, required double? pixels, required double? viewportDimension, required AxisDirection axisDirection, required this.minRange, required this.maxRange, required this.correctionOffset]
[{required double? minScrollExtent}, {required double? maxScrollExtent}, {required double? pixels}, {required double? viewportDimension}, {required AxisDirection axisDirection}, {required double minRange}, {required double maxRange}, {required double correctionOffset}]
For class -> _NestedScrollCoordinator
[this._state, this._parent, this._onHasScrolledBodyChanged, this._floatHeaderSlivers]
[NestedScrollViewState _state, ScrollController? _parent, void Function() _onHasScrolledBodyChanged, bool _floatHeaderSlivers]
For class -> _NestedScrollController
[this.coordinator, double initialScrollOffset = 0.0, String? debugLabel]
[_NestedScrollCoordinator coordinator, {double initialScrollOffset = 0.0}, {String? debugLabel}]
For class -> _NestedScrollPosition
[required ScrollPhysics physics, required ScrollContext context, double initialPixels = 0.0, ScrollPosition? oldPosition, String? debugLabel, required this.coordinator]
[{required ScrollPhysics physics}, {required ScrollContext context}, {double initialPixels = 0.0}, {ScrollPosition? oldPosition}, {String? debugLabel}, {required _NestedScrollCoordinator coordinator}]
For class -> _NestedInnerBallisticScrollActivity
[this.coordinator, _NestedScrollPosition position, Simulation simulation, TickerProvider vsync]
[_NestedScrollCoordinator coordinator, _NestedScrollPosition position, Simulation simulation, TickerProvider vsync]
For class -> _NestedOuterBallisticScrollActivity
[this.coordinator, _NestedScrollPosition position, this.metrics, Simulation simulation, TickerProvider vsync]
[_NestedScrollCoordinator coordinator, _NestedScrollPosition position, _NestedScrollMetrics metrics, Simulation simulation, TickerProvider vsync]
For class -> SliverOverlapAbsorberHandle
For class -> SliverOverlapAbsorber
[Key? key, required this.handle, Widget? sliver]
[{Key? key}, {required SliverOverlapAbsorberHandle handle}, {Widget? sliver}]
For class -> RenderSliverOverlapAbsorber
[required SliverOverlapAbsorberHandle handle, RenderSliver? sliver]
[{required SliverOverlapAbsorberHandle handle}, {RenderSliver? sliver}]
For class -> SliverOverlapInjector
[Key? key, required this.handle, Widget? sliver]
[{Key? key}, {required SliverOverlapAbsorberHandle handle}, {Widget? sliver}]
For class -> RenderSliverOverlapInjector
[required SliverOverlapAbsorberHandle handle]
[{required SliverOverlapAbsorberHandle handle}]
For class -> NestedScrollViewViewport
[Key? key, AxisDirection axisDirection = AxisDirection.down, AxisDirection? crossAxisDirection, double anchor = 0.0, required ViewportOffset offset, Key? center, List<Widget> slivers = const <Widget>[], required this.handle, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {AxisDirection? crossAxisDirection}, {double anchor = 0.0}, {required ViewportOffset offset}, {Key? center}, {List<Widget> slivers = const <Widget>[]}, {required SliverOverlapAbsorberHandle handle}, {Clip clipBehavior = Clip.hardEdge}]
For class -> RenderNestedScrollViewViewport
[AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, double anchor = 0.0, List<RenderSliver>? children, RenderSliver? center, required SliverOverlapAbsorberHandle handle, Clip clipBehavior = Clip.hardEdge]
[{AxisDirection axisDirection = AxisDirection.down}, {required AxisDirection crossAxisDirection}, {required ViewportOffset offset}, {double anchor = 0.0}, {List<RenderSliver>? children}, {RenderSliver? center}, {required SliverOverlapAbsorberHandle handle}, {Clip clipBehavior = Clip.hardEdge}]
For class -> Notification
[]
[]
For class -> NotificationListener
[Key? key, required this.child, this.onNotification]
[{Key? key}, {required Widget child}, {bool Function(T)? onNotification}]
For class -> LayoutChangedNotification
For class -> OrientationBuilder
[Key? key, required this.builder]
[{Key? key}, {required Widget Function(BuildContext, Orientation) builder}]
For class -> OverflowBar
[Key? key, this.spacing = 0.0, this.overflowSpacing = 0.0, this.overflowAlignment = OverflowBarAlignment.start, this.overflowDirection = VerticalDirection.down, this.textDirection, this.clipBehavior = Clip.none, List<Widget> children = const <Widget>[]]
[{Key? key}, {double spacing = 0.0}, {double overflowSpacing = 0.0}, {OverflowBarAlignment overflowAlignment = OverflowBarAlignment.start}, {VerticalDirection overflowDirection = VerticalDirection.down}, {TextDirection? textDirection}, {Clip clipBehavior = Clip.none}, {List<Widget> children = const <Widget>[]}]
For class -> _OverflowBarParentData
For class -> _RenderOverflowBar
[List<RenderBox>? children, double spacing = 0.0, double overflowSpacing = 0.0, OverflowBarAlignment overflowAlignment = OverflowBarAlignment.start, VerticalDirection overflowDirection = VerticalDirection.down, required TextDirection textDirection, Clip clipBehavior = Clip.none]
[{List<RenderBox>? children}, {double spacing = 0.0}, {double overflowSpacing = 0.0}, {OverflowBarAlignment overflowAlignment = OverflowBarAlignment.start}, {VerticalDirection overflowDirection = VerticalDirection.down}, {required TextDirection textDirection}, {Clip clipBehavior = Clip.none}]
For class -> OverlayEntry
[required this.builder, bool opaque = false, bool maintainState = false]
[{required Widget Function(BuildContext) builder}, {bool opaque = false}, {bool maintainState = false}]
For class -> _OverlayEntryWidget
[required Key key, required this.entry, this.tickerEnabled = true]
[{required Key key}, {required OverlayEntry entry}, {bool tickerEnabled = true}]
For class -> _OverlayEntryWidgetState
For class -> Overlay
[Key? key, this.initialEntries = const <OverlayEntry>[], this.clipBehavior = Clip.hardEdge]
[{Key? key}, {List<OverlayEntry> initialEntries = const <OverlayEntry>[]}, {Clip clipBehavior = Clip.hardEdge}]
For class -> OverlayState
For class -> _Theatre
[Key? key, this.skipCount = 0, this.clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]]
[{Key? key}, {int skipCount = 0}, {Clip clipBehavior = Clip.hardEdge}, {List<Widget> children = const <Widget>[]}]
For class -> _TheatreElement
[_Theatre widget]
[_Theatre widget]
For class -> _RenderTheatre
[List<RenderBox>? children, required TextDirection textDirection, int skipCount = 0, Clip clipBehavior = Clip.hardEdge]
[{List<RenderBox>? children}, {required TextDirection textDirection}, {int skipCount = 0}, {Clip clipBehavior = Clip.hardEdge}]
For class -> GlowingOverscrollIndicator
[Key? key, this.showLeading = true, this.showTrailing = true, required this.axisDirection, required this.color, this.notificationPredicate = defaultScrollNotificationPredicate, this.child]
[{Key? key}, {bool showLeading = true}, {bool showTrailing = true}, {required AxisDirection axisDirection}, {required Color color}, {bool Function(ScrollNotification) notificationPredicate = defaultScrollNotificationPredicate}, {Widget? child}]
For class -> _GlowingOverscrollIndicatorState
For class -> _GlowController
[required TickerProvider vsync, required Color color, required Axis axis]
[{required TickerProvider vsync}, {required Color color}, {required Axis axis}]
For class -> _GlowingOverscrollIndicatorPainter
[this.leadingController, this.trailingController, required this.axisDirection, Listenable? repaint]
[{_GlowController? leadingController}, {_GlowController? trailingController}, {required AxisDirection axisDirection}, {Listenable? repaint}]
For class -> OverscrollIndicatorNotification
[required this.leading]
[{required bool leading}]
For class -> PageRoute
[RouteSettings? settings, this.fullscreenDialog = false]
[{RouteSettings? settings}, {bool fullscreenDialog = false}]
For class -> PageRouteBuilder
[RouteSettings? settings, required this.pageBuilder, this.transitionsBuilder = _defaultTransitionsBuilder, this.transitionDuration = const Duration(milliseconds: 300), this.reverseTransitionDuration = const Duration(milliseconds: 300), this.opaque = true, this.barrierDismissible = false, this.barrierColor, this.barrierLabel, this.maintainState = true, bool fullscreenDialog = false]
[{RouteSettings? settings}, {required Widget Function(BuildContext, Animation<double>, Animation<double>) pageBuilder}, {Widget Function(BuildContext, Animation<double>, Animation<double>, Widget) transitionsBuilder = _defaultTransitionsBuilder}, {Duration transitionDuration = const Duration(milliseconds: 300)}, {Duration reverseTransitionDuration = const Duration(milliseconds: 300)}, {bool opaque = true}, {bool barrierDismissible = false}, {Color? barrierColor}, {String? barrierLabel}, {bool maintainState = true}, {bool fullscreenDialog = false}]
For class -> PageStorageKey
[T value]
[T value]
For class -> _StorageEntryIdentifier
[this.keys]
[List<PageStorageKey<dynamic>> keys]
For class -> PageStorageBucket
For class -> PageStorage
[Key? key, required this.bucket, required this.child]
[{Key? key}, {required PageStorageBucket bucket}, {required Widget child}]
For class -> PageController
[this.initialPage = 0, this.keepPage = true, this.viewportFraction = 1.0]
[{int initialPage = 0}, {bool keepPage = true}, {double viewportFraction = 1.0}]
For class -> PageMetrics
[required double? minScrollExtent, required double? maxScrollExtent, required double? pixels, required double? viewportDimension, required AxisDirection axisDirection, required this.viewportFraction]
[{required double? minScrollExtent}, {required double? maxScrollExtent}, {required double? pixels}, {required double? viewportDimension}, {required AxisDirection axisDirection}, {required double viewportFraction}]
For class -> _PagePosition
[required ScrollPhysics physics, required ScrollContext context, this.initialPage = 0, bool keepPage = true, double viewportFraction = 1.0, ScrollPosition? oldPosition]
[{required ScrollPhysics physics}, {required ScrollContext context}, {int initialPage = 0}, {bool keepPage = true}, {double viewportFraction = 1.0}, {ScrollPosition? oldPosition}]
For class -> _ForceImplicitScrollPhysics
[required this.allowImplicitScrolling, ScrollPhysics? parent]
[{required bool allowImplicitScrolling}, {ScrollPhysics? parent}]
For class -> PageScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> PageView
[Key? key, this.scrollDirection = Axis.horizontal, this.reverse = false, PageController? controller, this.physics, this.pageSnapping = true, this.onPageChanged, List<Widget> children = const <Widget>[], this.dragStartBehavior = DragStartBehavior.start, this.allowImplicitScrolling = false, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.horizontal}, {bool reverse = false}, {PageController? controller}, {ScrollPhysics? physics}, {bool pageSnapping = true}, {void Function(int)? onPageChanged}, {List<Widget> children = const <Widget>[]}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool allowImplicitScrolling = false}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, this.scrollDirection = Axis.horizontal, this.reverse = false, PageController? controller, this.physics, this.pageSnapping = true, this.onPageChanged, required IndexedWidgetBuilder itemBuilder, int? itemCount, this.dragStartBehavior = DragStartBehavior.start, this.allowImplicitScrolling = false, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.horizontal}, {bool reverse = false}, {PageController? controller}, {ScrollPhysics? physics}, {bool pageSnapping = true}, {void Function(int)? onPageChanged}, {required Widget Function(BuildContext, int) itemBuilder}, {int? itemCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool allowImplicitScrolling = false}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, this.scrollDirection = Axis.horizontal, this.reverse = false, PageController? controller, this.physics, this.pageSnapping = true, this.onPageChanged, required this.childrenDelegate, this.dragStartBehavior = DragStartBehavior.start, this.allowImplicitScrolling = false, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.horizontal}, {bool reverse = false}, {PageController? controller}, {ScrollPhysics? physics}, {bool pageSnapping = true}, {void Function(int)? onPageChanged}, {required SliverChildDelegate childrenDelegate}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {bool allowImplicitScrolling = false}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> _PageViewState
For class -> PerformanceOverlay
[Key? key, this.optionsMask = 0, this.rasterizerThreshold = 0, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false]
[{Key? key}, {int optionsMask = 0}, {int rasterizerThreshold = 0}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}]
[Key? key, this.rasterizerThreshold = 0, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false]
[{Key? key}, {int rasterizerThreshold = 0}, {bool checkerboardRasterCacheImages = false}, {bool checkerboardOffscreenLayers = false}]
For class -> _PlaceholderPainter
[required this.color, required this.strokeWidth]
[{required Color color}, {required double strokeWidth}]
For class -> Placeholder
[Key? key, this.color = const Color(0xFF455A64), this.strokeWidth = 2.0, this.fallbackWidth = 400.0, this.fallbackHeight = 400.0]
[{Key? key}, {Color color = const Color(0xFF455A64)}, {double strokeWidth = 2.0}, {double fallbackWidth = 400.0}, {double fallbackHeight = 400.0}]
For class -> AndroidView
[Key? key, required this.viewType, this.onPlatformViewCreated, this.hitTestBehavior = PlatformViewHitTestBehavior.opaque, this.layoutDirection, this.gestureRecognizers, this.creationParams, this.creationParamsCodec, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required String viewType}, {void Function(int)? onPlatformViewCreated}, {PlatformViewHitTestBehavior hitTestBehavior = PlatformViewHitTestBehavior.opaque}, {TextDirection? layoutDirection}, {Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers}, {dynamic creationParams}, {MessageCodec<dynamic>? creationParamsCodec}, {Clip clipBehavior = Clip.hardEdge}]
For class -> UiKitView
[Key? key, required this.viewType, this.onPlatformViewCreated, this.hitTestBehavior = PlatformViewHitTestBehavior.opaque, this.layoutDirection, this.creationParams, this.creationParamsCodec, this.gestureRecognizers]
[{Key? key}, {required String viewType}, {void Function(int)? onPlatformViewCreated}, {PlatformViewHitTestBehavior hitTestBehavior = PlatformViewHitTestBehavior.opaque}, {TextDirection? layoutDirection}, {dynamic creationParams}, {MessageCodec<dynamic>? creationParamsCodec}, {Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers}]
For class -> HtmlElementView
[Key? key, required this.viewType]
[{Key? key}, {required String viewType}]
For class -> _HtmlElementViewController
[this.viewId, this.viewType]
[int viewId, String viewType]
For class -> _AndroidViewState
For class -> _UiKitViewState
For class -> _AndroidPlatformView
[Key? key, required this.controller, required this.hitTestBehavior, required this.gestureRecognizers, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required AndroidViewController controller}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}, {Clip clipBehavior = Clip.hardEdge}]
For class -> _UiKitPlatformView
[Key? key, required this.controller, required this.hitTestBehavior, required this.gestureRecognizers]
[{Key? key}, {required UiKitViewController controller}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}]
For class -> PlatformViewCreationParams
[required this.id, required this.viewType, required this.onPlatformViewCreated, required this.onFocusChanged]
[{required int id}, {required String viewType}, {required void Function(int) onPlatformViewCreated}, {required void Function(bool) onFocusChanged}]
For class -> PlatformViewLink
[Key? key, required PlatformViewSurfaceFactory surfaceFactory, required CreatePlatformViewCallback onCreatePlatformView, required this.viewType]
[{Key? key}, {required Widget Function(BuildContext, PlatformViewController) surfaceFactory}, {required PlatformViewController Function(PlatformViewCreationParams) onCreatePlatformView}, {required String viewType}]
For class -> _PlatformViewLinkState
For class -> PlatformViewSurface
[Key? key, required this.controller, required this.hitTestBehavior, required this.gestureRecognizers]
[{Key? key}, {required PlatformViewController controller}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}]
For class -> AndroidViewSurface
[Key? key, required AndroidViewController controller, required PlatformViewHitTestBehavior hitTestBehavior, required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers]
[{Key? key}, {required AndroidViewController controller}, {required PlatformViewHitTestBehavior hitTestBehavior}, {required Set<Factory<OneSequenceGestureRecognizer>> gestureRecognizers}]
For class -> PreferredSizeWidget
For class -> PreferredSize
[Key? key, required this.child, required this.preferredSize]
[{Key? key}, {required Widget child}, {required Size preferredSize}]
For class -> PrimaryScrollController
[Key? key, required ScrollController this.controller, required Widget child]
[{Key? key}, {required ScrollController controller}, {required Widget child}]
[Key? key, required Widget child]
[{Key? key}, {required Widget child}]
For class -> RawKeyboardListener
[Key? key, required this.focusNode, this.autofocus = false, this.includeSemantics = true, this.onKey, required this.child]
[{Key? key}, {required FocusNode focusNode}, {bool autofocus = false}, {bool includeSemantics = true}, {void Function(RawKeyEvent)? onKey}, {required Widget child}]
For class -> _RawKeyboardListenerState
For class -> ReorderableList
[Key? key, required this.itemBuilder, required this.itemCount, required this.onReorder, this.proxyDecorator, this.padding, this.scrollDirection = Axis.vertical, this.reverse = false, this.controller, this.primary, this.physics, this.shrinkWrap = false, this.anchor = 0.0, this.cacheExtent, this.dragStartBehavior = DragStartBehavior.start, this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {required Widget Function(BuildContext, int) itemBuilder}, {required int itemCount}, {required void Function(int, int) onReorder}, {Widget Function(Widget, int, Animation<double>)? proxyDecorator}, {EdgeInsetsGeometry? padding}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {double anchor = 0.0}, {double? cacheExtent}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> ReorderableListState
For class -> SliverReorderableList
[Key? key, required this.itemBuilder, required this.itemCount, required this.onReorder, this.proxyDecorator]
[{Key? key}, {required Widget Function(BuildContext, int) itemBuilder}, {required int itemCount}, {required void Function(int, int) onReorder}, {Widget Function(Widget, int, Animation<double>)? proxyDecorator}]
For class -> SliverReorderableListState
For class -> _ReorderableItem
[required Key key, required this.index, required this.child, required this.capturedThemes]
[{required Key key}, {required int index}, {required Widget child}, {required CapturedThemes capturedThemes}]
For class -> _ReorderableItemState
For class -> ReorderableDragStartListener
[Key? key, required this.child, required this.index]
[{Key? key}, {required Widget child}, {required int index}]
For class -> ReorderableDelayedDragStartListener
[Key? key, required Widget child, required int index]
[{Key? key}, {required Widget child}, {required int index}]
For class -> _DragInfo
[required this.item, Offset initialPosition = Offset.zero, this.scrollDirection = Axis.vertical, this.onUpdate, this.onEnd, this.onCancel, this.onDropCompleted, this.proxyDecorator, required this.tickerProvider]
[{required _ReorderableItemState item}, {Offset initialPosition = Offset.zero}, {Axis scrollDirection = Axis.vertical}, {void Function(_DragInfo, Offset, Offset)? onUpdate}, {void Function(_DragInfo)? onEnd}, {void Function(_DragInfo)? onCancel}, {void Function()? onDropCompleted}, {Widget Function(Widget, int, Animation<double>)? proxyDecorator}, {required TickerProvider tickerProvider}]
For class -> _DragItemProxy
[Key? key, required this.item, required this.position, required this.size, required this.animation, required this.proxyDecorator]
[{Key? key}, {required _ReorderableItemState item}, {required Offset position}, {required Size size}, {required AnimationController animation}, {required Widget Function(Widget, int, Animation<double>)? proxyDecorator}]
For class -> _ReorderableItemGlobalKey
[this.subKey, this.index, this.state]
[Key subKey, int index, SliverReorderableListState state]
For class -> RestorationScope
[Key? key, required this.restorationId, required this.child]
[{Key? key}, {required String? restorationId}, {required Widget child}]
For class -> _RestorationScopeState
For class -> UnmanagedRestorationScope
[Key? key, this.bucket, required Widget child]
[{Key? key}, {RestorationBucket? bucket}, {required Widget child}]
For class -> RootRestorationScope
[Key? key, required this.restorationId, required this.child]
[{Key? key}, {required String? restorationId}, {required Widget child}]
For class -> _RootRestorationScopeState
For class -> RestorableProperty
For class -> RestorableValue
For class -> _RestorablePrimitiveValueN
[this._defaultValue]
[T _defaultValue]
For class -> _RestorablePrimitiveValue
[T _defaultValue]
[T _defaultValue]
For class -> RestorableNum
[T defaultValue]
[T defaultValue]
For class -> RestorableDouble
[double defaultValue]
[double defaultValue]
For class -> RestorableInt
[int defaultValue]
[int defaultValue]
For class -> RestorableString
[String defaultValue]
[String defaultValue]
For class -> RestorableBool
[bool defaultValue]
[bool defaultValue]
For class -> RestorableBoolN
[bool? defaultValue]
[bool? defaultValue]
For class -> RestorableNumN
[T defaultValue]
[T defaultValue]
For class -> RestorableDoubleN
[double? defaultValue]
[double? defaultValue]
For class -> RestorableIntN
[int? defaultValue]
[int? defaultValue]
For class -> RestorableStringN
[String? defaultValue]
[String? defaultValue]
For class -> RestorableListenable
For class -> RestorableChangeNotifier
For class -> RestorableTextEditingController
[String? text]
[{String? text}]
[TextEditingValue value]
[TextEditingValue value]
For class -> RouteInformation
[this.location, this.state]
[{String? location}, {Object? state}]
For class -> Router
[Key? key, this.routeInformationProvider, this.routeInformationParser, required this.routerDelegate, this.backButtonDispatcher]
[{Key? key}, {RouteInformationProvider? routeInformationProvider}, {RouteInformationParser<T>? routeInformationParser}, {required RouterDelegate<T> routerDelegate}, {BackButtonDispatcher? backButtonDispatcher}]
For class -> _RouterState
For class -> _RouterScope
[Key? key, required this.routeInformationProvider, required this.backButtonDispatcher, required this.routeInformationParser, required this.routerDelegate, required this.routerState, required Widget child]
[{Key? key}, {required ValueListenable<RouteInformation?>? routeInformationProvider}, {required BackButtonDispatcher? backButtonDispatcher}, {required RouteInformationParser<dynamic>? routeInformationParser}, {required RouterDelegate<dynamic> routerDelegate}, {required _RouterState<dynamic> routerState}, {required Widget child}]
For class -> _CallbackHookProvider
For class -> BackButtonDispatcher
For class -> RootBackButtonDispatcher
[]
[]
For class -> ChildBackButtonDispatcher
[this.parent]
[BackButtonDispatcher parent]
For class -> RouteInformationParser
[]
[]
For class -> RouterDelegate
For class -> RouteInformationProvider
For class -> PlatformRouteInformationProvider
[RouteInformation? initialRouteInformation]
[{RouteInformation? initialRouteInformation}]
For class -> OverlayRoute
[RouteSettings? settings]
[{RouteSettings? settings}]
For class -> TransitionRoute
[RouteSettings? settings]
[{RouteSettings? settings}]
For class -> LocalHistoryEntry
[this.onRemove]
[{void Function()? onRemove}]
For class -> _DismissModalAction
[this.context]
[BuildContext context]
For class -> _ModalScopeStatus
[Key? key, required this.isCurrent, required this.canPop, required this.route, required Widget child]
[{Key? key}, {required bool isCurrent}, {required bool canPop}, {required Route<dynamic> route}, {required Widget child}]
For class -> _ModalScope
[Key? key, required this.route]
[{Key? key}, {required ModalRoute<T> route}]
For class -> _ModalScopeState
For class -> ModalRoute
[RouteSettings? settings, this.filter]
[{RouteSettings? settings}, {ImageFilter? filter}]
For class -> PopupRoute
[RouteSettings? settings, ui.ImageFilter? filter]
[{RouteSettings? settings}, {ImageFilter? filter}]
For class -> RouteObserver
For class -> RouteAware
For class -> RawDialogRoute
[required RoutePageBuilder pageBuilder, bool barrierDismissible = true, Color? barrierColor = const Color(0x80000000), String? barrierLabel, Duration transitionDuration = const Duration(milliseconds: 200), RouteTransitionsBuilder? transitionBuilder, RouteSettings? settings]
[{required Widget Function(BuildContext, Animation<double>, Animation<double>) pageBuilder}, {bool barrierDismissible = true}, {Color? barrierColor = const Color(0x80000000)}, {String? barrierLabel}, {Duration transitionDuration = const Duration(milliseconds: 200)}, {Widget Function(BuildContext, Animation<double>, Animation<double>, Widget)? transitionBuilder}, {RouteSettings? settings}]
For class -> SafeArea
[Key? key, this.left = true, this.top = true, this.right = true, this.bottom = true, this.minimum = EdgeInsets.zero, this.maintainBottomViewPadding = false, required this.child]
[{Key? key}, {bool left = true}, {bool top = true}, {bool right = true}, {bool bottom = true}, {EdgeInsets minimum = EdgeInsets.zero}, {bool maintainBottomViewPadding = false}, {required Widget child}]
For class -> SliverSafeArea
[Key? key, this.left = true, this.top = true, this.right = true, this.bottom = true, this.minimum = EdgeInsets.zero, required this.sliver]
[{Key? key}, {bool left = true}, {bool top = true}, {bool right = true}, {bool bottom = true}, {EdgeInsets minimum = EdgeInsets.zero}, {required Widget sliver}]
For class -> Scrollable
[Key? key, this.axisDirection = AxisDirection.down, this.controller, this.physics, required this.viewportBuilder, this.incrementCalculator, this.excludeFromSemantics = false, this.semanticChildCount, this.dragStartBehavior = DragStartBehavior.start, this.restorationId]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {ScrollController? controller}, {ScrollPhysics? physics}, {required Widget Function(BuildContext, ViewportOffset) viewportBuilder}, {double Function(ScrollIncrementDetails)? incrementCalculator}, {bool excludeFromSemantics = false}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {String? restorationId}]
For class -> _ScrollableScope
[Key? key, required this.scrollable, required this.position, required Widget child]
[{Key? key}, {required ScrollableState scrollable}, {required ScrollPosition position}, {required Widget child}]
For class -> ScrollableState
For class -> _ScrollSemantics
[Key? key, required this.position, required this.allowImplicitScrolling, required this.semanticChildCount, Widget? child]
[{Key? key}, {required ScrollPosition position}, {required bool allowImplicitScrolling}, {required int? semanticChildCount}, {Widget? child}]
For class -> _RenderScrollSemantics
[required ScrollPosition position, required bool allowImplicitScrolling, required int? semanticChildCount, RenderBox? child]
[{required ScrollPosition position}, {required bool allowImplicitScrolling}, {required int? semanticChildCount}, {RenderBox? child}]
For class -> ScrollIncrementDetails
[required this.type, required this.metrics]
[{required ScrollIncrementType type}, {required ScrollMetrics metrics}]
For class -> ScrollIntent
[required this.direction, this.type = ScrollIncrementType.line]
[{required AxisDirection direction}, {ScrollIncrementType type = ScrollIncrementType.line}]
For class -> ScrollAction
For class -> _RestorableScrollOffset
For class -> ScrollbarPainter
[required Color color, required this.fadeoutOpacityAnimation, Color trackColor = const Color(0x00000000), Color trackBorderColor = const Color(0x00000000), TextDirection? textDirection, double thickness = _kScrollbarThickness, EdgeInsets padding = EdgeInsets.zero, double mainAxisMargin = 0.0, double crossAxisMargin = 0.0, Radius? radius, double minLength = _kMinThumbExtent, double? minOverscrollLength]
[{required Color color}, {required Animation<double> fadeoutOpacityAnimation}, {Color trackColor = const Color(0x00000000)}, {Color trackBorderColor = const Color(0x00000000)}, {TextDirection? textDirection}, {double thickness = _kScrollbarThickness}, {EdgeInsets padding = EdgeInsets.zero}, {double mainAxisMargin = 0.0}, {double crossAxisMargin = 0.0}, {Radius? radius}, {double minLength = _kMinThumbExtent}, {double? minOverscrollLength}]
For class -> RawScrollbar
[Key? key, required this.child, this.controller, this.isAlwaysShown, this.radius, this.thickness, this.thumbColor, this.fadeDuration = _kScrollbarFadeDuration, this.timeToFade = _kScrollbarTimeToFade, this.pressDuration = Duration.zero, this.notificationPredicate = defaultScrollNotificationPredicate]
[{Key? key}, {required Widget child}, {ScrollController? controller}, {bool? isAlwaysShown}, {Radius? radius}, {double? thickness}, {Color? thumbColor}, {Duration fadeDuration = _kScrollbarFadeDuration}, {Duration timeToFade = _kScrollbarTimeToFade}, {Duration pressDuration = Duration.zero}, {bool Function(ScrollNotification) notificationPredicate = defaultScrollNotificationPredicate}]
For class -> RawScrollbarState
For class -> _ThumbPressGestureRecognizer
[double? postAcceptSlopTolerance, PointerDeviceKind? kind, required Object debugOwner, required GlobalKey customPaintKey, required Duration pressDuration]
[{double? postAcceptSlopTolerance}, {PointerDeviceKind? kind}, {required Object debugOwner}, {required GlobalKey<State<StatefulWidget>> customPaintKey}, {required Duration pressDuration}]
For class -> _TrackTapGestureRecognizer
[required Object debugOwner, required GlobalKey customPaintKey]
[{required Object debugOwner}, {required GlobalKey<State<StatefulWidget>> customPaintKey}]
For class -> ScrollActivityDelegate
For class -> ScrollActivity
[this._delegate]
[ScrollActivityDelegate _delegate]
For class -> IdleScrollActivity
[ScrollActivityDelegate delegate]
[ScrollActivityDelegate delegate]
For class -> ScrollHoldController
For class -> HoldScrollActivity
[required ScrollActivityDelegate delegate, this.onHoldCanceled]
[{required ScrollActivityDelegate delegate}, {void Function()? onHoldCanceled}]
For class -> ScrollDragController
[required ScrollActivityDelegate delegate, required DragStartDetails details, this.onDragCanceled, this.carriedVelocity, this.motionStartDistanceThreshold]
[{required ScrollActivityDelegate delegate}, {required DragStartDetails details}, {void Function()? onDragCanceled}, {double? carriedVelocity}, {double? motionStartDistanceThreshold}]
For class -> DragScrollActivity
[ScrollActivityDelegate delegate, ScrollDragController controller]
[ScrollActivityDelegate delegate, ScrollDragController controller]
For class -> BallisticScrollActivity
[ScrollActivityDelegate delegate, Simulation simulation, TickerProvider vsync]
[ScrollActivityDelegate delegate, Simulation simulation, TickerProvider vsync]
For class -> DrivenScrollActivity
[ScrollActivityDelegate delegate, required double from, required double to, required Duration duration, required Curve curve, required TickerProvider vsync]
[ScrollActivityDelegate delegate, {required double from}, {required double to}, {required Duration duration}, {required Curve curve}, {required TickerProvider vsync}]
For class -> ScrollAwareImageProvider
[required this.context, required this.imageProvider]
[{required DisposableBuildContext<State<StatefulWidget>> context}, {required ImageProvider<T> imageProvider}]
For class -> ScrollBehavior
[]
[]
For class -> ScrollConfiguration
[Key? key, required this.behavior, required Widget child]
[{Key? key}, {required ScrollBehavior behavior}, {required Widget child}]
For class -> ScrollContext
For class -> ScrollController
[double initialScrollOffset = 0.0, this.keepScrollOffset = true, this.debugLabel]
[{double initialScrollOffset = 0.0}, {bool keepScrollOffset = true}, {String? debugLabel}]
For class -> TrackingScrollController
[double initialScrollOffset = 0.0, bool keepScrollOffset = true, String? debugLabel]
[{double initialScrollOffset = 0.0}, {bool keepScrollOffset = true}, {String? debugLabel}]
For class -> ScrollMetrics
For class -> FixedScrollMetrics
[required double? minScrollExtent, required double? maxScrollExtent, required double? pixels, required double? viewportDimension, required this.axisDirection]
[{required double? minScrollExtent}, {required double? maxScrollExtent}, {required double? pixels}, {required double? viewportDimension}, {required AxisDirection axisDirection}]
For class -> ScrollNotification
[required this.metrics, required this.context]
[{required ScrollMetrics metrics}, {required BuildContext? context}]
For class -> ScrollStartNotification
[required ScrollMetrics metrics, required BuildContext? context, this.dragDetails]
[{required ScrollMetrics metrics}, {required BuildContext? context}, {DragStartDetails? dragDetails}]
For class -> ScrollUpdateNotification
[required ScrollMetrics metrics, required BuildContext context, this.dragDetails, this.scrollDelta]
[{required ScrollMetrics metrics}, {required BuildContext context}, {DragUpdateDetails? dragDetails}, {double? scrollDelta}]
For class -> OverscrollNotification
[required ScrollMetrics metrics, required BuildContext context, this.dragDetails, required this.overscroll, this.velocity = 0.0]
[{required ScrollMetrics metrics}, {required BuildContext context}, {DragUpdateDetails? dragDetails}, {required double overscroll}, {double velocity = 0.0}]
For class -> ScrollEndNotification
[required ScrollMetrics metrics, required BuildContext context, this.dragDetails]
[{required ScrollMetrics metrics}, {required BuildContext context}, {DragEndDetails? dragDetails}]
For class -> UserScrollNotification
[required ScrollMetrics metrics, required BuildContext context, required this.direction]
[{required ScrollMetrics metrics}, {required BuildContext context}, {required ScrollDirection direction}]
For class -> ScrollPhysics
[this.parent]
[{ScrollPhysics? parent}]
For class -> RangeMaintainingScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> BouncingScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> ClampingScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> AlwaysScrollableScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> NeverScrollableScrollPhysics
[ScrollPhysics? parent]
[{ScrollPhysics? parent}]
For class -> ScrollPosition
[required this.physics, required this.context, this.keepScrollOffset = true, ScrollPosition? oldPosition, this.debugLabel]
[{required ScrollPhysics physics}, {required ScrollContext context}, {bool keepScrollOffset = true}, {ScrollPosition? oldPosition}, {String? debugLabel}]
For class -> ScrollPositionWithSingleContext
[required ScrollPhysics physics, required ScrollContext context, double? initialPixels = 0.0, bool keepScrollOffset = true, ScrollPosition? oldPosition, String? debugLabel]
[{required ScrollPhysics physics}, {required ScrollContext context}, {double? initialPixels = 0.0}, {bool keepScrollOffset = true}, {ScrollPosition? oldPosition}, {String? debugLabel}]
For class -> BouncingScrollSimulation
[required double position, required double velocity, required this.leadingExtent, required this.trailingExtent, required this.spring, Tolerance tolerance = Tolerance.defaultTolerance]
[{required double position}, {required double velocity}, {required double leadingExtent}, {required double trailingExtent}, {required SpringDescription spring}, {Tolerance tolerance = Tolerance.defaultTolerance}]
For class -> ClampingScrollSimulation
[required this.position, required this.velocity, this.friction = 0.015, Tolerance tolerance = Tolerance.defaultTolerance]
[{required double position}, {required double velocity}, {double friction = 0.015}, {Tolerance tolerance = Tolerance.defaultTolerance}]
For class -> ScrollView
[Key? key, this.scrollDirection = Axis.vertical, this.reverse = false, this.controller, bool? primary, ScrollPhysics? physics, this.shrinkWrap = false, this.center, this.anchor = 0.0, this.cacheExtent, this.semanticChildCount, this.dragStartBehavior = DragStartBehavior.start, this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, this.restorationId, this.clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {Key? center}, {double anchor = 0.0}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> CustomScrollView
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, Key? center, double anchor = 0.0, double? cacheExtent, this.slivers = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {Key? center}, {double anchor = 0.0}, {double? cacheExtent}, {List<Widget> slivers = const <Widget>[]}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> BoxScrollView
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, this.padding, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> ListView
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, this.itemExtent, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {double? itemExtent}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {List<Widget> children = const <Widget>[]}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, this.itemExtent, required IndexedWidgetBuilder itemBuilder, int? itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {double? itemExtent}, {required Widget Function(BuildContext, int) itemBuilder}, {int? itemCount}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required IndexedWidgetBuilder itemBuilder, required IndexedWidgetBuilder separatorBuilder, required int itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required Widget Function(BuildContext, int) itemBuilder}, {required Widget Function(BuildContext, int) separatorBuilder}, {required int itemCount}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, this.itemExtent, required this.childrenDelegate, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {double? itemExtent}, {required SliverChildDelegate childrenDelegate}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> GridView
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required this.gridDelegate, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Clip clipBehavior = Clip.hardEdge, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required SliverGridDelegate gridDelegate}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {List<Widget> children = const <Widget>[]}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {Clip clipBehavior = Clip.hardEdge}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required this.gridDelegate, required IndexedWidgetBuilder itemBuilder, int? itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required SliverGridDelegate gridDelegate}, {required Widget Function(BuildContext, int) itemBuilder}, {int? itemCount}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required this.gridDelegate, required this.childrenDelegate, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required SliverGridDelegate gridDelegate}, {required SliverChildDelegate childrenDelegate}, {double? cacheExtent}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required int crossAxisCount}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {List<Widget> children = const <Widget>[]}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
[Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {ScrollController? controller}, {bool? primary}, {ScrollPhysics? physics}, {bool shrinkWrap = false}, {EdgeInsetsGeometry? padding}, {required double maxCrossAxisExtent}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {double? cacheExtent}, {List<Widget> children = const <Widget>[]}, {int? semanticChildCount}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual}, {String? restorationId}, {Clip clipBehavior = Clip.hardEdge}]
For class -> SemanticsDebugger
[Key? key, required this.child, this.labelStyle = const TextStyle(color: Color(0xFF000000), fontSize: 10.0, height: 0.8)]
[{Key? key}, {required Widget child}, {TextStyle labelStyle = const TextStyle(color: Color(0xFF000000), fontSize: 10.0, height: 0.8)}]
For class -> _SemanticsDebuggerState
For class -> _SemanticsClient
[PipelineOwner pipelineOwner]
[PipelineOwner pipelineOwner]
For class -> _SemanticsDebuggerPainter
[this.owner, this.generation, this.pointerPosition, this.devicePixelRatio, this.labelStyle]
[PipelineOwner owner, int generation, Offset? pointerPosition, double devicePixelRatio, TextStyle labelStyle]
For class -> KeySet
[T key1, T? key2, T? key3, T? key4]
[T key1, [T? key2], [T? key3], [T? key4]]
[Set<T> keys]
[Set<T> keys]
For class -> LogicalKeySet
[LogicalKeyboardKey key1, LogicalKeyboardKey? key2, LogicalKeyboardKey? key3, LogicalKeyboardKey? key4]
[LogicalKeyboardKey key1, [LogicalKeyboardKey? key2], [LogicalKeyboardKey? key3], [LogicalKeyboardKey? key4]]
[Set<LogicalKeyboardKey> keys]
[Set<LogicalKeyboardKey> keys]
For class -> ShortcutMapProperty
[String name, Map<LogicalKeySet, Intent> value, bool showName = true, Object defaultValue = kNoDefaultValue, DiagnosticLevel level = DiagnosticLevel.info, String? description]
[String name, Map<LogicalKeySet, Intent> value, {bool showName = true}, {Object defaultValue = kNoDefaultValue}, {DiagnosticLevel level = DiagnosticLevel.info}, {String? description}]
For class -> ShortcutManager
[Map<LogicalKeySet, Intent> shortcuts = const <LogicalKeySet, Intent>{}, this.modal = false]
[{Map<LogicalKeySet, Intent> shortcuts = const <LogicalKeySet, Intent>{}}, {bool modal = false}]
For class -> Shortcuts
[Key? key, this.manager, required this.shortcuts, required this.child, this.debugLabel]
[{Key? key}, {ShortcutManager? manager}, {required Map<LogicalKeySet, Intent> shortcuts}, {required Widget child}, {String? debugLabel}]
For class -> _ShortcutsState
For class -> _ShortcutsMarker
[required ShortcutManager manager, required Widget child]
[{required ShortcutManager manager}, {required Widget child}]
For class -> SingleChildScrollView
[Key? key, this.scrollDirection = Axis.vertical, this.reverse = false, this.padding, bool? primary, this.physics, this.controller, this.child, this.dragStartBehavior = DragStartBehavior.start, this.clipBehavior = Clip.hardEdge, this.restorationId]
[{Key? key}, {Axis scrollDirection = Axis.vertical}, {bool reverse = false}, {EdgeInsetsGeometry? padding}, {bool? primary}, {ScrollPhysics? physics}, {ScrollController? controller}, {Widget? child}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {Clip clipBehavior = Clip.hardEdge}, {String? restorationId}]
For class -> _SingleChildViewport
[Key? key, this.axisDirection = AxisDirection.down, required this.offset, Widget? child, required this.clipBehavior]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {required ViewportOffset offset}, {Widget? child}, {required Clip clipBehavior}]
For class -> _RenderSingleChildViewport
[AxisDirection axisDirection = AxisDirection.down, required ViewportOffset offset, double cacheExtent = RenderAbstractViewport.defaultCacheExtent, RenderBox? child, required Clip clipBehavior]
[{AxisDirection axisDirection = AxisDirection.down}, {required ViewportOffset offset}, {double cacheExtent = RenderAbstractViewport.defaultCacheExtent}, {RenderBox? child}, {required Clip clipBehavior}]
For class -> SizeChangedLayoutNotification
For class -> SizeChangedLayoutNotifier
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> _RenderSizeChangedWithCallback
[RenderBox? child, required this.onLayoutChangedCallback]
[{RenderBox? child}, {required void Function() onLayoutChangedCallback}]
For class -> SliverChildDelegate
[]
[]
For class -> _SaltedValueKey
[Key key]
[Key key]
For class -> SliverChildBuilderDelegate
[this.builder, this.findChildIndexCallback, this.childCount, this.addAutomaticKeepAlives = true, this.addRepaintBoundaries = true, this.addSemanticIndexes = true, this.semanticIndexCallback = _kDefaultSemanticIndexCallback, this.semanticIndexOffset = 0]
[Widget? Function(BuildContext, int) builder, {int? Function(Key)? findChildIndexCallback}, {int? childCount}, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {int? Function(Widget, int) semanticIndexCallback = _kDefaultSemanticIndexCallback}, {int semanticIndexOffset = 0}]
For class -> SliverChildListDelegate
[this.children, this.addAutomaticKeepAlives = true, this.addRepaintBoundaries = true, this.addSemanticIndexes = true, this.semanticIndexCallback = _kDefaultSemanticIndexCallback, this.semanticIndexOffset = 0]
[List<Widget> children, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {int? Function(Widget, int) semanticIndexCallback = _kDefaultSemanticIndexCallback}, {int semanticIndexOffset = 0}]
[this.children, this.addAutomaticKeepAlives = true, this.addRepaintBoundaries = true, this.addSemanticIndexes = true, this.semanticIndexCallback = _kDefaultSemanticIndexCallback, this.semanticIndexOffset = 0]
[List<Widget> children, {bool addAutomaticKeepAlives = true}, {bool addRepaintBoundaries = true}, {bool addSemanticIndexes = true}, {int? Function(Widget, int) semanticIndexCallback = _kDefaultSemanticIndexCallback}, {int semanticIndexOffset = 0}]
For class -> SliverWithKeepAliveWidget
[Key? key]
[{Key? key}]
For class -> SliverMultiBoxAdaptorWidget
[Key? key, required this.delegate]
[{Key? key}, {required SliverChildDelegate delegate}]
For class -> SliverList
[Key? key, required SliverChildDelegate delegate]
[{Key? key}, {required SliverChildDelegate delegate}]
For class -> SliverFixedExtentList
[Key? key, required SliverChildDelegate delegate, required this.itemExtent]
[{Key? key}, {required SliverChildDelegate delegate}, {required double itemExtent}]
For class -> SliverGrid
[Key? key, required SliverChildDelegate delegate, required this.gridDelegate]
[{Key? key}, {required SliverChildDelegate delegate}, {required SliverGridDelegate gridDelegate}]
[Key? key, required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, List<Widget> children = const <Widget>[]]
[{Key? key}, {required int crossAxisCount}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {List<Widget> children = const <Widget>[]}]
[Key? key, required double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, List<Widget> children = const <Widget>[]]
[{Key? key}, {required double maxCrossAxisExtent}, {double mainAxisSpacing = 0.0}, {double crossAxisSpacing = 0.0}, {double childAspectRatio = 1.0}, {List<Widget> children = const <Widget>[]}]
For class -> SliverMultiBoxAdaptorElement
[SliverMultiBoxAdaptorWidget widget, bool replaceMovedChildren = false]
[SliverMultiBoxAdaptorWidget widget, {bool replaceMovedChildren = false}]
For class -> SliverOpacity
[Key? key, required this.opacity, this.alwaysIncludeSemantics = false, Widget? sliver]
[{Key? key}, {required double opacity}, {bool alwaysIncludeSemantics = false}, {Widget? sliver}]
For class -> SliverIgnorePointer
[Key? key, this.ignoring = true, this.ignoringSemantics, Widget? sliver]
[{Key? key}, {bool ignoring = true}, {bool? ignoringSemantics}, {Widget? sliver}]
For class -> SliverOffstage
[Key? key, this.offstage = true, Widget? sliver]
[{Key? key}, {bool offstage = true}, {Widget? sliver}]
For class -> _SliverOffstageElement
[SliverOffstage widget]
[SliverOffstage widget]
For class -> KeepAlive
[Key? key, required this.keepAlive, required Widget child]
[{Key? key}, {required bool keepAlive}, {required Widget child}]
For class -> SliverFillViewport
[Key? key, required this.delegate, this.viewportFraction = 1.0, this.padEnds = true]
[{Key? key}, {required SliverChildDelegate delegate}, {double viewportFraction = 1.0}, {bool padEnds = true}]
For class -> _SliverFillViewportRenderObjectWidget
[Key? key, required SliverChildDelegate delegate, this.viewportFraction = 1.0]
[{Key? key}, {required SliverChildDelegate delegate}, {double viewportFraction = 1.0}]
For class -> _SliverFractionalPadding
[this.viewportFraction = 0, Widget? sliver]
[{double viewportFraction = 0}, {Widget? sliver}]
For class -> _RenderSliverFractionalPadding
[double viewportFraction = 0]
[{double viewportFraction = 0}]
For class -> SliverFillRemaining
[Key? key, this.child, this.hasScrollBody = true, this.fillOverscroll = false]
[{Key? key}, {Widget? child}, {bool hasScrollBody = true}, {bool fillOverscroll = false}]
For class -> _SliverFillRemainingWithScrollable
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> _SliverFillRemainingWithoutScrollable
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> _SliverFillRemainingAndOverscroll
[Key? key, Widget? child]
[{Key? key}, {Widget? child}]
For class -> SliverLayoutBuilder
[Key? key, required SliverLayoutWidgetBuilder builder]
[{Key? key}, {required Widget Function(BuildContext, SliverConstraints) builder}]
For class -> _RenderSliverLayoutBuilder
For class -> SliverPersistentHeaderDelegate
[]
[]
For class -> SliverPersistentHeader
[Key? key, required this.delegate, this.pinned = false, this.floating = false]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}, {bool pinned = false}, {bool floating = false}]
For class -> _SliverPersistentHeaderElement
[_SliverPersistentHeaderRenderObjectWidget widget]
[_SliverPersistentHeaderRenderObjectWidget widget]
For class -> _SliverPersistentHeaderRenderObjectWidget
[Key? key, required this.delegate]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}]
For class -> _SliverScrollingPersistentHeader
[Key? key, required SliverPersistentHeaderDelegate delegate]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}]
For class -> _RenderSliverScrollingPersistentHeaderForWidgets
[RenderBox? child, OverScrollHeaderStretchConfiguration? stretchConfiguration]
[{RenderBox? child}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}]
For class -> _SliverPinnedPersistentHeader
[Key? key, required SliverPersistentHeaderDelegate delegate]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}]
For class -> _RenderSliverPinnedPersistentHeaderForWidgets
[RenderBox? child, OverScrollHeaderStretchConfiguration? stretchConfiguration, PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration]
[{RenderBox? child}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}]
For class -> _SliverFloatingPersistentHeader
[Key? key, required SliverPersistentHeaderDelegate delegate]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}]
For class -> _RenderSliverFloatingPinnedPersistentHeaderForWidgets
[RenderBox? child, required TickerProvider? vsync, FloatingHeaderSnapConfiguration? snapConfiguration, OverScrollHeaderStretchConfiguration? stretchConfiguration, PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration]
[{RenderBox? child}, {required TickerProvider? vsync}, {FloatingHeaderSnapConfiguration? snapConfiguration}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}]
For class -> _SliverFloatingPinnedPersistentHeader
[Key? key, required SliverPersistentHeaderDelegate delegate]
[{Key? key}, {required SliverPersistentHeaderDelegate delegate}]
For class -> _RenderSliverFloatingPersistentHeaderForWidgets
[RenderBox? child, required TickerProvider? vsync, FloatingHeaderSnapConfiguration? snapConfiguration, OverScrollHeaderStretchConfiguration? stretchConfiguration, PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration]
[{RenderBox? child}, {required TickerProvider? vsync}, {FloatingHeaderSnapConfiguration? snapConfiguration}, {OverScrollHeaderStretchConfiguration? stretchConfiguration}, {PersistentHeaderShowOnScreenConfiguration? showOnScreenConfiguration}]
For class -> SliverPrototypeExtentList
[Key? key, required SliverChildDelegate delegate, required this.prototypeItem]
[{Key? key}, {required SliverChildDelegate delegate}, {required Widget prototypeItem}]
For class -> _SliverPrototypeExtentListElement
[SliverPrototypeExtentList widget]
[SliverPrototypeExtentList widget]
For class -> _RenderSliverPrototypeExtentList
[required _SliverPrototypeExtentListElement childManager]
[{required _SliverPrototypeExtentListElement childManager}]
For class -> Spacer
[Key? key, this.flex = 1]
[{Key? key}, {int flex = 1}]
For class -> StatusTransitionWidget
[Key? key, required this.animation]
[{Key? key}, {required Animation<double> animation}]
For class -> _StatusTransitionState
For class -> TableRow
[this.key, this.decoration, this.children]
[{LocalKey? key}, {Decoration? decoration}, {List<Widget>? children}]
For class -> _TableElementRow
[this.key, required this.children]
[{LocalKey? key}, {required List<Element> children}]
For class -> Table
[Key? key, this.children = const <TableRow>[], this.columnWidths, this.defaultColumnWidth = const FlexColumnWidth(1.0), this.textDirection, this.border, this.defaultVerticalAlignment = TableCellVerticalAlignment.top, this.textBaseline]
[{Key? key}, {List<TableRow> children = const <TableRow>[]}, {Map<int, TableColumnWidth>? columnWidths}, {TableColumnWidth defaultColumnWidth = const FlexColumnWidth(1.0)}, {TextDirection? textDirection}, {TableBorder? border}, {TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.top}, {TextBaseline? textBaseline}]
For class -> _TableElement
[Table widget]
[Table widget]
For class -> TableCell
[Key? key, this.verticalAlignment, required Widget child]
[{Key? key}, {TableCellVerticalAlignment? verticalAlignment}, {required Widget child}]
For class -> DefaultTextStyle
[Key? key, required this.style, this.textAlign, this.softWrap = true, this.overflow = TextOverflow.clip, this.maxLines, this.textWidthBasis = TextWidthBasis.parent, this.textHeightBehavior, required Widget child]
[{Key? key}, {required TextStyle style}, {TextAlign? textAlign}, {bool softWrap = true}, {TextOverflow overflow = TextOverflow.clip}, {int? maxLines}, {TextWidthBasis textWidthBasis = TextWidthBasis.parent}, {TextHeightBehavior? textHeightBehavior}, {required Widget child}]
[Key? key]
[{Key? key}]
For class -> _NullWidget
[]
[]
For class -> DefaultTextHeightBehavior
[Key? key, required this.textHeightBehavior, required Widget child]
[{Key? key}, {required TextHeightBehavior textHeightBehavior}, {required Widget child}]
For class -> Text
[String this.data, Key? key, this.style, this.strutStyle, this.textAlign, this.textDirection, this.locale, this.softWrap, this.overflow, this.textScaleFactor, this.maxLines, this.semanticsLabel, this.textWidthBasis, this.textHeightBehavior]
[String data, {Key? key}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign? textAlign}, {TextDirection? textDirection}, {Locale? locale}, {bool? softWrap}, {TextOverflow? overflow}, {double? textScaleFactor}, {int? maxLines}, {String? semanticsLabel}, {TextWidthBasis? textWidthBasis}, {TextHeightBehavior? textHeightBehavior}]
[InlineSpan this.textSpan, Key? key, this.style, this.strutStyle, this.textAlign, this.textDirection, this.locale, this.softWrap, this.overflow, this.textScaleFactor, this.maxLines, this.semanticsLabel, this.textWidthBasis, this.textHeightBehavior]
[InlineSpan textSpan, {Key? key}, {TextStyle? style}, {StrutStyle? strutStyle}, {TextAlign? textAlign}, {TextDirection? textDirection}, {Locale? locale}, {bool? softWrap}, {TextOverflow? overflow}, {double? textScaleFactor}, {int? maxLines}, {String? semanticsLabel}, {TextWidthBasis? textWidthBasis}, {TextHeightBehavior? textHeightBehavior}]
For class -> Texture
[Key? key, required this.textureId, this.filterQuality = FilterQuality.low]
[{Key? key}, {required int textureId}, {FilterQuality filterQuality = FilterQuality.low}]
For class -> ToolbarItemsParentData
For class -> TextSelectionControls
For class -> TextSelectionOverlay
[required TextEditingValue value, required this.context, this.debugRequiredFor, required this.toolbarLayerLink, required this.startHandleLayerLink, required this.endHandleLayerLink, required this.renderObject, this.selectionControls, bool handlesVisible = false, this.selectionDelegate, this.dragStartBehavior = DragStartBehavior.start, this.onSelectionHandleTapped, this.clipboardStatus]
[{required TextEditingValue value}, {required BuildContext context}, {Widget? debugRequiredFor}, {required LayerLink toolbarLayerLink}, {required LayerLink startHandleLayerLink}, {required LayerLink endHandleLayerLink}, {required RenderEditable renderObject}, {TextSelectionControls? selectionControls}, {bool handlesVisible = false}, {TextSelectionDelegate? selectionDelegate}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}, {void Function()? onSelectionHandleTapped}, {ClipboardStatusNotifier? clipboardStatus}]
For class -> _TextSelectionHandleOverlay
[Key? key, required this.selection, required this.position, required this.startHandleLayerLink, required this.endHandleLayerLink, required this.renderObject, required this.onSelectionHandleChanged, required this.onSelectionHandleTapped, required this.selectionControls, this.dragStartBehavior = DragStartBehavior.start]
[{Key? key}, {required TextSelection selection}, {required _TextSelectionHandlePosition position}, {required LayerLink startHandleLayerLink}, {required LayerLink endHandleLayerLink}, {required RenderEditable renderObject}, {required void Function(TextSelection) onSelectionHandleChanged}, {required void Function()? onSelectionHandleTapped}, {required TextSelectionControls? selectionControls}, {DragStartBehavior dragStartBehavior = DragStartBehavior.start}]
For class -> _TextSelectionHandleOverlayState
For class -> TextSelectionGestureDetectorBuilderDelegate
For class -> TextSelectionGestureDetectorBuilder
[required this.delegate]
[{required TextSelectionGestureDetectorBuilderDelegate delegate}]
For class -> TextSelectionGestureDetector
[Key? key, this.onTapDown, this.onForcePressStart, this.onForcePressEnd, this.onSecondaryTap, this.onSecondaryTapDown, this.onSingleTapUp, this.onSingleTapCancel, this.onSingleLongTapStart, this.onSingleLongTapMoveUpdate, this.onSingleLongTapEnd, this.onDoubleTapDown, this.onDragSelectionStart, this.onDragSelectionUpdate, this.onDragSelectionEnd, this.behavior, required this.child]
[{Key? key}, {void Function(TapDownDetails)? onTapDown}, {void Function(ForcePressDetails)? onForcePressStart}, {void Function(ForcePressDetails)? onForcePressEnd}, {void Function()? onSecondaryTap}, {void Function(TapDownDetails)? onSecondaryTapDown}, {void Function(TapUpDetails)? onSingleTapUp}, {void Function()? onSingleTapCancel}, {void Function(LongPressStartDetails)? onSingleLongTapStart}, {void Function(LongPressMoveUpdateDetails)? onSingleLongTapMoveUpdate}, {void Function(LongPressEndDetails)? onSingleLongTapEnd}, {void Function(TapDownDetails)? onDoubleTapDown}, {void Function(DragStartDetails)? onDragSelectionStart}, {void Function(DragStartDetails, DragUpdateDetails)? onDragSelectionUpdate}, {void Function(DragEndDetails)? onDragSelectionEnd}, {HitTestBehavior? behavior}, {required Widget child}]
For class -> _TextSelectionGestureDetectorState
For class -> _TransparentTapGestureRecognizer
[Object? debugOwner]
[{Object? debugOwner}]
For class -> ClipboardStatusNotifier
[ClipboardStatus value = ClipboardStatus.unknown]
[{ClipboardStatus value = ClipboardStatus.unknown}]
For class -> TextSelectionToolbarLayoutDelegate
[required this.anchorAbove, required this.anchorBelow, this.fitsAbove]
[{required Offset anchorAbove}, {required Offset anchorBelow}, {bool? fitsAbove}]
For class -> TickerMode
[Key? key, required this.enabled, required this.child]
[{Key? key}, {required bool enabled}, {required Widget child}]
For class -> _EffectiveTickerMode
[Key? key, required this.enabled, required Widget child]
[{Key? key}, {required bool enabled}, {required Widget child}]
For class -> _WidgetTicker
[TickerCallback onTick, this._creator, String? debugLabel]
[void Function(Duration) onTick, TickerProviderStateMixin<StatefulWidget> _creator, {String? debugLabel}]
For class -> Title
[Key? key, this.title = '', required this.color, required this.child]
[{Key? key}, {String title = ''}, {required Color color}, {required Widget child}]
For class -> AnimatedWidget
[Key? key, required this.listenable]
[{Key? key}, {required Listenable listenable}]
For class -> _AnimatedState
For class -> SlideTransition
[Key? key, required Animation<Offset> position, this.transformHitTests = true, this.textDirection, this.child]
[{Key? key}, {required Animation<Offset> position}, {bool transformHitTests = true}, {TextDirection? textDirection}, {Widget? child}]
For class -> ScaleTransition
[Key? key, required Animation<double> scale, this.alignment = Alignment.center, this.child]
[{Key? key}, {required Animation<double> scale}, {Alignment alignment = Alignment.center}, {Widget? child}]
For class -> RotationTransition
[Key? key, required Animation<double> turns, this.alignment = Alignment.center, this.child]
[{Key? key}, {required Animation<double> turns}, {Alignment alignment = Alignment.center}, {Widget? child}]
For class -> SizeTransition
[Key? key, this.axis = Axis.vertical, required Animation<double> sizeFactor, this.axisAlignment = 0.0, this.child]
[{Key? key}, {Axis axis = Axis.vertical}, {required Animation<double> sizeFactor}, {double axisAlignment = 0.0}, {Widget? child}]
For class -> FadeTransition
[Key? key, required this.opacity, this.alwaysIncludeSemantics = false, Widget? child]
[{Key? key}, {required Animation<double> opacity}, {bool alwaysIncludeSemantics = false}, {Widget? child}]
For class -> SliverFadeTransition
[Key? key, required this.opacity, this.alwaysIncludeSemantics = false, Widget? sliver]
[{Key? key}, {required Animation<double> opacity}, {bool alwaysIncludeSemantics = false}, {Widget? sliver}]
For class -> RelativeRectTween
[RelativeRect? begin, RelativeRect? end]
[{RelativeRect? begin}, {RelativeRect? end}]
For class -> PositionedTransition
[Key? key, required Animation<RelativeRect> rect, required this.child]
[{Key? key}, {required Animation<RelativeRect> rect}, {required Widget child}]
For class -> RelativePositionedTransition
[Key? key, required Animation<Rect> rect, required this.size, required this.child]
[{Key? key}, {required Animation<Rect> rect}, {required Size size}, {required Widget child}]
For class -> DecoratedBoxTransition
[Key? key, required this.decoration, this.position = DecorationPosition.background, required this.child]
[{Key? key}, {required Animation<Decoration> decoration}, {DecorationPosition position = DecorationPosition.background}, {required Widget child}]
For class -> AlignTransition
[Key? key, required Animation<AlignmentGeometry> alignment, required this.child, this.widthFactor, this.heightFactor]
[{Key? key}, {required Animation<AlignmentGeometry> alignment}, {required Widget child}, {double? widthFactor}, {double? heightFactor}]
For class -> DefaultTextStyleTransition
[Key? key, required Animation<TextStyle> style, required this.child, this.textAlign, this.softWrap = true, this.overflow = TextOverflow.clip, this.maxLines]
[{Key? key}, {required Animation<TextStyle> style}, {required Widget child}, {TextAlign? textAlign}, {bool softWrap = true}, {TextOverflow overflow = TextOverflow.clip}, {int? maxLines}]
For class -> AnimatedBuilder
[Key? key, required Listenable animation, required this.builder, this.child]
[{Key? key}, {required Listenable animation}, {required Widget Function(BuildContext, Widget?) builder}, {Widget? child}]
For class -> TweenAnimationBuilder
[Key? key, required this.tween, required Duration duration, Curve curve = Curves.linear, required this.builder, VoidCallback? onEnd, this.child]
[{Key? key}, {required Tween<T> tween}, {required Duration duration}, {Curve curve = Curves.linear}, {required Widget Function(BuildContext, T, Widget?) builder}, {void Function()? onEnd}, {Widget? child}]
For class -> _TweenAnimationBuilderState
For class -> UniqueWidget
[required GlobalKey<T> key]
[{required GlobalKey<T> key}]
For class -> ValueListenableBuilder
[Key? key, required this.valueListenable, required this.builder, this.child]
[{Key? key}, {required ValueListenable<T> valueListenable}, {required Widget Function(BuildContext, T, Widget?) builder}, {Widget? child}]
For class -> _ValueListenableBuilderState
For class -> Viewport
[Key? key, this.axisDirection = AxisDirection.down, this.crossAxisDirection, this.anchor = 0.0, required this.offset, this.center, this.cacheExtent, this.cacheExtentStyle = CacheExtentStyle.pixel, this.clipBehavior = Clip.hardEdge, List<Widget> slivers = const <Widget>[]]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {AxisDirection? crossAxisDirection}, {double anchor = 0.0}, {required ViewportOffset offset}, {Key? center}, {double? cacheExtent}, {CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel}, {Clip clipBehavior = Clip.hardEdge}, {List<Widget> slivers = const <Widget>[]}]
For class -> _ViewportElement
[Viewport widget]
[Viewport widget]
For class -> ShrinkWrappingViewport
[Key? key, this.axisDirection = AxisDirection.down, this.crossAxisDirection, required this.offset, this.clipBehavior = Clip.hardEdge, List<Widget> slivers = const <Widget>[]]
[{Key? key}, {AxisDirection axisDirection = AxisDirection.down}, {AxisDirection? crossAxisDirection}, {required ViewportOffset offset}, {Clip clipBehavior = Clip.hardEdge}, {List<Widget> slivers = const <Widget>[]}]
For class -> Visibility
[Key? key, required this.child, this.replacement = const SizedBox.shrink(), this.visible = true, this.maintainState = false, this.maintainAnimation = false, this.maintainSize = false, this.maintainSemantics = false, this.maintainInteractivity = false]
[{Key? key}, {required Widget child}, {Widget replacement = const SizedBox.shrink()}, {bool visible = true}, {bool maintainState = false}, {bool maintainAnimation = false}, {bool maintainSize = false}, {bool maintainSemantics = false}, {bool maintainInteractivity = false}]
For class -> SliverVisibility
[Key? key, required this.sliver, this.replacementSliver = const SliverToBoxAdapter(), this.visible = true, this.maintainState = false, this.maintainAnimation = false, this.maintainSize = false, this.maintainSemantics = false, this.maintainInteractivity = false]
[{Key? key}, {required Widget sliver}, {Widget replacementSliver = const SliverToBoxAdapter()}, {bool visible = true}, {bool maintainState = false}, {bool maintainAnimation = false}, {bool maintainSize = false}, {bool maintainSemantics = false}, {bool maintainInteractivity = false}]
For class -> _ProxyLayer
[this._layer]
[Layer _layer]
For class -> _MulticastCanvas
[required Canvas main, required Canvas screenshot]
[{required Canvas main}, {required Canvas screenshot}]
For class -> _ScreenshotContainerLayer
For class -> _ScreenshotData
[required this.target]
[{required RenderObject target}]
For class -> _ScreenshotPaintingContext
[required ContainerLayer containerLayer, required Rect estimatedBounds, required _ScreenshotData screenshotData]
[{required ContainerLayer containerLayer}, {required Rect estimatedBounds}, {required _ScreenshotData screenshotData}]
For class -> _DiagnosticsPathNode
[required this.node, required this.children, this.childIndex]
[{required DiagnosticsNode node}, {required List<DiagnosticsNode> children}, {int? childIndex}]
For class -> _InspectorReferenceData
[this.object]
[Object object]
For class -> _LocationCount
[required this.location, required this.id, required this.local]
[{required _Location location}, {required int id}, {required bool local}]
For class -> _ElementLocationStatsTracker
For class -> _WidgetForTypeTests
For class -> WidgetInspector
[Key? key, required this.child, required this.selectButtonBuilder]
[{Key? key}, {required Widget child}, {required Widget Function(BuildContext, void Function())? selectButtonBuilder}]
For class -> _WidgetInspectorState
[]
[]
For class -> InspectorSelection
For class -> _InspectorOverlay
[Key? key, required this.selection]
[{Key? key}, {required InspectorSelection selection}]
For class -> _RenderInspectorOverlay
[required InspectorSelection selection]
[{required InspectorSelection selection}]
For class -> _TransformedRect
[RenderObject object, RenderObject? ancestor]
[RenderObject object, RenderObject? ancestor]
For class -> _InspectorOverlayRenderState
[required this.overlayRect, required this.selected, required this.candidates, required this.tooltip, required this.textDirection]
[{required Rect overlayRect}, {required _TransformedRect selected}, {required List<_TransformedRect> candidates}, {required String tooltip}, {required TextDirection textDirection}]
For class -> _InspectorOverlayLayer
[required this.overlayRect, required this.selection, required this.rootRenderObject]
[{required Rect overlayRect}, {required InspectorSelection selection}, {required RenderObject? rootRenderObject}]
For class -> _HasCreationLocation
For class -> _Location
[required this.file, required this.line, required this.column, required this.name, required this.parameterLocations]
[{required String file}, {required int line}, {required int column}, {required String? name}, {required List<_Location>? parameterLocations}]
For class -> DevToolsDeepLinkProperty
[String description, String url]
[String description, String url]
For class -> InspectorSerializationDelegate
[this.groupName, this.summaryTree = false, this.maxDescendentsTruncatableNode = -1, this.expandPropertyValues = true, this.subtreeDepth = 1, this.includeProperties = false, required this.service, this.addAdditionalPropertiesCallback]
[{String? groupName}, {bool summaryTree = false}, {int maxDescendentsTruncatableNode = -1}, {bool expandPropertyValues = true}, {int subtreeDepth = 1}, {bool includeProperties = false}, {required WidgetInspectorService service}, {Map<String, Object>? Function(DiagnosticsNode, InspectorSerializationDelegate)? addAdditionalPropertiesCallback}]
For class -> WidgetSpan
[required this.child, ui.PlaceholderAlignment alignment = ui.PlaceholderAlignment.bottom, TextBaseline? baseline, TextStyle? style]
[{required Widget child}, {PlaceholderAlignment alignment = ui.PlaceholderAlignment.bottom}, {TextBaseline? baseline}, {TextStyle? style}]
For class -> WillPopScope
[Key? key, required this.child, required this.onWillPop]
[{Key? key}, {required Widget child}, {required Future<bool> Function()? onWillPop}]
For class -> _WillPopScopeState
For class -> theClass
[bool visibility]
[bool visibility]
For class -> RandomClass
[this.variable]
[T variable]
[this.variable, int i]
[T variable, int i]
For class -> One
[required String? one, Osef? two, String? three, required int? four, bool? five]
[{required String? one}, {dynamic two}, {String? three}, {required int? four}, {bool? five}]
For class -> Two
[required Osef? one, required bool? five]
[{required dynamic one}, {required bool? five}]
For class -> testImport
[this.visibility]
[bool visibility]
